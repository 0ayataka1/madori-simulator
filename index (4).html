<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>é–“å–ã‚Šå®¶å…·é…ç½®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ï½œ3Då¯¾å¿œãƒ»ç„¡æ–™</title>
<meta name="description" content="éƒ¨å±‹ã®é–“å–ã‚Šã«å®¶å…·ã‚’è‡ªç”±ã«é…ç½®ã§ãã‚‹ç„¡æ–™ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ã€‚3Dè¡¨ç¤ºãƒ»çª“é…ç½®ãƒ»å£ã®è‰²è¨­å®šã«å¯¾å¿œã€‚ã‚½ãƒ•ã‚¡ãƒ»ãƒ†ãƒ¼ãƒ–ãƒ«ãƒ»ãƒ™ãƒƒãƒ‰ãªã©è±Šå¯Œãªå®¶å…·ã§ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã€‚">
<meta name="keywords" content="é–“å–ã‚Š,å®¶å…·é…ç½®,ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼,3D,ã‚¤ãƒ³ãƒ†ãƒªã‚¢,ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ,ç„¡æ–™,å¼•è¶Šã—,æ–°å±…">
<meta property="og:title" content="é–“å–ã‚Šå®¶å…·é…ç½®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ï½œ3Då¯¾å¿œãƒ»ç„¡æ–™">
<meta property="og:description" content="éƒ¨å±‹ã®é–“å–ã‚Šã«å®¶å…·ã‚’è‡ªç”±ã«é…ç½®ã§ãã‚‹ç„¡æ–™ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ã€‚3Dè¡¨ç¤ºå¯¾å¿œã€‚å¼•è¶Šã—ãƒ»æ–°å±…ã®å®¶å…·ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã«ã€‚">
<meta property="og:type" content="website">
<meta name="twitter:card" content="summary">
<style>
@import url('https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;700&family=DM+Mono:wght@300;400&display=swap');
:root {
  --bg:#f5f0e8; --panel:#faf7f2; --border:#ddd8cc;
  --accent:#5c7a5c; --accent-edit:#c07a30;
  --text:#2a2520; --muted:#8a8278; --wall:#2a2520;
  --lp-w:188px; --rp-w:186px;
}
*{margin:0;padding:0;box-sizing:border-box;}
body{background:var(--bg);color:var(--text);font-family:'Noto Sans JP',sans-serif;height:100vh;height:100dvh;display:flex;flex-direction:column;overflow:hidden;-webkit-text-size-adjust:100%;}

/* iPad / mobile overrides */
@media (max-width: 900px){
  :root{ --lp-w:160px; --rp-w:150px; }
  header{ padding:6px 10px; gap:6px; flex-wrap:wrap; }
  .header-title{ font-size:11px; }
  .mode-btn{ font-size:10px; padding:5px 8px; }
  .floor-tabs button{ padding:4px 10px; font-size:11px; }
}
@media (max-width: 680px){
  :root{ --lp-w:0px; --rp-w:0px; }
  .left-panel{ display:none !important; }
  .info{ display:none !important; }
  .mobile-bar{ display:flex !important; }
}

header{background:var(--wall);color:#f5f0e8;padding:8px 12px;display:flex;align-items:center;gap:8px;flex-shrink:0;flex-wrap:wrap;}
.header-title{font-size:13px;font-weight:300;letter-spacing:.06em;flex:1;min-width:120px;}
.floor-tabs{display:flex;gap:3px;}
.tab{background:transparent;border:1px solid rgba(255,255,255,.2);color:rgba(255,255,255,.6);padding:6px 14px;cursor:pointer;font-family:'DM Mono',monospace;font-size:11px;border-radius:3px;transition:all .15s;-webkit-tap-highlight-color:transparent;}
.tab.active{background:var(--accent);border-color:var(--accent);color:#fff;}
.tab:hover:not(.active){border-color:rgba(255,255,255,.5);color:rgba(255,255,255,.9);}

.mode-toggle{display:flex;gap:3px;background:rgba(255,255,255,.08);border-radius:4px;padding:2px;}
.mode-btn{background:transparent;border:none;color:rgba(255,255,255,.5);padding:6px 12px;cursor:pointer;font-family:'DM Mono',monospace;font-size:10px;border-radius:3px;transition:all .15s;letter-spacing:.04em;-webkit-tap-highlight-color:transparent;min-height:36px;}
.mode-btn.active-edit{background:var(--accent-edit);color:#fff;}
.mode-btn.active-furn{background:var(--accent);color:#fff;}
.mode-btn.active-3d{background:#3a5a8a;color:#fff;}

.workspace{flex:1;display:flex;overflow:hidden;}

.left-panel{width:var(--lp-w);background:var(--panel);border-right:1px solid var(--border);display:flex;flex-direction:column;overflow:hidden;flex-shrink:0;}
.left-scroll{flex:1;overflow-y:auto;-webkit-overflow-scrolling:touch;}

.palette-section{padding:10px 12px;border-bottom:1px solid var(--border);}
.palette-label{font-family:'DM Mono',monospace;font-size:9px;color:var(--muted);letter-spacing:.2em;text-transform:uppercase;margin-bottom:7px;}
.furniture-grid{display:grid;grid-template-columns:1fr 1fr;gap:5px;}
.furniture-item{background:#fff;border:1.5px solid var(--border);border-radius:6px;padding:9px 4px;cursor:grab;text-align:center;transition:all .15s;user-select:none;-webkit-tap-highlight-color:transparent;touch-action:none;}
.furniture-item:hover{border-color:var(--accent);background:#f0f5f0;transform:translateY(-1px);box-shadow:0 3px 8px rgba(0,0,0,.1);}
.fi-icon{font-size:20px;display:block;margin-bottom:3px;}
.fi-name{font-size:9px;color:var(--muted);line-height:1.2;}

.edit-panel-inner{padding:12px;}
.ep-title{font-family:'DM Mono',monospace;font-size:9px;color:var(--muted);letter-spacing:.2em;text-transform:uppercase;margin-bottom:7px;margin-top:14px;}
.ep-title:first-child{margin-top:0;}
.ep-room-list{display:flex;flex-direction:column;gap:4px;}
.ep-room-item{background:#fff;border:1.5px solid var(--border);border-radius:5px;padding:9px 10px;cursor:pointer;transition:all .15s;-webkit-tap-highlight-color:transparent;}
.ep-room-item:hover{border-color:var(--accent-edit);}
.ep-room-item.active{border-color:var(--accent-edit);background:rgba(192,122,48,.07);}
.ep-room-name{font-size:11px;font-weight:700;}
.ep-room-size{font-family:'DM Mono',monospace;font-size:10px;color:var(--muted);}

.input-row{display:flex;align-items:center;gap:6px;margin-bottom:7px;}
.input-row label{font-size:10px;color:var(--muted);width:28px;flex-shrink:0;}
.input-row input[type=range]{flex:1;accent-color:var(--accent-edit);}
.input-val{font-family:'DM Mono',monospace;font-size:10px;color:var(--accent-edit);width:34px;text-align:right;flex-shrink:0;}

.hint-box{background:rgba(192,122,48,.08);border:1px solid rgba(192,122,48,.2);border-radius:4px;padding:8px;font-size:10px;color:#7a4a20;line-height:1.7;}

.canvas-wrap{flex:1;display:block;background:var(--bg);position:relative;overflow:hidden;touch-action:none;}
#mobileSheet{display:none;}

/* iPad / responsive */
@media (max-width: 1100px) and (orientation:landscape){
  :root{ --lp-w:160px; --rp-w:150px; }
}
@media (max-width: 900px){
  :root{ --lp-w:150px; --rp-w:140px; }
  header{ gap:6px; padding:6px 10px; }
  .header-title{ font-size:11px; }
  .mode-btn{ font-size:10px; padding:5px 7px; }
  .tab{ padding:4px 10px; font-size:11px; }
  .save-btn span:last-child{ display:none; }
}
@media (max-width: 680px){
  .left-panel,.info{ display:none !important; }
}
canvas{box-shadow:0 4px 24px rgba(0,0,0,.12);}
.canvas-hint{position:absolute;bottom:12px;left:50%;transform:translateX(-50%);font-family:'DM Mono',monospace;font-size:10px;color:var(--muted);background:rgba(245,240,232,.92);padding:5px 14px;border-radius:20px;border:1px solid var(--border);white-space:nowrap;pointer-events:none;}

.info{width:var(--rp-w);background:var(--panel);border-left:1px solid var(--border);display:flex;flex-direction:column;flex-shrink:0;overflow-y:auto;}
.info-section{padding:12px 14px;border-bottom:1px solid var(--border);}
.info-label{font-family:'DM Mono',monospace;font-size:9px;color:var(--muted);letter-spacing:.2em;text-transform:uppercase;margin-bottom:7px;}
.action-btn{width:100%;background:transparent;border:1px solid var(--border);color:var(--text);padding:9px 8px;cursor:pointer;font-family:'Noto Sans JP',sans-serif;font-size:11px;border-radius:4px;transition:all .15s;margin-bottom:5px;text-align:left;display:flex;align-items:center;gap:7px;-webkit-tap-highlight-color:transparent;min-height:38px;}
.action-btn:hover{background:var(--bg);border-color:var(--accent);}
.action-btn.danger:hover{background:#fff0f0;border-color:#cc4444;color:#cc4444;}
.rotate-row{display:flex;gap:4px;margin-top:6px;}
.rotate-btn{flex:1;background:var(--bg);border:1px solid var(--border);padding:6px;cursor:pointer;border-radius:3px;font-size:15px;transition:all .15s;}
.rotate-btn:hover{background:var(--accent);color:#fff;}
kbd{background:#e8e2d8;border:1px solid var(--border);border-radius:3px;padding:1px 4px;font-family:'DM Mono',monospace;font-size:9px;}
.legend-row{display:flex;align-items:center;gap:7px;margin-bottom:4px;}
/* Structural palette */
.struct-grid{display:grid;grid-template-columns:1fr 1fr;gap:5px;}
.struct-item{background:#fff;border:1.5px solid var(--border);border-radius:6px;padding:9px 4px;cursor:grab;text-align:center;transition:all .15s;user-select:none;-webkit-tap-highlight-color:transparent;touch-action:none;}
.struct-item:hover{border-color:#555;background:#f5f5f0;transform:translateY(-1px);box-shadow:0 3px 8px rgba(0,0,0,.12);}
.struct-item:active{cursor:grabbing;}
.struct-icon{font-size:20px;display:block;margin-bottom:3px;}
.struct-name{font-size:9px;color:var(--muted);line-height:1.2;}
.struct-hint{background:rgba(42,37,32,.06);border:1px solid rgba(42,37,32,.1);border-radius:4px;padding:8px;font-size:10px;color:#444;line-height:1.7;margin-bottom:8px;}
.win-item{background:#f0f6fa;border:1.5px solid #a8c8dc;border-radius:6px;padding:9px 4px;cursor:grab;text-align:center;transition:all .15s;user-select:none;-webkit-tap-highlight-color:transparent;touch-action:none;}
.win-item:hover{border-color:#5c9fc0;background:#e4f0f8;transform:translateY(-1px);box-shadow:0 3px 8px rgba(92,159,192,.18);}
.win-item:active{cursor:grabbing;}
/* Window info panel */
.win-panel{padding:12px 14px;border-bottom:1px solid var(--border);}
.win-panel .win-type-row{display:flex;gap:4px;flex-wrap:wrap;margin-top:6px;}
.win-type-btn{background:rgba(92,159,192,.1);border:1px solid #a8c8dc;color:#2a6a8a;
  padding:3px 8px;border-radius:10px;cursor:pointer;font-size:10px;transition:all .12s;}
.win-type-btn.active{background:#5c9fc0;color:#fff;border-color:#5c9fc0;}

/* â”€â”€ RESPONSIVE / iPAD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
@media (max-width: 900px){
  header{ padding:6px 8px; gap:6px; }
  .header-title{ display:none; }
  .tab{ padding:5px 10px; font-size:10px; }
  .mode-btn{ padding:5px 9px; font-size:9px; min-height:32px; }
  .left-panel{ width:160px; }
  .info{ width:150px; }
  .fi-icon{ font-size:18px; }
  .fi-name{ font-size:8px; }
  .struct-icon{ font-size:18px; }
  .struct-name{ font-size:8px; }
  .palette-section{ padding:8px 8px; }
  .info-section{ padding:8px 10px; }
  .color-swatch{ border-radius:3px; }
}

@media (max-width: 680px){
  /* Phone: hide side panels, show bottom bar */
  .left-panel{ width:140px; }
  .info{ width:130px; }
  .mode-btn{ padding:4px 7px; font-size:9px; }
}

/* Prevent iOS rubber-band scroll on workspace */
.workspace{ overscroll-behavior:none; }
canvas{ display:block; }

/* Furniture style panel */
.style-panel { border-bottom: 1px solid var(--border); padding: 12px 14px; }
.color-grid { display: grid; grid-template-columns: repeat(6,1fr); gap: 4px; margin-bottom: 8px; }
.color-swatch {
  width: 100%; aspect-ratio: 1;
  border-radius: 4px; cursor: pointer;
  border: 2px solid transparent;
  transition: all .15s;
  -webkit-tap-highlight-color:transparent;
}
.color-swatch:hover { transform: scale(1.15); }
.color-swatch.active { border-color: #2a2520; box-shadow: 0 0 0 1px #2a2520; }

.style-row { display: flex; gap: 4px; margin-bottom: 6px; flex-wrap: wrap; }
.style-chip {
  background: #fff;
  border: 1.5px solid var(--border);
  border-radius: 12px;
  padding: 3px 8px;
  font-size: 10px;
  cursor: pointer;
  transition: all .15s;
  white-space: nowrap;
}
.style-chip:hover { border-color: var(--accent); color: var(--accent); }
.style-chip.active { background: var(--accent); border-color: var(--accent); color: #fff; }

.size-row { display: flex; align-items: center; gap: 5px; margin-bottom: 5px; }
.size-row label { font-size: 10px; color: var(--muted); width: 28px; }
.size-row input[type=range] { flex:1; accent-color: var(--accent); }
.size-row .sv { font-family:'DM Mono',monospace; font-size:10px; color:var(--accent); width:30px; text-align:right; }
.rotate-quick{display:flex;gap:3px;margin-top:4px;margin-bottom:2px;}
.rotate-quick button{flex:1;background:rgba(0,0,0,.05);border:1px solid var(--border);
  color:var(--text);padding:4px 0;border-radius:3px;cursor:pointer;font-size:10px;
  font-family:'DM Mono',monospace;transition:all .12s;}
.rotate-quick button:hover{background:var(--accent);color:#fff;}
/* Coordinate input panel */
.coord-grid{display:flex;flex-direction:column;gap:4px;}
.coord-row{display:flex;align-items:center;gap:4px;}
.coord-row label{font-size:10px;font-family:'DM Mono',monospace;color:var(--muted);
  width:14px;text-align:right;flex-shrink:0;font-weight:600;}
.coord-input-wrap{display:flex;align-items:center;flex:1;border:1px solid var(--border);
  border-radius:4px;overflow:hidden;background:#fff;}
.coord-input-wrap input[type=number]{flex:1;border:none;outline:none;padding:3px 4px;
  font-size:11px;font-family:'DM Mono',monospace;color:var(--text);text-align:center;
  background:transparent;min-width:0;-moz-appearance:textfield;}
.coord-input-wrap input[type=number]::-webkit-inner-spin-button,
.coord-input-wrap input[type=number]::-webkit-outer-spin-button{-webkit-appearance:none;}
.coord-input-wrap:focus-within{border-color:var(--accent);box-shadow:0 0 0 2px rgba(92,122,92,.15);}
.coord-step{background:rgba(0,0,0,.04);border:none;border-right:1px solid var(--border);
  color:var(--muted);padding:0 5px;cursor:pointer;font-size:13px;line-height:1;
  transition:background .1s;flex-shrink:0;height:100%;min-height:22px;}
.coord-step:last-child{border-right:none;border-left:1px solid var(--border);}
.coord-step:hover{background:var(--accent);color:#fff;}
.coord-unit{font-size:9px;color:var(--muted);width:10px;flex-shrink:0;font-family:'DM Mono',monospace;}
.coord-divider{height:1px;background:var(--border);margin:2px 0;}

.legend-dot{width:11px;height:11px;border-radius:2px;flex-shrink:0;border:1px solid rgba(0,0,0,.1);}

.ob-panel { display:none; }
.ob-panel.active { display:block; animation: obFadeIn .3s ease; }
@keyframes obFadeIn { from{opacity:0;transform:translateY(12px)} to{opacity:1;transform:none} }
.ob-emoji { font-size:40px;margin-bottom:12px; }
.ob-title { color:#fff;font-size:24px;font-weight:700;margin:0 0 8px; }
.ob-sub   { color:rgba(255,255,255,.65);font-size:14px;line-height:1.7;margin:0 0 20px; }
.ob-step-dot {
  flex:1;height:4px;border-radius:2px;background:rgba(255,255,255,.15);
  transition:background .3s;
}
.ob-step-dot.active { background:#5c9a5c; }
.ob-step-dot.done   { background:rgba(92,154,92,.5); }
.ob-card-grid {
  display:grid;grid-template-columns:repeat(auto-fill,minmax(110px,1fr));gap:10px;
  margin-bottom:24px;
}
.ob-card {
  background:rgba(255,255,255,.07);border:1.5px solid rgba(255,255,255,.12);
  border-radius:12px;padding:14px 8px;cursor:pointer;
  display:flex;flex-direction:column;align-items:center;gap:6px;
  color:#fff;font-size:13px;transition:all .15s;
  font-family:'Noto Sans JP',sans-serif;line-height:1.4;text-align:center;
}
.ob-card small { font-size:10px;color:rgba(255,255,255,.5); }
.ob-card:hover  { background:rgba(92,154,92,.25);border-color:#5c9a5c;transform:translateY(-2px); }
.ob-card.selected { background:rgba(92,154,92,.35);border-color:#7aba7a;box-shadow:0 0 0 2px rgba(92,154,92,.3); }
.ob-room-row {
  display:flex;align-items:center;gap:10px;
  background:rgba(255,255,255,.06);border-radius:10px;padding:12px 14px;
}
.ob-room-row label { color:rgba(255,255,255,.8);font-size:13px;min-width:80px;flex-shrink:0; }
.ob-room-row .ob-dim {
  display:flex;align-items:center;gap:6px;flex:1;
}
.ob-room-row input[type=number] {
  width:62px;background:rgba(255,255,255,.12);border:1px solid rgba(255,255,255,.2);
  border-radius:6px;color:#fff;padding:5px 8px;font-size:13px;text-align:center;
  font-family:'DM Mono',monospace;outline:none;-moz-appearance:textfield;
}
.ob-room-row input[type=number]::-webkit-inner-spin-button { -webkit-appearance:none; }
.ob-room-row input[type=number]:focus { border-color:#5c9a5c; }
.ob-room-row .ob-unit { color:rgba(255,255,255,.4);font-size:11px; }
.ob-start-btn {
  width:100%;padding:16px;background:linear-gradient(135deg,#5c9a5c,#3a7a3a);
  border:none;border-radius:12px;color:#fff;font-size:16px;font-weight:700;
  cursor:pointer;transition:all .15s;font-family:'Noto Sans JP',sans-serif;
}
.ob-start-btn:hover { transform:translateY(-2px);box-shadow:0 6px 20px rgba(92,154,92,.4); }

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   MOBILE UI  (â‰¤ 680px)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
@media (max-width: 680px){
  /* Reset existing panel hiding */
  .left-panel{ display:none !important; }
  
  /* Header: single compact row */
  header{
    padding:4px 8px;
    gap:4px;
    flex-wrap:nowrap;
    height:44px;
    min-height:44px;
    overflow:hidden;
  }
  .header-title{ display:none; }
  .floor-tabs{ gap:2px; }
  .floor-tabs button{ padding:4px 8px; font-size:11px; }
  .mode-toggle{ gap:2px; }
  .mode-btn{ font-size:11px; padding:5px 8px; }
  /* Save bar compact */
  .save-bar{ gap:3px; }
  .save-btn{ padding:4px 8px; font-size:11px; }
  .save-btn span:last-child{ display:none; } /* hide text, keep icon */
  #saveStatus{ display:none; }
  
  /* 3D mode button hides bottom bar */
  body.mode-3d #mobileBottomBar{ display:none !important; }
  
  /* tap target minimum 44px for accessibility */
  .mob-nav-btn, .sheet-tab{ min-height:44px; }
  
  /* prevent pull-to-refresh interfering with sheet */
  #mobileSheet{ overscroll-behavior:contain; }
  
  /* Canvas takes remaining height */
  .workspace{ flex-direction:column; height:calc(100dvh - 44px); }
  canvas-wrap, .canvas-wrap{ flex:1; min-height:0; }
  #canvasWrap{ flex:1; min-height:0; }
  
  /* Bottom safe area padding for canvas */
  #canvasWrap{ padding-bottom:56px; }
  
  /* â”€â”€ Bottom Navigation Bar â”€â”€ */
  #mobileBottomBar{
    position:fixed;
    bottom:0; left:0; right:0;
    height:56px;
    background:#1e2a1e;
    border-top:1px solid rgba(255,255,255,.12);
    display:flex;
    align-items:center;
    justify-content:space-around;
    z-index:200;
    padding-bottom:env(safe-area-inset-bottom);
  }
  .mob-nav-btn{
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:2px;
    padding:6px 12px;
    border:none;
    background:transparent;
    color:rgba(255,255,255,.5);
    font-family:'Noto Sans JP',sans-serif;
    font-size:9px;
    cursor:pointer;
    border-radius:8px;
    transition:all .15s;
    min-width:56px;
  }
  .mob-nav-btn .mob-icon{ font-size:20px; line-height:1; }
  .mob-nav-btn.active{ color:#8fbc8f; }
  .mob-nav-btn.active .mob-icon-bg{
    background:rgba(143,188,143,.15);
    border-radius:12px;
    padding:2px 8px;
  }
  
  /* â”€â”€ Bottom Sheet â”€â”€ */
  #mobileSheet{
    display:flex;
    position:fixed;
    left:0; right:0;
    bottom:-100%;
    height:72vh;
    background:#242e24;
    border-radius:16px 16px 0 0;
    border-top:1px solid rgba(255,255,255,.15);
    z-index:300;
    transition:bottom .3s cubic-bezier(.4,0,.2,1);
    display:flex;
    flex-direction:column;
    overflow:hidden;
  }
  #mobileSheet.open{ bottom:56px; }
  
  /* Sheet drag handle */
  #sheetHandle{
    width:36px; height:4px;
    background:rgba(255,255,255,.2);
    border-radius:2px;
    margin:10px auto 4px;
    flex-shrink:0;
  }
  
  /* Sheet tab bar */
  #sheetTabs{
    display:flex;
    border-bottom:1px solid rgba(255,255,255,.1);
    flex-shrink:0;
  }
  .sheet-tab{
    flex:1;
    padding:8px 4px;
    border:none;
    background:transparent;
    color:rgba(255,255,255,.4);
    font-size:12px;
    font-family:'Noto Sans JP',sans-serif;
    cursor:pointer;
    border-bottom:2px solid transparent;
    transition:all .15s;
  }
  .sheet-tab.active{
    color:#8fbc8f;
    border-bottom-color:#8fbc8f;
  }
  
  /* Sheet content panels */
  #sheetContent{ flex:1; overflow-y:auto; -webkit-overflow-scrolling:touch; }
  .sheet-panel{ display:none; }
  .sheet-panel.active{ display:block; }
  
  /* Furniture grid in sheet: 3 columns on mobile */
  #sheetFurniture .furniture-grid{ grid-template-columns:1fr 1fr 1fr; gap:6px; padding:4px; }
  #sheetFurniture .palette-section{ padding:8px 10px; }
  #sheetFurniture .palette-label{ font-size:10px; }
  #sheetFurniture .furniture-item{ padding:8px 4px; }
  #sheetFurniture .fi-icon{ font-size:20px; }
  #sheetFurniture .fi-name{ font-size:9px; }
  
  /* Edit controls in sheet */
  #sheetEdit{ padding:12px; }
  #sheetEdit .ep-title{ font-size:10px; color:rgba(255,255,255,.4); text-transform:uppercase; letter-spacing:.06em; margin-bottom:6px; }
  #sheetEdit .coord-row{ display:flex; align-items:center; gap:6px; margin-bottom:8px; }
  #sheetEdit .coord-row label{ font-size:11px; width:24px; flex-shrink:0; }
  #sheetEdit .coord-input-wrap{ flex:1; display:flex; align-items:center; background:rgba(255,255,255,.08); border-radius:6px; }
  #sheetEdit .coord-step{ width:32px; height:32px; border:none; background:transparent; color:#8fbc8f; font-size:16px; cursor:pointer; }
  #sheetEdit input[type=number]{ background:transparent; border:none; outline:none; color:#fff; font-size:13px; text-align:center; width:100%; padding:4px; }
  #sheetEdit .coord-unit{ font-size:10px; color:rgba(255,255,255,.4); width:16px; }
  
  /* Zone add buttons in sheet */
  #sheetEdit .zone-grid{ display:grid; grid-template-columns:1fr 1fr; gap:4px; margin-bottom:10px; }
  #sheetEdit .action-btn{ padding:8px; font-size:11px; justify-content:center; }
  
  /* Room list in sheet */
  .ep-room-item{ padding:8px 10px; }
  
  /* Save/share in sheet */
  #sheetSave{ padding:16px; display:flex; flex-direction:column; gap:10px; }
  #sheetSave .save-btn{ width:100%; justify-content:center; padding:12px; font-size:13px; border-radius:10px; }
}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     ONBOARDING WIZARD OVERLAY
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="onboardingOverlay" style="
  position:fixed;inset:0;z-index:9999;
  background:linear-gradient(135deg,#1a2a1a 0%,#2a3a2a 50%,#1a2820 100%);
  display:flex;align-items:center;justify-content:center;
  font-family:'Noto Sans JP',sans-serif;
  overflow-y:auto;padding:16px;box-sizing:border-box;">

  <div style="width:100%;max-width:520px;">

    <!-- Progress bar -->
    <div style="display:flex;gap:6px;margin-bottom:28px;" id="obProgress">
      <div class="ob-step-dot active" id="dot0"></div>
      <div class="ob-step-dot" id="dot1"></div>
      <div class="ob-step-dot" id="dot2"></div>
      <div class="ob-step-dot" id="dot3"></div>
      <div class="ob-step-dot" id="dot4"></div>
    </div>

    <!-- Step panels -->
    <div id="ob0" class="ob-panel active">
      <div class="ob-emoji">ğŸ </div>
      <h1 class="ob-title">é–“å–ã‚Šã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼</h1>
      <p class="ob-sub">ä½ã‚€äºˆå®šã®éƒ¨å±‹ã®é–“å–ã‚Šã‚’ä¸€ç·’ã«è¨­å®šã—ã¾ã—ã‚‡ã†ã€‚<br>3ã€œ4åˆ†ã§ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ãŒä½¿ãˆã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚</p>
      <div class="ob-card-grid" id="buildingTypeGrid">
        <button class="ob-card" onclick="selectBuildingType('house')">ğŸ¡<span>ä¸€æˆ¸å»ºã¦</span></button>
        <button class="ob-card" onclick="selectBuildingType('mansion')">ğŸ¢<span>ãƒãƒ³ã‚·ãƒ§ãƒ³</span></button>
        <button class="ob-card" onclick="selectBuildingType('apartment')">ğŸ <span>ã‚¢ãƒ‘ãƒ¼ãƒˆ</span></button>
        <button class="ob-card" onclick="selectBuildingType('other')">ğŸ“¦<span>ãã®ä»–</span></button>
      </div>
    </div>

    <div id="ob1" class="ob-panel">
      <div class="ob-emoji">ğŸ—ºï¸</div>
      <h1 class="ob-title">é–“å–ã‚Šã‚’æ•™ãˆã¦ãã ã•ã„</h1>
      <p class="ob-sub">ä½ã‚€äºˆå®šï¼ˆã¾ãŸã¯æ¤œè¨ä¸­ï¼‰ã®éƒ¨å±‹ã®é–“å–ã‚Šã¯ï¼Ÿ</p>
      <div class="ob-card-grid" id="layoutTypeGrid">
        <button class="ob-card" onclick="selectLayout('1r')">ğŸŸ¦<span>ãƒ¯ãƒ³ãƒ«ãƒ¼ãƒ <br><small>ã€œ25ã¡</small></span></button>
        <button class="ob-card" onclick="selectLayout('1k')">ğŸŸ§<span>1K / 1DK<br><small>20ã€œ35ã¡</small></span></button>
        <button class="ob-card" onclick="selectLayout('1ldk')">ğŸŸ©<span>1LDK<br><small>30ã€œ50ã¡</small></span></button>
        <button class="ob-card" onclick="selectLayout('2ldk')">ğŸŸ¨<span>2LDK<br><small>45ã€œ70ã¡</small></span></button>
        <button class="ob-card" onclick="selectLayout('3ldk')">ğŸŸ¥<span>3LDK<br><small>60ã€œ90ã¡</small></span></button>
        <button class="ob-card" onclick="selectLayout('4ldk')">ğŸŸª<span>4LDKä»¥ä¸Š<br><small>80ã¡ã€œ</small></span></button>
      </div>
    </div>

    <div id="ob2" class="ob-panel">
      <div class="ob-emoji">ğŸ“</div>
      <h1 class="ob-title">éƒ¨å±‹ã®ã‚µã‚¤ã‚º</h1>
      <p class="ob-sub">ä¸»ãªãŠéƒ¨å±‹ã®ã‚µã‚¤ã‚ºã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚<br><small style="color:rgba(255,255,255,.5);">ã‚ã‹ã‚‰ãªã„å ´åˆã¯ç›®å®‰ã®ã¾ã¾é€²ã‚ã¦OKã§ã™</small></p>
      <div id="obRoomInputs" style="display:flex;flex-direction:column;gap:10px;"></div>
      <div style="margin-top:8px;font-size:11px;color:rgba(255,255,255,.4);">
        â€» 1ç•³ â‰ˆ 1.65ã¡ã€€ã€€6ç•³ â‰ˆ 9.9ã¡ â‰ˆ 3.3mÃ—3.0m
      </div>
    </div>

    <div id="ob3" class="ob-panel">
      <div class="ob-emoji">ğŸ‘¥</div>
      <h1 class="ob-title">ä¸–å¸¯æ§‹æˆ</h1>
      <p class="ob-sub">èª°ã¨ä½ã¿ã¾ã™ã‹ï¼Ÿï¼ˆå®¶å…·ã®ææ¡ˆã«ä½¿ã„ã¾ã™ï¼‰</p>
      <div class="ob-card-grid">
        <button class="ob-card" onclick="selectHousehold('single')">ğŸ§‘<span>ä¸€äººæš®ã‚‰ã—</span></button>
        <button class="ob-card" onclick="selectHousehold('couple')">ğŸ‘«<span>ã‚«ãƒƒãƒ—ãƒ«ãƒ»<br>å¤«å©¦2äºº</span></button>
        <button class="ob-card" onclick="selectHousehold('family_small')">ğŸ‘¨â€ğŸ‘©â€ğŸ‘¦<span>å®¶æ—<br>ï¼ˆå­1ã€œ2äººï¼‰</span></button>
        <button class="ob-card" onclick="selectHousehold('family_large')">ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦<span>å®¶æ—<br>ï¼ˆå­3äººä»¥ä¸Šï¼‰</span></button>
        <button class="ob-card" onclick="selectHousehold('roommate')">ğŸ¤<span>ãƒ«ãƒ¼ãƒ ã‚·ã‚§ã‚¢</span></button>
        <button class="ob-card" onclick="selectHousehold('other')">â“<span>ãã®ä»–</span></button>
      </div>
    </div>

    <div id="ob4" class="ob-panel">
      <div class="ob-emoji">âœ…</div>
      <h1 class="ob-title">è¨­å®šå®Œäº†ï¼</h1>
      <div id="obSummary" style="background:rgba(255,255,255,.08);border-radius:12px;
        padding:16px 20px;margin:16px 0;font-size:13px;line-height:2;color:rgba(255,255,255,.9);">
      </div>
      <p class="ob-sub" style="font-size:12px;">ã“ã®è¨­å®šã§ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ã‚’é–‹å§‹ã—ã¾ã™ã€‚<br>ã‚ã¨ã‹ã‚‰é–“å–ã‚Šç·¨é›†ãƒ¢ãƒ¼ãƒ‰ã§è‡ªç”±ã«å¤‰æ›´ã§ãã¾ã™ã€‚</p>
      <button class="ob-start-btn" onclick="finishOnboarding()">
        ğŸš€ ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ã‚’é–‹å§‹ã™ã‚‹
      </button>
      <button onclick="obBack()" style="width:100%;background:none;border:1px solid rgba(255,255,255,.2);
        color:rgba(255,255,255,.5);padding:10px;border-radius:8px;cursor:pointer;
        font-size:12px;margin-top:8px;">â† ä¿®æ­£ã™ã‚‹</button>
    </div>

  </div>

    <!-- ob5: ä¸€è»’å®¶ - éšæ•°é¸æŠ -->
    <div id="ob5" class="ob-panel">
      <div class="ob-emoji">ğŸ—ï¸</div>
      <h1 class="ob-title">ä½•éšå»ºã¦ã§ã™ã‹ï¼Ÿ</h1>
      <p class="ob-sub">åœ°ä¸Šã®éšæ•°ã‚’é¸ã‚“ã§ãã ã•ã„</p>
      <div class="ob-card-grid" style="grid-template-columns:repeat(4,1fr);">
        <button class="ob-card" onclick="selectFloorCount(2)">2<span>éšå»ºã¦</span></button>
        <button class="ob-card" onclick="selectFloorCount(3)">3<span>éšå»ºã¦</span></button>
        <button class="ob-card" onclick="selectFloorCount(4)">4<span>éšå»ºã¦</span></button>
        <button class="ob-card" onclick="selectFloorCount(5)">5<span>éšå»ºã¦ä»¥ä¸Š</span></button>
      </div>
    </div>

    <!-- ob6: ä¸€è»’å®¶ - å„éšã®ç”¨é€” (dynamically filled) -->
    <div id="ob6" class="ob-panel">
      <div class="ob-emoji">ğŸ </div>
      <h1 class="ob-title" id="ob6Title">1éšã®æ§‹æˆ</h1>
      <p class="ob-sub">ã“ã®éšã«ã¯ä½•ãŒã‚ã‚Šã¾ã™ã‹ï¼Ÿ<br><small style="color:rgba(255,255,255,.45);">è¤‡æ•°é¸æŠã§ãã¾ã™</small></p>
      <div id="ob6RoomGrid" class="ob-card-grid" style="grid-template-columns:repeat(3,1fr);gap:8px;"></div>
      <div style="margin-top:12px;">
        <div style="color:rgba(255,255,255,.5);font-size:11px;margin-bottom:4px;">ãã®ä»–ãƒ»ãƒ¡ãƒ¢ï¼ˆä»»æ„ï¼‰</div>
        <input type="text" id="ob6Note"
          style="width:100%;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.15);
                 border-radius:8px;color:#fff;padding:8px 12px;font-size:13px;
                 font-family:'Noto Sans JP',sans-serif;box-sizing:border-box;outline:none;"
          placeholder="ä¾‹: ãƒ«ãƒ¼ãƒ•ãƒãƒ«ã‚³ãƒ‹ãƒ¼ã€ã‚¦ã‚©ãƒ¼ã‚¯ã‚¤ãƒ³ã‚¯ãƒ­ãƒ¼ã‚¼ãƒƒãƒˆãªã©">
      </div>
      <div style="display:flex;gap:8px;margin-top:16px;">
        <button onclick="obBack()" style="flex:1;background:rgba(255,255,255,.08);
          border:1px solid rgba(255,255,255,.15);color:rgba(255,255,255,.6);padding:12px;
          border-radius:10px;cursor:pointer;font-size:13px;font-family:'Noto Sans JP',sans-serif;">â† æˆ»ã‚‹</button>
        <button onclick="nextFloorDetail()" style="flex:2;" class="ob-start-btn">æ¬¡ã¸ â†’</button>
      </div>
    </div>

  </div>
</div>


<header>
  <div class="header-title">é–“å–ã‚Š ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼</div>
  <div class="floor-tabs">
    <button class="tab" onclick="setFloor('1f',event)">1F</button>
    <button class="tab active" onclick="setFloor('2f',event)">2F</button>
    <button class="tab" onclick="setFloor('3f',event)">3F</button>
    <button class="tab" onclick="setFloor('rf',event)">RF</button>
  </div>
  <div style="font-family:'DM Mono',monospace;font-size:10px;color:rgba(255,255,255,.5);line-height:1.5;text-align:right;white-space:nowrap;">
    <span id="floorAreaLabel" style="color:rgba(180,220,180,.8);font-size:11px;">23.50 mÂ²</span><br>
    <span>1ãƒ•ãƒ­ã‚¢é¢ç©</span>
  </div>
  <div class="mode-toggle">
    <button class="mode-btn" id="modeEditBtn" onclick="setMode('edit')">âœï¸ ç·¨é›†</button>
    <button class="mode-btn active-furn" id="modeFurnBtn" onclick="setMode('furniture')">ğŸ›‹ å®¶å…·</button>
    <button class="mode-btn" id="mode3dBtn" onclick="setMode('3d')">ğŸ  3D</button>
  </div>
  <!-- Save/Load controls -->
  <div class="save-bar">
    <button class="save-btn" id="saveBtn" onclick="saveToCloud()" title="ã‚¯ãƒ©ã‚¦ãƒ‰ã«ä¿å­˜ï¼ˆå…¨ç«¯æœ«ã§å…±æœ‰ï¼‰">
      <span id="saveBtnIcon">â˜ï¸</span><span> ä¿å­˜</span>
    </button>
    <button class="save-btn" onclick="loadFromCloud()" title="ã‚¯ãƒ©ã‚¦ãƒ‰ã‹ã‚‰èª­ã¿è¾¼ã¿" style="background:rgba(60,80,120,.8);">
      <span>ğŸ“‚ èª­è¾¼</span>
    </button>
    <button class="save-btn" onclick="showShareModal()" title="é–“å–ã‚Šã‚’å…±æœ‰" style="background:rgba(80,60,120,.8);">
      <span>ğŸ”— å…±æœ‰</span>
    </button>
    <div id="saveStatus" class="save-status"></div>
  </div>

  <!-- Share Modal -->
  <div id="shareModal" style="display:none;position:fixed;inset:0;z-index:10000;
    background:rgba(0,0,0,.7);align-items:center;justify-content:center;">
    <div style="background:#2a3428;border:1px solid rgba(255,255,255,.15);border-radius:16px;
      padding:24px;width:min(480px,90vw);font-family:'Noto Sans JP',sans-serif;">
      <div style="font-size:16px;font-weight:700;color:#fff;margin-bottom:8px;">ğŸ”— é–“å–ã‚Šã‚’å…±æœ‰</div>
      <div style="font-size:12px;color:rgba(255,255,255,.55);margin-bottom:16px;line-height:1.7;">
        ã“ã®URLã‚’æ—¦é‚£ã•ã‚“ã‚„å®¶æ—ã«é€ã‚‹ã¨ã€åŒã˜é–“å–ã‚ŠãŒé–‹ã‘ã¾ã™ã€‚<br>
        ç›¸æ‰‹ãŒç·¨é›†ã—ã¦å…±æœ‰URLã‚’é€ã‚Šè¿”ã™ã“ã¨ã‚‚å¯èƒ½ã§ã™ã€‚
      </div>
      <div style="display:flex;gap:8px;margin-bottom:12px;">
        <input id="shareUrlInput" type="text" readonly
          style="flex:1;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.2);
                 border-radius:8px;color:#fff;padding:8px 12px;font-size:11px;
                 font-family:'DM Mono',monospace;outline:none;min-width:0;">
        <button onclick="copyShareUrl()" id="copyShareBtn"
          style="background:#5c7a5c;border:none;border-radius:8px;color:#fff;
                 padding:8px 14px;cursor:pointer;font-size:12px;white-space:nowrap;
                 font-family:'Noto Sans JP',sans-serif;">
          ã‚³ãƒ”ãƒ¼
        </button>
      </div>
      <div id="shareUrlWarn" style="font-size:10px;color:rgba(255,200,100,.8);
        margin-bottom:12px;display:none;">
        âš ï¸ URLãŒé•·ã™ãã‚‹å ´åˆã¯ãƒ–ãƒ©ã‚¦ã‚¶ã«ã‚ˆã£ã¦é–‹ã‘ãªã„ã“ã¨ãŒã‚ã‚Šã¾ã™
      </div>
      <div style="display:flex;gap:8px;justify-content:flex-end;">
        <button onclick="document.getElementById('shareModal').style.display='none'"
          style="background:rgba(255,255,255,.1);border:1px solid rgba(255,255,255,.15);
                 border-radius:8px;color:rgba(255,255,255,.6);padding:8px 16px;
                 cursor:pointer;font-size:12px;font-family:'Noto Sans JP',sans-serif;">
          é–‰ã˜ã‚‹
        </button>
      </div>
    </div>
  </div>
</header>

<div class="workspace">
  <div class="left-panel">
    <!-- FURNITURE PALETTE -->
    <div id="furniturePalette" class="left-scroll">
      <div class="palette-section">
        <div class="palette-label">ãƒªãƒ“ãƒ³ã‚°</div>
        <div class="furniture-grid">
          <div class="furniture-item" draggable="true" data-type="sofa3" data-w="3" data-h="1.5" data-label="ã‚½ãƒ•ã‚¡(3äºº)" data-color="#b8d4b8"><span class="fi-icon">ğŸ›‹ï¸</span><div class="fi-name">ã‚½ãƒ•ã‚¡<br>3äººæ›ã‘</div></div>
          <div class="furniture-item" draggable="true" data-type="sofa1" data-w="1.5" data-h="1.5" data-label="1äººæ›ã‘" data-color="#c8e0c8"><span class="fi-icon">ğŸª‘</span><div class="fi-name">ã‚½ãƒ•ã‚¡<br>1äººæ›ã‘</div></div>
          <div class="furniture-item" draggable="true" data-type="table_low" data-w="1.2" data-h="0.6" data-label="ã‚»ãƒ³ã‚¿ãƒ¼ãƒ†ãƒ¼ãƒ–ãƒ«" data-color="#d4c4a0"><span class="fi-icon">ğŸŸ«</span><div class="fi-name">ã‚»ãƒ³ã‚¿ãƒ¼<br>ãƒ†ãƒ¼ãƒ–ãƒ«</div></div>
          <div class="furniture-item" draggable="true" data-type="sofa_l" data-w="2.4" data-h="2.0" data-label="Lã‚½ãƒ•ã‚¡ 240Ã—200" data-color="#b8d4b8" data-style="NE"><span class="fi-icon">ğŸ›‹ï¸</span><div class="fi-name">Lå­—<br>ã‚½ãƒ•ã‚¡</div></div>
          <div class="furniture-item" draggable="true" data-type="tv" data-w="1.5" data-h="0.3" data-label="ãƒ†ãƒ¬ãƒ“å°" data-color="#8a8080"><span class="fi-icon">ğŸ“º</span><div class="fi-name">ãƒ†ãƒ¬ãƒ“å°</div></div>
        </div>
      </div>
      <!-- WINDOW PALETTE -->
      <div class="palette-section">
        <div class="palette-label">ğŸªŸ çª“</div>
        <div class="furniture-grid">
          <div class="win-item" draggable="true"
               data-wtype="sliding" data-ww="0.9" data-label="å¼•ãé•ã„çª“ W90">
            <span class="fi-icon">ğŸªŸ</span><div class="fi-name">å¼•ãé•ã„<br>W90cm</div>
          </div>
          <div class="win-item" draggable="true"
               data-wtype="sliding" data-ww="1.6" data-label="æƒãå‡ºã—çª“ W160">
            <span class="fi-icon">ğŸªŸ</span><div class="fi-name">æƒãå‡ºã—<br>W160cm</div>
          </div>
          <div class="win-item" draggable="true"
               data-wtype="sliding" data-ww="1.2" data-label="å¼•ãé•ã„çª“ W120">
            <span class="fi-icon">ğŸªŸ</span><div class="fi-name">å¼•ãé•ã„<br>W120cm</div>
          </div>
          <div class="win-item" draggable="true"
               data-wtype="fixed" data-ww="0.6" data-label="FIXçª“ W60">
            <span class="fi-icon">ğŸ”²</span><div class="fi-name">FIXçª“<br>W60cm</div>
          </div>
          <div class="win-item" draggable="true"
               data-wtype="slit" data-ww="0.25" data-label="ã‚¹ãƒªãƒƒãƒˆçª“ W25">
            <span class="fi-icon">â–¬</span><div class="fi-name">ã‚¹ãƒªãƒƒãƒˆ<br>W25cm</div>
          </div>
          <div class="win-item" draggable="true"
               data-wtype="sliding" data-ww="2.0" data-label="å¤§çª“ W200">
            <span class="fi-icon">ğŸ</span><div class="fi-name">å¤§çª“<br>W200cm</div>
          </div>
        </div>
      </div>
      <div class="palette-section">
        <div class="palette-label">ãƒ€ã‚¤ãƒ‹ãƒ³ã‚°</div>
        <div class="furniture-grid">
          <div class="furniture-item" draggable="true" data-type="dining4" data-w="1.4" data-h="0.8" data-label="4äººæ›ã‘ 140Ã—80" data-color="#d4b896"><span class="fi-icon">ğŸ½ï¸</span><div class="fi-name">ãƒ†ãƒ¼ãƒ–ãƒ«<br>4äºº 140Ã—80</div></div>
          <div class="furniture-item" draggable="true" data-type="dining4" data-w="1.6" data-h="0.8" data-label="4ã€œ6äººæ›ã‘ 160Ã—80" data-color="#c8a878"><span class="fi-icon">ğŸªµ</span><div class="fi-name">ãƒ†ãƒ¼ãƒ–ãƒ«<br>4-6äºº 160Ã—80</div></div>
          <div class="furniture-item" draggable="true" data-type="dining4" data-w="1.2" data-h="0.75" data-label="4äººæ›ã‘ 120Ã—75" data-color="#dcc4a8"><span class="fi-icon">ğŸ´</span><div class="fi-name">ãƒ†ãƒ¼ãƒ–ãƒ«<br>4äºº 120Ã—75</div></div>
          <div class="furniture-item" draggable="true" data-type="dining4" data-w="1.1" data-h="1.1" data-label="ä¸¸ãƒ†ãƒ¼ãƒ–ãƒ« Ï†110" data-color="#d4b896" data-style="ä¸¸ãƒ†ãƒ¼ãƒ–ãƒ«"><span class="fi-icon">â­•</span><div class="fi-name">ä¸¸ãƒ†ãƒ¼ãƒ–ãƒ«<br>Ï†110 4äºº</div></div>
          <div class="furniture-item" draggable="true" data-type="dining4" data-w="1.3" data-h="1.3" data-label="ä¸¸ãƒ†ãƒ¼ãƒ–ãƒ« Ï†130" data-color="#c8a878" data-style="ä¸¸ãƒ†ãƒ¼ãƒ–ãƒ«"><span class="fi-icon">â­•</span><div class="fi-name">ä¸¸ãƒ†ãƒ¼ãƒ–ãƒ«<br>Ï†130 4-6äºº</div></div>
          <div class="furniture-item" draggable="true" data-type="folding_s" data-w="0.60" data-h="0.45" data-label="æŠ˜ã‚ŠãŸãŸã¿å° 60Ã—45" data-color="#d4c4a0" data-style="åç´"><span class="fi-icon">ğŸ“‹</span><div class="fi-name">æŠ˜ã‚ŠãŸãŸã¿<br>å° 60â†’120</div></div>
          <div class="furniture-item" draggable="true" data-type="folding_m" data-w="0.80" data-h="0.80" data-label="æŠ˜ã‚ŠãŸãŸã¿ä¸­ 80Ã—80" data-color="#c8b896" data-style="åç´"><span class="fi-icon">ğŸ“‹</span><div class="fi-name">æŠ˜ã‚ŠãŸãŸã¿<br>ä¸­ 80â†’160</div></div>
          <div class="furniture-item" draggable="true" data-type="folding_l" data-w="0.90" data-h="0.90" data-label="æŠ˜ã‚ŠãŸãŸã¿å¤§ 90Ã—90" data-color="#bca880" data-style="åç´"><span class="fi-icon">ğŸ“‹</span><div class="fi-name">æŠ˜ã‚ŠãŸãŸã¿<br>å¤§ 90â†’180</div></div>
          <div class="furniture-item" draggable="true" data-type="chair" data-w="0.45" data-h="0.45" data-label="ãƒ€ã‚¤ãƒ‹ãƒ³ã‚°ãƒã‚§ã‚¢" data-color="#c8b89a"><span class="fi-icon">ğŸª‘</span><div class="fi-name">æ¤…å­<br>ãƒ€ã‚¤ãƒ‹ãƒ³ã‚°</div></div>
          <div class="furniture-item" draggable="true" data-type="chair_arm" data-w="0.55" data-h="0.55" data-label="ã‚¢ãƒ¼ãƒ ãƒã‚§ã‚¢" data-color="#b8a888"><span class="fi-icon">ğŸª‘</span><div class="fi-name">æ¤…å­<br>ã‚¢ãƒ¼ãƒ ä»˜ã</div></div>
          <div class="furniture-item" draggable="true" data-type="chair_stool" data-w="0.40" data-h="0.40" data-label="ã‚¹ãƒ„ãƒ¼ãƒ«" data-color="#d4c4a0"><span class="fi-icon">ğŸŸ¤</span><div class="fi-name">ã‚¹ãƒ„ãƒ¼ãƒ«</div></div>
        </div>
      </div>
      <div class="palette-section">
        <div class="palette-label">ã‚­ãƒƒãƒãƒ³</div>
        <div class="furniture-grid">
          <div class="furniture-item" draggable="true" data-type="kitchen_l" data-w="2.7" data-h="0.65" data-label="ã‚­ãƒƒãƒãƒ³(Lå‹)" data-color="#c0c8d4"><span class="fi-icon">ğŸ³</span><div class="fi-name">ã‚­ãƒƒãƒãƒ³<br>Lå‹</div></div>
          <div class="furniture-item" draggable="true" data-type="kitchen_i" data-w="2.4" data-h="0.65" data-label="ã‚­ãƒƒãƒãƒ³(Iå‹)" data-color="#c8d0dc"><span class="fi-icon">ğŸ¥˜</span><div class="fi-name">ã‚­ãƒƒãƒãƒ³<br>Iå‹</div></div>
          <div class="furniture-item" draggable="true" data-type="island" data-w="1.2" data-h="0.7" data-label="ã‚¢ã‚¤ãƒ©ãƒ³ãƒ‰" data-color="#b8c0cc"><span class="fi-icon">ğŸï¸</span><div class="fi-name">ã‚¢ã‚¤ãƒ©ãƒ³ãƒ‰</div></div>
          <div class="furniture-item" draggable="true" data-type="fridge" data-w="0.65" data-h="0.65" data-label="å†·è”µåº«" data-color="#d8dce0"><span class="fi-icon">ğŸ§Š</span><div class="fi-name">å†·è”µåº«</div></div>
        </div>
      </div>
      <div class="palette-section">
        <div class="palette-label">å¯å®¤</div>
        <div class="furniture-grid">
          <div class="furniture-item" draggable="true" data-type="bed_double" data-w="1.6" data-h="2.0" data-label="ãƒ€ãƒ–ãƒ«ãƒ™ãƒƒãƒ‰" data-color="#d4c0d4"><span class="fi-icon">ğŸ›ï¸</span><div class="fi-name">ãƒ™ãƒƒãƒ‰<br>ãƒ€ãƒ–ãƒ«</div></div>
          <div class="furniture-item" draggable="true" data-type="bed_single" data-w="1.0" data-h="2.0" data-label="ã‚·ãƒ³ã‚°ãƒ«ãƒ™ãƒƒãƒ‰" data-color="#dccce0"><span class="fi-icon">ğŸ›Œ</span><div class="fi-name">ãƒ™ãƒƒãƒ‰<br>ã‚·ãƒ³ã‚°ãƒ«</div></div>
          <div class="furniture-item" draggable="true" data-type="desk" data-w="1.2" data-h="0.6" data-label="ãƒ‡ã‚¹ã‚¯" data-color="#c8b890"><span class="fi-icon">ğŸ’»</span><div class="fi-name">ãƒ‡ã‚¹ã‚¯</div></div>
          <div class="furniture-item" draggable="true" data-type="wardrobe" data-w="1.8" data-h="0.6" data-label="ã‚¯ãƒ­ãƒ¼ã‚¼ãƒƒãƒˆ" data-color="#c0a880"><span class="fi-icon">ğŸ‘”</span><div class="fi-name">ã‚¯ãƒ­ãƒ¼ã‚¼ãƒƒãƒˆ</div></div>
        </div>
      </div>
      <div class="palette-section">
        <div class="palette-label">ãã®ä»–</div>
        <div class="furniture-grid">
          <div class="furniture-item" draggable="true" data-type="washing" data-w="0.6" data-h="0.6" data-label="æ´—æ¿¯æ©Ÿ" data-color="#d0e0f0"><span class="fi-icon">ğŸ«§</span><div class="fi-name">æ´—æ¿¯æ©Ÿ</div></div>
          <div class="furniture-item" draggable="true" data-type="bath" data-w="0.75" data-h="1.2" data-label="ãƒã‚¹ã‚¿ãƒ–" data-color="#b8d8ec"><span class="fi-icon">ğŸ›</span><div class="fi-name">ãƒã‚¹ã‚¿ãƒ–</div></div>
          <div class="furniture-item" draggable="true" data-type="toilet" data-w="0.5" data-h="0.7" data-label="ãƒˆã‚¤ãƒ¬" data-color="#e0e8f0"><span class="fi-icon">ğŸš½</span><div class="fi-name">ãƒˆã‚¤ãƒ¬</div></div>
          <div class="furniture-item" draggable="true" data-type="plant" data-w="0.5" data-h="0.5" data-label="è¦³è‘‰æ¤ç‰©" data-color="#90c890"><span class="fi-icon">ğŸª´</span><div class="fi-name">æ¤ç‰©</div></div>
        </div>
      </div>

      <!-- COUNTER / STORAGE section -->
      <div class="palette-section">
        <div class="palette-label">ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ãƒ»åç´</div>
        <div class="furniture-grid">
          <div class="furniture-item" draggable="true" data-type="counter_straight" data-w="1.8" data-h="0.45" data-label="ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ç›´ç·š" data-color="#c8c0b0"><span class="fi-icon">ğŸŸ«</span><div class="fi-name">ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼<br>ç›´ç·š</div></div>
          <div class="furniture-item" draggable="true" data-type="counter_l" data-w="1.8" data-h="0.9" data-label="ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼Lå­—" data-color="#bfb8a8" data-style="Lå­—NE"><span class="fi-icon">ğŸ“</span><div class="fi-name">ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼<br>Lå­—</div></div>
          <div class="furniture-item" draggable="true" data-type="shelf" data-w="0.9" data-h="0.3" data-label="æ£šï¼ˆå£ä»˜ã‘ï¼‰" data-color="#d4c8b0"><span class="fi-icon">ğŸ“š</span><div class="fi-name">æ£š<br>å£ä»˜ã‘</div></div>
          <div class="furniture-item" draggable="true" data-type="shelf_tall" data-w="0.9" data-h="0.45" data-label="èƒŒã®é«˜ã„æ£š" data-color="#c8bca8"><span class="fi-icon">ğŸ—„ï¸</span><div class="fi-name">èƒŒã®é«˜ã„æ£š</div></div>
          <div class="furniture-item" draggable="true" data-type="cabinet" data-w="1.2" data-h="0.45" data-label="ã‚­ãƒ£ãƒ“ãƒãƒƒãƒˆ" data-color="#c0b498"><span class="fi-icon">ğŸ—ƒï¸</span><div class="fi-name">ã‚­ãƒ£ãƒ“ãƒãƒƒãƒˆ</div></div>
          <div class="furniture-item" draggable="true" data-type="shoe_rack" data-w="0.9" data-h="0.35" data-label="ä¸‹é§„ç®±" data-color="#c8bfb0"><span class="fi-icon">ğŸ‘Ÿ</span><div class="fi-name">ä¸‹é§„ç®±</div></div>
          <div class="furniture-item" draggable="true" data-type="tv_board" data-w="1.8" data-h="0.4" data-label="TVãƒœãƒ¼ãƒ‰" data-color="#a09080"><span class="fi-icon">ğŸ“º</span><div class="fi-name">TVãƒœãƒ¼ãƒ‰<br>W180</div></div>
          <div class="furniture-item" draggable="true" data-type="sideboard" data-w="1.2" data-h="0.45" data-label="ã‚µã‚¤ãƒ‰ãƒœãƒ¼ãƒ‰" data-color="#b8a890"><span class="fi-icon">ğŸªµ</span><div class="fi-name">ã‚µã‚¤ãƒ‰ãƒœãƒ¼ãƒ‰</div></div>
        </div>
      </div>

    </div>

    <!-- EDIT PANEL -->
    <div id="editPanel" class="left-scroll" style="display:none;">
      <div class="edit-panel-inner">

        <!-- Floor size controls -->
        <div class="ep-title">ãƒ•ãƒ­ã‚¢ã‚µã‚¤ã‚º</div>
        <div class="input-row">
          <label>å¹…</label>
          <input type="range" id="flW" min="2" max="20" step="0.05"
            oninput="onFloorSize('W', this.value)">
          <span class="input-val" id="fvW">7.8m</span>
        </div>
        <div class="input-row">
          <label>å¥¥è¡Œ</label>
          <input type="range" id="flH" min="2" max="15" step="0.05"
            oninput="onFloorSize('H', this.value)">
          <span class="input-val" id="fvH">3.0m</span>
        </div>
        <div style="display:flex;gap:4px;margin-bottom:10px;">
          <div style="flex:1;background:rgba(92,122,92,.1);border-radius:5px;padding:5px 8px;
            font-family:'DM Mono',monospace;font-size:10px;color:var(--accent);text-align:center;">
            <span id="floorSizeDisplay">7.83 Ã— 3.00 m</span>
          </div>
        </div>

        <div class="ep-title">æ§‹é€ è¦ç´ ã‚’è¿½åŠ </div>
        <div class="struct-hint">ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ãƒ•ãƒ­ã‚¢ã«é…ç½®<br>é…ç½®å¾Œã‚‚ãƒ‰ãƒ©ãƒƒã‚°ã§ç§»å‹•ãƒ»ãƒªã‚µã‚¤ã‚ºå¯</div>
        <div class="struct-grid">
          <div class="struct-item" draggable="true"
               data-stype="column" data-sw="0.12" data-sh="0.12" data-label="æŸ±">
            <span class="struct-icon">â¬›</span>
            <div class="struct-name">æŸ±</div>
          </div>
          <div class="struct-item" draggable="true"
               data-stype="wall_h" data-sw="1.0" data-sh="0.12" data-label="å£ï¼ˆæ¨ªï¼‰">
            <span class="struct-icon">â–¬</span>
            <div class="struct-name">å£ï¼ˆæ¨ªï¼‰</div>
          </div>
          <div class="struct-item" draggable="true"
               data-stype="wall_v" data-sw="0.12" data-sh="1.0" data-label="å£ï¼ˆç¸¦ï¼‰">
            <span class="struct-icon">â–®</span>
            <div class="struct-name">å£ï¼ˆç¸¦ï¼‰</div>
          </div>
          <div class="struct-item" draggable="true"
               data-stype="wall_corner" data-sw="0.12" data-sh="0.12" data-label="ã‚³ãƒ¼ãƒŠãƒ¼æŸ±">
            <span class="struct-icon">âŠ</span>
            <div class="struct-name">ã‚³ãƒ¼ãƒŠãƒ¼æŸ±</div>
          </div>
        </div>
        <div style="display:flex;gap:4px;margin-top:8px;margin-bottom:4px;">
          <button class="action-btn" style="flex:1;font-size:10px;justify-content:center;" onclick="autoPlaceCornerColumns()">â¬› å››éš…ã«è‡ªå‹•é…ç½®</button>
        </div>
        <div style="display:flex;gap:4px;margin-top:4px;margin-bottom:4px;">
          <button class="action-btn" style="flex:1;font-size:10px;justify-content:center;" onclick="autoPlacePerimeterWalls()">â–¬ 4è¾ºã«å£ã‚’é…ç½®</button>
        </div>
        <div style="display:flex;align-items:center;gap:6px;margin-bottom:6px;padding:6px 0 2px;">
          <span style="font-size:10px;color:var(--muted);white-space:nowrap;">å£åš</span>
          <input type="range" id="wallThkSlider" min="0.06" max="0.30" step="0.01"
            value="0.12" oninput="onWallThkChange(this.value)"
            style="flex:1;accent-color:var(--accent);">
          <span id="wallThkVal" style="font-size:10px;font-family:'DM Mono',monospace;
            color:var(--accent);width:32px;text-align:right;">12cm</span>
        </div>
        <div id="structSelControls" style="display:none;margin-top:8px;">
          <div class="ep-title">é¸æŠä¸­ã®æ§‹é€ è¦ç´ </div>
          <div id="structSelName" style="font-size:11px;font-weight:700;margin-bottom:6px;"></div>
          <div class="input-row">
            <label>X</label>
            <input type="range" id="ssX" min="0" max="8" step="0.01" oninput="onStructSlider('x',this.value)">
            <span class="input-val" id="svX">0</span>
          </div>
          <div class="input-row">
            <label>Y</label>
            <input type="range" id="ssY" min="0" max="4" step="0.01" oninput="onStructSlider('y',this.value)">
            <span class="input-val" id="svY">0</span>
          </div>
          <div class="input-row">
            <label>å¹…</label>
            <input type="range" id="ssW" min="0.01" max="3" step="0.01" oninput="onStructSlider('w',this.value)">
            <span class="input-val" id="svW">0</span>
          </div>
          <div class="input-row">
            <label>é«˜ã•</label>
            <input type="range" id="ssH" min="0.01" max="3" step="0.01" oninput="onStructSlider('h',this.value)">
            <span class="input-val" id="svH">0</span>
          </div>
          <button class="action-btn danger" onclick="deleteStructEl()" style="margin-top:6px;">âœ• å‰Šé™¤</button>
        </div>

        <div class="ep-title" style="margin-top:14px;">ä½¿ã„æ–¹</div>
        <div class="hint-box">
          ğŸ–± éƒ¨å±‹ã‚’ãƒ‰ãƒ©ãƒƒã‚° â†’ ç§»å‹•<br>
          â†” å³ãƒ»ä¸‹ç«¯ã‚’ãƒ‰ãƒ©ãƒƒã‚° â†’ ãƒªã‚µã‚¤ã‚º<br>
          âŒ¨ çŸ¢å°ã‚­ãƒ¼ â†’ 0.1må˜ä½ç§»å‹•
        </div>
        <div class="ep-title" style="margin-top:14px;">ã‚¾ãƒ¼ãƒ³ã‚’è¿½åŠ </div>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-bottom:10px;">
          <button class="action-btn" style="font-size:10px;justify-content:center;padding:5px 4px;" onclick="addZone('kitchen_walk')">ğŸš¶ ã‚­ãƒƒãƒãƒ³æ­©è¡Œ</button>
          <button class="action-btn" style="font-size:10px;justify-content:center;padding:5px 4px;" onclick="addZone('dining_zone')">ğŸ½ï¸ ãƒ€ã‚¤ãƒ‹ãƒ³ã‚°</button>
          <button class="action-btn" style="font-size:10px;justify-content:center;padding:5px 4px;" onclick="addZone('storage_zone')">ğŸ“¦ åç´ã‚¾ãƒ¼ãƒ³</button>
          <button class="action-btn" style="font-size:10px;justify-content:center;padding:5px 4px;" onclick="addZone('passage_zone')">â†”ï¸ é€šè·¯ã‚¾ãƒ¼ãƒ³</button>
          <button class="action-btn" style="font-size:10px;justify-content:center;padding:5px 4px;" onclick="addZone('work_zone')">ğŸ’» ãƒ¯ãƒ¼ã‚¯ã‚¾ãƒ¼ãƒ³</button>
          <button class="action-btn" style="font-size:10px;justify-content:center;padding:5px 4px;" onclick="addZone('free_zone')">ï¼‹ ãƒ•ãƒªãƒ¼</button>
        </div>

        <div class="ep-title" style="margin-top:14px;">éƒ¨å±‹ä¸€è¦§</div>
        <div class="ep-room-list" id="epRoomList"></div>
        <div id="epRoomControls" style="display:none;">
          <div class="ep-title">éƒ¨å±‹å</div>
          <div class="coord-input-wrap" style="margin-bottom:8px;">
            <input type="text" id="roomNameInput"
              style="width:100%;border:none;outline:none;padding:4px 8px;font-size:12px;
                     font-family:'Noto Sans JP',sans-serif;background:transparent;color:var(--text);"
              oninput="onRoomNameInput(this.value)" placeholder="éƒ¨å±‹åã‚’å…¥åŠ›">
          </div>
          <div class="ep-title">ä½ç½®</div>
          <div class="coord-row" style="margin-bottom:6px;">
            <label>X</label>
            <div class="coord-input-wrap">
              <button class="coord-step" onclick="nudgeRoom('x',-0.01)">âˆ’</button>
              <input type="number" id="slX" step="0.01" min="0"
                style="width:100%;border:none;outline:none;padding:3px 4px;font-size:12px;
                       font-family:'DM Mono',monospace;text-align:center;background:transparent;
                       -moz-appearance:textfield;"
                oninput="onSlider('x',this.value)"
                onchange="onSlider('x',this.value)"
                onkeydown="if(event.key==='Enter')onSlider('x',this.value)"
                onfocus="this.select()">
              <button class="coord-step" onclick="nudgeRoom('x', 0.01)">ï¼‹</button>
            </div>
            <span class="coord-unit">m</span>
          </div>
          <div class="coord-row" style="margin-bottom:6px;">
            <label>Y</label>
            <div class="coord-input-wrap">
              <button class="coord-step" onclick="nudgeRoom('y',-0.01)">âˆ’</button>
              <input type="number" id="slY" step="0.01" min="0"
                style="width:100%;border:none;outline:none;padding:3px 4px;font-size:12px;
                       font-family:'DM Mono',monospace;text-align:center;background:transparent;
                       -moz-appearance:textfield;"
                oninput="onSlider('y',this.value)"
                onchange="onSlider('y',this.value)"
                onkeydown="if(event.key==='Enter')onSlider('y',this.value)"
                onfocus="this.select()">
              <button class="coord-step" onclick="nudgeRoom('y', 0.01)">ï¼‹</button>
            </div>
            <span class="coord-unit">m</span>
          </div>
          <div class="ep-title" style="margin-top:8px;">ã‚µã‚¤ã‚º</div>
          <div class="coord-row" style="margin-bottom:6px;">
            <label>å¹…</label>
            <div class="coord-input-wrap">
              <button class="coord-step" onclick="nudgeRoom('w',-0.01)">âˆ’</button>
              <input type="number" id="slW" step="0.01" min="0.1"
                style="width:100%;border:none;outline:none;padding:3px 4px;font-size:12px;
                       font-family:'DM Mono',monospace;text-align:center;background:transparent;
                       -moz-appearance:textfield;"
                oninput="onSlider('w',this.value)"
                onchange="onSlider('w',this.value)"
                onkeydown="if(event.key==='Enter')onSlider('w',this.value)"
                onfocus="this.select()">
              <button class="coord-step" onclick="nudgeRoom('w', 0.01)">ï¼‹</button>
            </div>
            <span class="coord-unit">m</span>
          </div>
          <div class="coord-row" style="margin-bottom:6px;">
            <label>å¥¥è¡Œ</label>
            <div class="coord-input-wrap">
              <button class="coord-step" onclick="nudgeRoom('h',-0.01)">âˆ’</button>
              <input type="number" id="slH" step="0.01" min="0.1"
                style="width:100%;border:none;outline:none;padding:3px 4px;font-size:12px;
                       font-family:'DM Mono',monospace;text-align:center;background:transparent;
                       -moz-appearance:textfield;"
                oninput="onSlider('h',this.value)"
                onchange="onSlider('h',this.value)"
                onkeydown="if(event.key==='Enter')onSlider('h',this.value)"
                onfocus="this.select()">
              <button class="coord-step" onclick="nudgeRoom('h', 0.01)">ï¼‹</button>
            </div>
            <span class="coord-unit">m</span>
          </div>
          <div style="font-size:9px;color:var(--muted);margin-top:2px;line-height:1.6;">
            1cmå˜ä½ã§å…¥åŠ›å¯ ã€€<kbd>Â±</kbd>ãƒœã‚¿ãƒ³ã§1cmåˆ»ã¿
          </div>
          <div class="ep-title" style="margin-top:10px;">å›è»¢</div>
          <div class="coord-row" style="margin-bottom:4px;">
            <label>è§’åº¦</label>
            <div class="coord-input-wrap">
              <button class="coord-step" onclick="rotateRoom(-90)">â†º</button>
              <input type="number" id="slR_room" step="1" min="0" max="359"
                style="width:100%;border:none;outline:none;padding:3px 4px;font-size:12px;
                       font-family:'DM Mono',monospace;text-align:center;background:transparent;
                       -moz-appearance:textfield;"
                oninput="onRoomRotInput(this.value)"
                onchange="onRoomRotInput(this.value)"
                onfocus="this.select()">
              <button class="coord-step" onclick="rotateRoom(90)">â†»</button>
            </div>
            <span class="coord-unit">Â°</span>
          </div>
          <div style="display:flex;gap:3px;margin-bottom:8px;">
            <button class="action-btn" style="flex:1;font-size:10px;justify-content:center;padding:4px;" onclick="setRoomRotation(0)">0Â°</button>
            <button class="action-btn" style="flex:1;font-size:10px;justify-content:center;padding:4px;" onclick="setRoomRotation(90)">90Â°</button>
            <button class="action-btn" style="flex:1;font-size:10px;justify-content:center;padding:4px;" onclick="setRoomRotation(180)">180Â°</button>
            <button class="action-btn" style="flex:1;font-size:10px;justify-content:center;padding:4px;" onclick="setRoomRotation(270)">270Â°</button>
          </div>
          <!-- Wall AI feature removed for public build -->
        </div>
      </div>
    </div>
  </div>

  <!-- Canvas -->
  <div class="canvas-wrap" id="canvasWrap">
    <canvas id="c"></canvas>
    <div id="threeContainer" style="display:none;width:100%;height:100%;position:absolute;top:0;left:0;"></div>
    <!-- Dimension edit popup -->
    <div id="dimEditPopup" style="display:none;position:absolute;z-index:200;">
      <input id="dimEditInput" type="number" step="0.01" min="0.1"
        style="width:72px;padding:4px 6px;font-size:12px;font-family:'DM Mono',monospace;
               border:2px solid #c07a30;border-radius:5px;outline:none;text-align:center;
               background:#fffdf8;box-shadow:0 3px 10px rgba(0,0,0,.18);"
        onkeydown="onDimEditKey(event)" onblur="commitDimEdit()">
      <div style="font-size:9px;color:#888;text-align:center;margin-top:2px;">Enterã§ç¢ºå®š Â· Escã§ã‚­ãƒ£ãƒ³ã‚»ãƒ«</div>
    </div>
    <div class="canvas-hint" id="canvasHint">ãƒ‘ãƒ¬ãƒƒãƒˆã‹ã‚‰ãƒ‰ãƒ©ãƒƒã‚° â†’ <kbd>R</kbd> å›è»¢ Â· <kbd>Del</kbd> å‰Šé™¤ Â· çŸ¢å°ã‚­ãƒ¼ ç§»å‹•</div>
    <div id="view3dControls" style="display:none;position:absolute;bottom:14px;left:50%;transform:translateX(-50%);gap:6px;align-items:center;">
      <div style="background:rgba(20,28,22,.85);backdrop-filter:blur(8px);border:1px solid rgba(255,255,255,.12);border-radius:20px;padding:7px 16px;font-family:'DM Mono',monospace;font-size:10px;color:rgba(220,240,220,.8);white-space:nowrap;display:flex;align-items:center;gap:14px;flex-wrap:wrap;justify-content:center;">
        <span style="display:flex;gap:8px;align-items:center;">
          <button onclick="set3DView('top')" style="background:rgba(92,122,92,.6);border:1px solid rgba(180,220,180,.3);color:#fff;padding:3px 8px;border-radius:10px;cursor:pointer;font-size:9px;">çœŸä¸Š</button>
          <button onclick="set3DView('iso')" style="background:rgba(92,122,92,.6);border:1px solid rgba(180,220,180,.3);color:#fff;padding:3px 8px;border-radius:10px;cursor:pointer;font-size:9px;">æ–œã‚</button>
          <button onclick="set3DView('side')" style="background:rgba(92,122,92,.6);border:1px solid rgba(180,220,180,.3);color:#fff;padding:3px 8px;border-radius:10px;cursor:pointer;font-size:9px;">æ¨ª</button>
          <button onclick="set3DView('inside')" style="background:rgba(92,122,92,.6);border:1px solid rgba(180,220,180,.3);color:#fff;padding:3px 8px;border-radius:10px;cursor:pointer;font-size:9px;">å®¤å†…</button>
        </span>
        <span style="font-size:9px;opacity:.7;">ğŸ–± ãƒ‰ãƒ©ãƒƒã‚°:å›è»¢ Â· ãƒ›ã‚¤ãƒ¼ãƒ«:ã‚ºãƒ¼ãƒ </span>
        <span style="display:flex;align-items:center;gap:6px;">
          å£ã®é€æ˜åº¦:
          <input type="range" id="wallOpacity" min="5" max="95" value="13" step="1"
            style="width:80px;accent-color:#5c7a5c;vertical-align:middle;"
            oninput="updateWallOpacity(this.value)">
          <span id="wallOpacityVal" style="color:rgba(180,220,180,.9);min-width:28px;">13%</span>
        </span>
      </div>
    </div>
  </div>

  <!-- RIGHT panel -->
  <div class="info">
    <div class="info-section">
      <div class="info-label">é¸æŠä¸­</div>
      <div id="selectedInfo" style="font-size:11px;color:var(--muted);">é¸æŠã—ã¦ãã ã•ã„</div>
      <div class="rotate-row" id="rotateRow" style="display:none;">
        <button class="rotate-btn" onclick="rotateFurniture(-90)">â†º</button>
        <button class="rotate-btn" onclick="rotateFurniture(90)">â†»</button>
      </div>
    </div>
    <!-- Furniture style panel (shown when furniture selected) -->
    <div class="style-panel" id="stylePanel" style="display:none;">
      <div class="info-label">ã‚«ãƒ©ãƒ¼</div>
      <div class="color-grid" id="colorGrid"></div>
      <div class="info-label" style="margin-top:8px;">ã‚¹ã‚¿ã‚¤ãƒ«</div>
      <div class="style-row" id="styleChips"></div>
      <!-- Folding table expand direction -->
      <div id="foldExpandRow" style="display:none;">
        <div class="info-label" style="margin-top:8px;">å±•é–‹æ–¹å‘</div>
        <div style="font-size:9px;color:var(--muted);margin-bottom:4px;line-height:1.5;">
          ãƒ†ãƒ¼ãƒ–ãƒ«è‡ªèº«ã®å‘ãã‚’åŸºæº–ã¨ã—ãŸæ–¹å‘
        </div>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-bottom:4px;">
          <div></div>
          <button class="win-type-btn" id="foldDir_up"    onclick="setExpandDir('up')">â†‘ å‰</button>
          <button class="win-type-btn" id="foldDir_left"  onclick="setExpandDir('left')">â† å·¦</button>
          <button class="win-type-btn" id="foldDir_right" onclick="setExpandDir('right')">â†’ å³</button>
          <div></div>
          <button class="win-type-btn" id="foldDir_down"  onclick="setExpandDir('down')">â†“ å¾Œ</button>
        </div>
        <button class="action-btn" style="width:100%;justify-content:center;margin-top:4px;font-size:11px;"
          id="foldToggleBtn" onclick="toggleSelectedFolding()">ğŸ“‹ å±•é–‹ã™ã‚‹</button>
      </div>
      <!-- L-sofa corner selector -->
      <div id="lSofaRow" style="display:none;">
        <div class="info-label" style="margin-top:8px;">Lå­—ã®å‘ã</div>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-bottom:4px;">
          <button class="win-type-btn" id="lc_NW" onclick="setLSofaCorner('NW')">â†– NW</button>
          <button class="win-type-btn" id="lc_NE" onclick="setLSofaCorner('NE')">â†— NE</button>
          <button class="win-type-btn" id="lc_SW" onclick="setLSofaCorner('SW')">â†™ SW</button>
          <button class="win-type-btn" id="lc_SE" onclick="setLSofaCorner('SE')">â†˜ SE</button>
        </div>
      </div>
      <div class="info-label" style="margin-top:8px;">ã‚µã‚¤ã‚º</div>
      <!-- é€šå¸¸ã‚µã‚¤ã‚ºï¼ˆä¸¸ãƒ†ãƒ¼ãƒ–ãƒ«ä»¥å¤–ï¼‰ -->
      <div id="sizeNormal">
        <div class="size-row">
          <label>å¹…</label>
          <input type="range" id="fslW" min="0.1" max="8.0" step="0.05" oninput="onFurnSize('w',this.value)">
          <span class="sv" id="fvalW">-</span>
        </div>
        <div class="size-row">
          <label>å¥¥è¡Œ</label>
          <input type="range" id="fslH" min="0.1" max="4.0" step="0.05" oninput="onFurnSize('h',this.value)">
          <span class="sv" id="fvalH">-</span>
        </div>
      </div>
      <!-- ä¸¸ãƒ†ãƒ¼ãƒ–ãƒ«å°‚ç”¨ï¼šç›´å¾„ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ -->
      <div id="sizeDiameter" style="display:none;">
        <div class="size-row">
          <label>ç›´å¾„</label>
          <input type="range" id="fslD" min="0.6" max="2.0" step="0.05" oninput="onFurnDiameter(this.value)">
          <span class="sv" id="fvalD">-</span>
        </div>
        <div style="font-size:9px;color:var(--muted);margin-top:2px;padding:0 2px;">
          Ï†60ã€œ200cm
        </div>
      </div>
      <!-- å›è»¢ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ -->
      <div class="info-label" style="margin-top:8px;">å›è»¢</div>
      <div class="size-row">
        <label>è§’åº¦</label>
        <input type="range" id="fslR" min="0" max="355" step="5" oninput="onFurnRotation(this.value)">
        <span class="sv" id="fvalR">0Â°</span>
      </div>
      <div class="rotate-quick">
        <button onclick="setFurnRotation(0)">0Â°</button>
        <button onclick="setFurnRotation(45)">45Â°</button>
        <button onclick="setFurnRotation(90)">90Â°</button>
        <button onclick="setFurnRotation(180)">180Â°</button>
      </div>
    </div>

    <!-- åº§æ¨™ãƒ»ã‚µã‚¤ã‚ºç›´æ¥å…¥åŠ›ãƒ‘ãƒãƒ« -->
    <div class="info-section" id="coordPanel" style="display:none;">
      <div class="info-label">ğŸ“ åº§æ¨™ãƒ»ã‚µã‚¤ã‚º</div>
      <div class="coord-grid">
        <div class="coord-row">
          <label>X</label>
          <div class="coord-input-wrap">
            <button class="coord-step" onclick="nudgeFurn('x',-0.01)">âˆ’</button>
            <input type="number" id="cinX" step="0.01" min="0" oninput="onCoordInput('x',this.value)" onfocus="this.select()">
            <button class="coord-step" onclick="nudgeFurn('x', 0.01)">ï¼‹</button>
          </div>
          <span class="coord-unit">m</span>
        </div>
        <div class="coord-row">
          <label>Y</label>
          <div class="coord-input-wrap">
            <button class="coord-step" onclick="nudgeFurn('y',-0.01)">âˆ’</button>
            <input type="number" id="cinY" step="0.01" min="0" oninput="onCoordInput('y',this.value)" onfocus="this.select()">
            <button class="coord-step" onclick="nudgeFurn('y', 0.01)">ï¼‹</button>
          </div>
          <span class="coord-unit">m</span>
        </div>
        <div class="coord-divider"></div>
        <div class="coord-row" id="coordW_row">
          <label>W</label>
          <div class="coord-input-wrap">
            <button class="coord-step" onclick="nudgeFurn('w',-0.01)">âˆ’</button>
            <input type="number" id="cinW" step="0.01" min="0.1" oninput="onCoordInput('w',this.value)" onfocus="this.select()">
            <button class="coord-step" onclick="nudgeFurn('w', 0.01)">ï¼‹</button>
          </div>
          <span class="coord-unit">m</span>
        </div>
        <div class="coord-row" id="coordH_row">
          <label>H</label>
          <div class="coord-input-wrap">
            <button class="coord-step" onclick="nudgeFurn('h',-0.01)">âˆ’</button>
            <input type="number" id="cinH" step="0.01" min="0.1" oninput="onCoordInput('h',this.value)" onfocus="this.select()">
            <button class="coord-step" onclick="nudgeFurn('h', 0.01)">ï¼‹</button>
          </div>
          <span class="coord-unit">m</span>
        </div>
        <div class="coord-row" id="coordD_row" style="display:none;">
          <label>Ï†</label>
          <div class="coord-input-wrap">
            <button class="coord-step" onclick="nudgeFurnDiam(-0.01)">âˆ’</button>
            <input type="number" id="cinD" step="0.01" min="0.1" oninput="onCoordInputDiam(this.value)" onfocus="this.select()">
            <button class="coord-step" onclick="nudgeFurnDiam( 0.01)">ï¼‹</button>
          </div>
          <span class="coord-unit">m</span>
        </div>
        <div class="coord-divider"></div>
        <div class="coord-row">
          <label>R</label>
          <div class="coord-input-wrap">
            <button class="coord-step" onclick="nudgeFurn('rotation',-1)">âˆ’</button>
            <input type="number" id="cinR" step="1" min="0" max="359" oninput="onCoordInput('rotation',this.value)" onfocus="this.select()">
            <button class="coord-step" onclick="nudgeFurn('rotation', 1)">ï¼‹</button>
          </div>
          <span class="coord-unit">Â°</span>
        </div>
      </div>
      <div style="font-size:9px;color:var(--muted);margin-top:5px;line-height:1.6;">
        X/Y = å·¦ä¸Šè§’ã®åº§æ¨™<br>
        <kbd>â†‘â†“â†â†’</kbd> 1cmå˜ä½ã§ç§»å‹•
      </div>
    </div>

    <div class="info-section" id="furnitureActions">
      <div class="info-label">æ“ä½œ</div>
      <!-- AI image feature removed for public build -->
      <button class="action-btn danger" onclick="deleteSelected()">âœ• å‰Šé™¤ <span style="margin-left:auto"><kbd>Del</kbd></span></button>
      <button class="action-btn danger" onclick="clearAll()" style="margin-top:5px;">ğŸ—‘ å…¨éƒ¨æ¶ˆã™</button>
    </div>
    <!-- Window selection panel -->
    <div class="info-section win-panel" id="winPanel" style="display:none;">
      <div class="info-label">ğŸªŸ çª“</div>
      <div id="winSelName" style="font-size:11px;color:var(--muted);margin-bottom:6px;">-</div>
      <div class="size-row">
        <label>å¹…</label>
        <input type="range" id="wslW" min="0.2" max="3.0" step="0.05" oninput="onWinWidth(this.value)">
        <span class="sv" id="wvalW">-</span>
      </div>
      <div class="info-label" style="margin-top:6px;margin-bottom:4px;">ç¨®é¡</div>
      <div class="win-type-row">
        <button class="win-type-btn" onclick="setWinType('sliding')">å¼•ãé•ã„</button>
        <button class="win-type-btn" onclick="setWinType('fixed')">FIX</button>
        <button class="win-type-btn" onclick="setWinType('slit')">ã‚¹ãƒªãƒƒãƒˆ</button>
      </div>
      <div class="info-label" style="margin-top:6px;margin-bottom:4px;">å£é¢</div>
      <div class="win-type-row">
        <button class="win-type-btn" onclick="setWinWall('n')">åŒ—</button>
        <button class="win-type-btn" onclick="setWinWall('s')">å—</button>
        <button class="win-type-btn" onclick="setWinWall('w')">è¥¿</button>
        <button class="win-type-btn" onclick="setWinWall('e')">æ±</button>
        <button class="win-type-btn" onclick="setWinWall('auto')">è‡ªå‹•</button>
      </div>
      <!-- ã‚«ãƒ¼ãƒ†ãƒ³ãƒ¬ãƒ¼ãƒ« -->
      <div class="info-label" style="margin-top:8px;">ã‚«ãƒ¼ãƒ†ãƒ³ãƒ¬ãƒ¼ãƒ«</div>
      <div style="display:flex;align-items:center;gap:4px;margin-bottom:4px;">
        <div class="coord-input-wrap" style="flex:1;">
          <button class="coord-step" onclick="nudgeWinRail(-0.01)">âˆ’</button>
          <input type="number" id="winRailInput" step="0.01" min="0" placeholder="æœªè¨­å®š"
            style="width:100%;border:none;outline:none;padding:3px 4px;font-size:11px;
                   font-family:'DM Mono',monospace;text-align:center;background:transparent;
                   -moz-appearance:textfield;"
            oninput="onWinRailInput(this.value)" onfocus="this.select()">
          <button class="coord-step" onclick="nudgeWinRail(0.01)">ï¼‹</button>
        </div>
        <span style="font-size:9px;color:var(--muted);font-family:'DM Mono',monospace;">m</span>
      </div>
      <div style="font-size:9px;color:var(--muted);line-height:1.6;margin-bottom:6px;">
        çª“å¹…ã¨ç•°ãªã‚‹å ´åˆã«å…¥åŠ›<br>3Dè¡¨ç¤ºã«ã‚‚åæ˜ 
      </div>
      <button class="action-btn danger" style="width:100%;" onclick="deleteWin()">âœ• å‰Šé™¤</button>
    </div>
    <div class="info-section">
      <div class="info-label">éƒ¨å±‹ã®è‰²</div>
      <div id="roomLegend"></div>
    </div>
    <div class="info-section" id="diningTip" style="display:none;">
      <div class="info-label">ğŸ’¡ ãƒ€ã‚¤ãƒ‹ãƒ³ã‚°Tips</div>
      <div style="font-size:10px;color:var(--muted);line-height:1.8;">
        <b style="color:var(--accent);">2Ã—3mã‚¾ãƒ¼ãƒ³</b>ã«é…ç½®ä¸­<br>
        ãƒ»é€šè·¯ã¯æœ€ä½ <b>60cm</b> ç¢ºä¿<br>
        ãƒ»æ¤…å­å¼•ãè¾¼ã¿ã« <b>+80cm</b><br>
        ãƒ»å£ä»˜ã‘ãƒ™ãƒ³ãƒãªã‚‰çœã‚¹ãƒšãƒ¼ã‚¹<br>
        <span style="color:#c07a30;font-weight:bold;">æ¨å¥¨: 140Ã—80cm ãƒ†ãƒ¼ãƒ–ãƒ«</span>
      </div>
    </div>
    <div class="info-section">
      <div class="info-label">é…ç½®æ•°</div>
      <div style="font-family:'DM Mono',monospace;font-size:22px;color:var(--accent);" id="furnitureCount">0</div>
      <div style="font-size:10px;color:var(--muted);">ç‚¹ã®å®¶å…·</div>
    </div>
  </div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     MOBILE BOTTOM BAR + BOTTOM SHEET
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="mobileBottomBar" style="display:none;">
  <button class="mob-nav-btn active" id="mobBtnFurniture" onclick="mobileTab('furniture')">
    <div class="mob-icon-bg"><span class="mob-icon">ğŸ›‹</span></div>
    <span>å®¶å…·</span>
  </button>
  <button class="mob-nav-btn" id="mobBtnEdit" onclick="mobileTab('edit')">
    <div class="mob-icon-bg"><span class="mob-icon">âœï¸</span></div>
    <span>ç·¨é›†</span>
  </button>
  <button class="mob-nav-btn" id="mobBtnSave" onclick="mobileTab('save')">
    <div class="mob-icon-bg"><span class="mob-icon">â˜ï¸</span></div>
    <span>ä¿å­˜</span>
  </button>
  <button class="mob-nav-btn" id="mobBtn3d" onclick="setMode('3d');closeSheet()">
    <div class="mob-icon-bg"><span class="mob-icon">ğŸ </span></div>
    <span>3D</span>
  </button>
</div>

<div id="mobileSheet">
  <div id="sheetHandle"></div>
  <div id="sheetTabs">
    <button class="sheet-tab active" id="sheetTab0" onclick="switchSheetTab(0)">ğŸ›‹ å®¶å…·</button>
    <button class="sheet-tab" id="sheetTab1" onclick="switchSheetTab(1)">âœï¸ é–“å–ã‚Šç·¨é›†</button>
    <button class="sheet-tab" id="sheetTab2" onclick="switchSheetTab(2)">â˜ï¸ ä¿å­˜ãƒ»å…±æœ‰</button>
  </div>
  <div id="sheetContent">
    <!-- Tab 0: Furniture palette (cloned from left panel) -->
    <div class="sheet-panel active" id="sheetPanel0">
      <div id="sheetFurniture"></div>
    </div>
    <!-- Tab 1: Edit panel -->
    <div class="sheet-panel" id="sheetPanel1">
      <div id="sheetEdit"></div>
    </div>
    <!-- Tab 2: Save/Share -->
    <div class="sheet-panel" id="sheetPanel2">
      <div id="sheetSave">
        <button class="save-btn" onclick="saveToCloud()" style="width:100%;justify-content:center;padding:14px;font-size:14px;border-radius:10px;">
          <span>â˜ï¸</span><span> ä¿å­˜</span>
        </button>
        <button class="save-btn" onclick="loadFromCloud()" style="width:100%;justify-content:center;padding:14px;font-size:14px;border-radius:10px;background:rgba(60,80,120,.8);">
          <span>ğŸ“‚</span><span> èª­ã¿è¾¼ã¿</span>
        </button>
        <button class="save-btn" onclick="showShareModal()" style="width:100%;justify-content:center;padding:14px;font-size:14px;border-radius:10px;background:rgba(80,60,120,.8);">
          <span>ğŸ”—</span><span> å…±æœ‰URLã‚’ç”Ÿæˆ</span>
        </button>
        <div id="saveStatus2" style="font-size:12px;color:rgba(180,220,180,.8);text-align:center;min-height:20px;"></div>
      </div>
    </div>
  </div>
</div>


<script>
// â”€â”€ Early declarations to prevent TDZ errors during initial draw â”€â”€
let obStep = 0;
let obData = { buildingType:null, layout:null, rooms:[], household:null };
let obCurrentFloor = 1;
let obFloorDetails = {};

const BASE_SCALE = 97.0;
let SCALE = 97.0; // updated before each draw to reflect viewScale

// Offscreen canvas for static layer (grid + rooms + walls) - rebuilt only when needed
let _offscreen = null;
let _offscreenValid = false;
let _offscreenFloor = null;
let _offscreenScale = 0;
let _offscreenW = 0, _offscreenH = 0;

function invalidateOffscreen(){ _offscreenValid = false; }
const SNAP = 0.25;     // room snap: 0.25m grid
const SNAP_S = 0.01;   // structural snap: 1cm grid
function snap(v){ return Math.round(v/SNAP)*SNAP; }
function snapS(v){ return Math.round(v/SNAP_S)*SNAP_S; }

// â”€â”€â”€ FLOOR DATA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const floors = {
  '1f':{ label:'1F', W:7.8333, H:3.0, rooms:[
    { id:'entrance',  name:'ç„é–¢åç´',          x:0.0,   y:0.0,   w:3.525, h:1.4, color:'#e8dcc8', tc:'#6a5a40' },
    { id:'stairs1',   name:'éšæ®µ UP',            x:3.525, y:0.0,   w:1.5666, h:1.4, color:'#ddd4c0', tc:'#5a4a20', stair:true },
    { id:'service',   name:'ã‚µãƒ¼ãƒ“ã‚¹ãƒ«ãƒ¼ãƒ \n4.3J',x:5.0917, y:0.0,   w:2.7417, h:3.0, color:'#d8e4d0', tc:'#4a6a40' },
    { id:'bath',      name:'æµ´å®¤',               x:0.0,   y:1.4, w:1.9583, h:1.6, color:'#c8dce8', tc:'#3a5a70' },
    { id:'laundry',   name:'æ´—é¢ãƒ»æ´—æ¿¯',         x:1.9583, y:1.4, w:1.5666, h:0.8, color:'#d0e8dc', tc:'#3a6a50' },
    { id:'toilet1f',  name:'ãƒˆã‚¤ãƒ¬',             x:1.9583, y:2.2, w:1.5666, h:0.8, color:'#d8e8f0', tc:'#4a6a80' },
    { id:'storage1f', name:'å‚™è“„ãƒ»é£Ÿåº«',         x:3.525, y:1.4, w:1.5666, h:1.6, color:'#e4dfd4', tc:'#5a5040' },
  ]},
  '2f':{ label:'2F', W:7.22, H:3.0, rooms:[
    { id:'ldk',       name:'LDK 13.1J',  x:0.0,  y:0.0, w:5.3, h:3.0, color:'#e8f0e0', tc:'#3a5a30' },
    { id:'dining_zone', name:'ãƒ€ã‚¤ãƒ‹ãƒ³ã‚°\nã‚¾ãƒ¼ãƒ³ 2Ã—3m', x:0.0, y:0.0, w:3.0, h:2.0, color:'#f0e8d8', tc:'#8a6030' },
    { id:'stairs2up', name:'UP', x:5.3, y:0.0, w:0.96, h:1.5, color:'#ddd4c0', tc:'#5a4a20', stair:true },
    { id:'stairs2dn', name:'DN', x:6.26, y:0.0, w:0.96, h:1.5, color:'#d0c8b4', tc:'#5a4a20', stair:true },
    { id:'kitchen2f', name:'ã‚­ãƒƒãƒãƒ³',   x:5.3, y:1.5, w:1.92, h:1.5, color:'#ddeedd', tc:'#3a6a40' },
  ]},
  '3f':{ label:'3F', W:7.8333, H:3.0, rooms:[
    { id:'bed1',      name:'å¯å®¤1\n7.3J',        x:0.0,   y:0.0,   w:4.3083, h:3.0, color:'#e8e0f0', tc:'#4a3a70' },
    { id:'stairs3up', name:'UP',                 x:4.3083, y:0.0,   w:0.9792,h:1.0, color:'#ddd4c0', tc:'#5a4a20', stair:true },
    { id:'stairs3dn', name:'DN',                 x:5.2875,y:0.0,   w:0.9792,h:1.0, color:'#d0c8b4', tc:'#5a4a20', stair:true },
    { id:'bed2',      name:'å¯å®¤2\n4.3J',        x:5.0917, y:1.0, w:2.7417, h:2.0, color:'#f0e8f4', tc:'#5a3a78' },
    { id:'hall3f',    name:'ãƒ›ãƒ¼ãƒ«',             x:4.3083, y:1.0, w:0.7834, h:2.0, color:'#e4e0ec', tc:'#6a5a80' },
    { id:'toilet3f',  name:'ãƒˆã‚¤ãƒ¬',             x:5.0917, y:0.0,   w:0.7834, h:1.0, color:'#d8e8f0', tc:'#4a6a80' },
  ]},
  'rf':{ label:'RF', W:7.8333, H:3.0, rooms:[
    { id:'roof_stair',name:'éšæ®µ DN',             x:0.0,   y:0.0,   w:1.5666, h:0.8, color:'#ddd4c0', tc:'#5a4a20', stair:true },
    { id:'ph',        name:'PH',                 x:1.5666, y:0.0,   w:6.2667, h:0.8, color:'#dce8f0', tc:'#3a5a70' },
    { id:'roofbalc',  name:'Roof Balcony\nç´„10J',x:0.0,   y:0.8, w:7.8333,h:2.2, color:'#e0f0e4', tc:'#2a5a38' },
  ]},
};

const defFurn2f = [
  // ã‚­ãƒƒãƒãƒ³è¨­å‚™
  {id:1, type:'kitchen_l', label:'ã‚­ãƒƒãƒãƒ³(Lå‹)', color:'#c0c8d4', x:5.95, y:1.57, w:1.85, h:0.65, rotation:0},
  {id:2, type:'fridge',    label:'å†·è”µåº«',        color:'#d8dce0', x:7.18, y:1.55, w:0.60, h:0.65, rotation:0},
  // ãƒ€ã‚¤ãƒ‹ãƒ³ã‚° (2Ã—3mã‚¾ãƒ¼ãƒ³å†… â€” 140Ã—80cm ãƒ†ãƒ¼ãƒ–ãƒ«ã€å£å¯„ã›é…ç½®)
  {id:3, type:'dining4',   label:'4äººæ›ã‘ 140Ã—80', color:'#c8a870', x:0.30, y:0.60, w:1.40, h:0.80, rotation:0},
  // ã‚½ãƒ•ã‚¡ã‚¾ãƒ¼ãƒ³
  {id:4, type:'sofa3',     label:'ã‚½ãƒ•ã‚¡(3äºº)',    color:'#b8d4b8', x:2.20, y:2.10, w:2.10, h:0.75, rotation:0},
  {id:5, type:'table_low', label:'ã‚»ãƒ³ã‚¿ãƒ¼ãƒ†ãƒ¼ãƒ–ãƒ«',color:'#d4c4a0', x:2.30, y:1.35, w:1.10, h:0.50, rotation:0},
  {id:6, type:'tv',        label:'ãƒ†ãƒ¬ãƒ“å°',       color:'#8a8080', x:0.08, y:0.10, w:1.20, h:0.30, rotation:0},
];

// Structural elements per floor: {id, stype, x, y, w, h, label}
let structEls = {'1f':[], '2f':[], '3f':[], 'rf':[]};
let selStructId = null;
let structDrag = null;

// â”€â”€ Windows â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Each window: {id, x, y, w, wall:'n'|'s'|'e'|'w'|'auto', label, wtype:'window'|'sliding'|'fixed'|'slit'}
// wall: which wall it sits on (determines orientation)
// x,y: position along floor (center of window)
// w: width in meters (0.4ã€œ2.4m)
let windows = {'1f':[], '2f':[], '3f':[], 'rf':[]};
let nWinId = 100;
let selWinId = null;
let winDrag = null; // {type:'move'|'resize'|'palette', ...}
let nStructId = 5000;

let furniture = {'1f':[],'2f':defFurn2f.map(f=>({...f})),'3f':[],'rf':[]};
let nid = 200;
let curFloor = '2f';
let appMode  = 'furniture'; // 'furniture' | 'edit'

// selection / drag
let selFurnId  = null;
let selRoomId  = null;
let furnDrag   = null; // {type:'move'|'palette', ...}
let roomDrag   = null; // {type:'move'|'resize', handle, roomId, startX,startY, origX,origY,origW,origH}

const canvas = document.getElementById('c');
canvas.style.display = 'block';
const ctx    = canvas.getContext('2d');
canvas.style.touchAction = 'none'; // prevent scroll on canvas touch
const wrap   = document.getElementById('canvasWrap');

// â”€â”€â”€ LAYOUT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function resize(){
  canvas.width  = wrap.clientWidth;
  canvas.height = wrap.clientHeight;
  // Show zoom reset button only on mobile
  const btn = document.getElementById('resetViewBtn');
  if(btn) btn.style.display = window.innerWidth <= 680 ? 'inline-block' : 'none';
  draw();
}

function offset(){
  const fl = floors[curFloor];
  const PAD = 60;
  // SCALE is already updated to BASE_SCALE*viewScale before draw
  const baseOx = Math.max(PAD, (canvas.width  - fl.W*SCALE)/2);
  const baseOy = Math.max(PAD, (canvas.height - fl.H*SCALE)/2);
  return {
    ox: baseOx + viewPanX,
    oy: baseOy + viewPanY,
  };
}

// â”€â”€â”€ DRAW â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// â”€â”€â”€ DIMENSION SYSTEM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// hoveredDim: {type:'floor_w'|'floor_h'|'room_w'|'room_h', roomId, axis, value, px,py,len, editTarget}
let hoveredDim = null;
let dimEditTarget = null; // {type, roomId, axis}
const DIM_HIT = 18;       // px hit radius for dimension lines
const DIM_OFFSET = 28;    // px distance from edge to dimension line

// Build list of all dimension segments for current floor
function getDimSegments(ox, oy){
  const fl = floors[curFloor];
  const segs = [];

  // â”€â”€ Outer floor dimensions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Top edge â†’ floor W
  segs.push({
    id:'floor_w',
    axis:'w', target:'floor',
    value: fl.W,
    // line goes across top, offset upward
    x1: ox, y1: oy - DIM_OFFSET,
    x2: ox + fl.W*SCALE, y2: oy - DIM_OFFSET,
    lx: ox + fl.W*SCALE/2, ly: oy - DIM_OFFSET,
    ext1x: ox, ext1y: oy, ext2x: ox+fl.W*SCALE, ext2y: oy,
    horiz: true,
  });
  // Left edge â†’ floor H
  segs.push({
    id:'floor_h',
    axis:'h', target:'floor',
    value: fl.H,
    x1: ox - DIM_OFFSET, y1: oy,
    x2: ox - DIM_OFFSET, y2: oy + fl.H*SCALE,
    lx: ox - DIM_OFFSET, ly: oy + fl.H*SCALE/2,
    ext1x: ox, ext1y: oy, ext2x: ox, ext2y: oy+fl.H*SCALE,
    horiz: false,
  });

  // â”€â”€ Room dimensions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  fl.rooms.forEach(r => {
    if(r.id==='dining_zone') return; // decorative zone, skip
    const rx = ox + r.x*SCALE, ry = oy + r.y*SCALE;
    const rw = r.w*SCALE, rh = r.h*SCALE;
    // Bottom edge â†’ room width
    segs.push({
      id:'room_w_'+r.id, axis:'w', target:'room', roomId: r.id,
      value: r.w,
      x1: rx, y1: ry + rh + DIM_OFFSET,
      x2: rx + rw, y2: ry + rh + DIM_OFFSET,
      lx: rx + rw/2, ly: ry + rh + DIM_OFFSET,
      ext1x: rx, ext1y: ry+rh, ext2x: rx+rw, ext2y: ry+rh,
      horiz: true,
    });
    // Right edge â†’ room height
    segs.push({
      id:'room_h_'+r.id, axis:'h', target:'room', roomId: r.id,
      value: r.h,
      x1: rx + rw + DIM_OFFSET, y1: ry,
      x2: rx + rw + DIM_OFFSET, y2: ry + rh,
      lx: rx + rw + DIM_OFFSET, ly: ry + rh/2,
      ext1x: rx+rw, ext1y: ry, ext2x: rx+rw, ext2y: ry+rh,
      horiz: false,
    });
  });

  return segs;
}

// Draw a single dimension segment
function drawDimSeg(seg, hovered){
  const alpha = hovered ? 1.0 : 0.45;
  const color = hovered ? '#c07a30' : (seg.target==='floor' ? '#2a6a8a' : '#7a5a2a');
  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.strokeStyle = color;
  ctx.fillStyle = color;
  ctx.lineWidth = hovered ? 1.8 : 1.2;

  // Extension lines (from object edge to dim line)
  ctx.setLineDash([2,3]);
  ctx.beginPath();
  ctx.moveTo(seg.ext1x, seg.ext1y);
  ctx.lineTo(seg.x1, seg.y1);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(seg.ext2x, seg.ext2y);
  ctx.lineTo(seg.x2, seg.y2);
  ctx.stroke();
  ctx.setLineDash([]);

  // Main dimension line with arrows
  ctx.beginPath(); ctx.moveTo(seg.x1, seg.y1); ctx.lineTo(seg.x2, seg.y2); ctx.stroke();
  // Arrow heads
  const ang = seg.horiz ? 0 : Math.PI/2;
  const aSize = 5;
  [[seg.x1,seg.y1, 1],[seg.x2,seg.y2,-1]].forEach(([ax,ay,dir])=>{
    ctx.beginPath();
    if(seg.horiz){
      ctx.moveTo(ax, ay);
      ctx.lineTo(ax+dir*aSize, ay-aSize*.5);
      ctx.lineTo(ax+dir*aSize, ay+aSize*.5);
    } else {
      ctx.moveTo(ax, ay);
      ctx.lineTo(ax-aSize*.5, ay+dir*aSize);
      ctx.lineTo(ax+aSize*.5, ay+dir*aSize);
    }
    ctx.closePath(); ctx.fill();
  });

  // Label
  const label = Math.round(seg.value*100)+'cm';
  const fs = hovered ? 11 : 10;
  ctx.font = `${hovered?'bold ':' '}${fs}px DM Mono`;
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  // Background pill
  const tw = ctx.measureText(label).width + 8;
  ctx.fillStyle = hovered ? '#fff8f0' : 'rgba(255,252,248,0.88)';
  ctx.strokeStyle = color; ctx.lineWidth = hovered ? 1.2 : 0.8;
  if(seg.horiz){
    ctx.beginPath(); ctx.roundRect(seg.lx-tw/2, seg.ly-8, tw, 16, 4);
    ctx.fill(); ctx.stroke();
    ctx.fillStyle = color; ctx.fillText(label, seg.lx, seg.ly);
  } else {
    ctx.save();
    ctx.translate(seg.lx, seg.ly); ctx.rotate(-Math.PI/2);
    ctx.beginPath(); ctx.roundRect(-tw/2, -8, tw, 16, 4);
    ctx.fill(); ctx.stroke();
    ctx.fillStyle = color; ctx.fillText(label, 0, 0);
    ctx.restore();
  }

  // Hover: show edit cursor hint
  if(hovered){
    ctx.font = '9px Noto Sans JP';
    ctx.fillStyle = '#c07a30';
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    const hint = 'ã‚¯ãƒªãƒƒã‚¯ã§ç·¨é›†';
    if(seg.horiz) ctx.fillText(hint, seg.lx, seg.ly + 14);
    else { ctx.save(); ctx.translate(seg.lx+14, seg.ly); ctx.rotate(-Math.PI/2); ctx.fillText(hint, 0, 0); ctx.restore(); }
  }

  ctx.restore();
}

// Draw all dimension segments (only in furniture/edit mode, not 3D)
function drawDimensions(ox, oy){
  if(appMode==='3d') return;
  const segs = getDimSegments(ox, oy);
  segs.forEach(seg => {
    drawDimSeg(seg, hoveredDim && hoveredDim.id === seg.id);
  });
}

// Hit test: is mouse near a dimension segment?
function dimAt(mx, my, ox, oy){
  const segs = getDimSegments(ox, oy);
  for(const seg of segs){
    if(seg.horiz){
      const minY = Math.min(seg.y1,seg.y2) - DIM_HIT;
      const maxY = Math.max(seg.y1,seg.y2) + DIM_HIT;
      if(my < minY || my > maxY) continue;
      if(mx >= seg.x1-DIM_HIT && mx <= seg.x2+DIM_HIT) return seg;
    } else {
      const minX = Math.min(seg.x1,seg.x2) - DIM_HIT;
      const maxX = Math.max(seg.x1,seg.x2) + DIM_HIT;
      if(mx < minX || mx > maxX) continue;
      if(my >= seg.y1-DIM_HIT && my <= seg.y2+DIM_HIT) return seg;
    }
  }
  return null;
}

// Open inline edit popup for a dim segment
function openDimEdit(seg){
  dimEditTarget = seg;
  const popup = document.getElementById('dimEditPopup');
  const input = document.getElementById('dimEditInput');
  const wrap = document.getElementById('canvasWrap');
  const wRect = wrap.getBoundingClientRect();
  const canvRect = canvas.getBoundingClientRect();

  // Position popup near the label
  let px = seg.lx + canvRect.left - wRect.left;
  let py = seg.ly + canvRect.top  - wRect.top;
  if(!seg.horiz) px += 20; else py -= 32;

  popup.style.left = (px - 40)+'px';
  popup.style.top  = (py - 12)+'px';
  popup.style.display = 'block';
  input.value = Math.round(seg.value * 100) / 100;
  input.min = seg.axis==='w' ? 0.5 : 0.5;
  setTimeout(()=>{ input.focus(); input.select(); }, 30);
}

function commitDimEdit(){
  const popup = document.getElementById('dimEditPopup');
  if(!dimEditTarget || popup.style.display==='none') return;
  const v = parseFloat(document.getElementById('dimEditInput').value);
  if(!isNaN(v) && v > 0.1){
    const fl = floors[curFloor];
    if(dimEditTarget.target === 'floor'){
      if(dimEditTarget.axis==='w') fl.W = Math.round(v*1000)/1000;
      else                         fl.H = Math.round(v*1000)/1000;
    } else {
      const r = fl.rooms.find(r=>r.id===dimEditTarget.roomId);
      if(r){
        if(dimEditTarget.axis==='w') r.w = Math.round(v*1000)/1000;
        else                         r.h = Math.round(v*1000)/1000;
      }
    }
    draw();
  }
  popup.style.display = 'none';
  dimEditTarget = null;
}

function cancelDimEdit(){
  document.getElementById('dimEditPopup').style.display = 'none';
  dimEditTarget = null;
}

function onDimEditKey(e){
  if(e.key==='Enter')  { e.preventDefault(); commitDimEdit(); }
  if(e.key==='Escape') { e.preventDefault(); cancelDimEdit(); }
}

// â”€â”€â”€ WINDOW DRAWING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const WIN_WALL = 0.12; // wall thickness in meters

function getWinRect(w, ox, oy, fl){
  // Returns pixel rect {rx,ry,rw,rh} and orientation
  const WT = WIN_WALL * SCALE;
  const ww = w.w * SCALE; // window width in px
  // Auto-detect wall based on position
  let wall = w.wall || 'auto';
  if(wall === 'auto'){
    const cx = w.x, cy = w.y;
    const distN = cy;
    const distS = fl.H - cy;
    const distW = cx;
    const distE = fl.W - cx;
    const mn = Math.min(distN, distS, distW, distE);
    if(mn === distN) wall = 'n';
    else if(mn === distS) wall = 's';
    else if(mn === distW) wall = 'w';
    else wall = 'e';
  }
  let rx, ry, rw, rh;
  if(wall === 'n'){
    rx = ox + w.x*SCALE - ww/2; ry = oy - WT/2;
    rw = ww; rh = WT;
  } else if(wall === 's'){
    rx = ox + w.x*SCALE - ww/2; ry = oy + fl.H*SCALE - WT/2;
    rw = ww; rh = WT;
  } else if(wall === 'w'){
    rx = ox - WT/2; ry = oy + w.y*SCALE - ww/2;
    rw = WT; rh = ww;
  } else { // 'e'
    rx = ox + fl.W*SCALE - WT/2; ry = oy + w.y*SCALE - ww/2;
    rw = WT; rh = ww;
  }
  return {rx, ry, rw, rh, wall, isHoriz: wall==='n'||wall==='s'};
}

function drawWindows(ox, oy){
  const fl = floors[curFloor];
  const WT = WIN_WALL * SCALE;
  windows[curFloor].forEach(w => {
    const {rx, ry, rw, rh, wall, isHoriz} = getWinRect(w, ox, oy, fl);
    const sel = w.id === selWinId;

    // 1. Erase wall behind window (paint floor bg color)
    ctx.fillStyle = '#f5f0e8';
    ctx.fillRect(rx-1, ry-1, rw+2, rh+2);

    // 2. Wall stubs on either side of window
    ctx.fillStyle = '#2a2520';
    if(isHoriz){
      // left stub
      ctx.fillRect(rx - 4, ry, 4, rh);
      // right stub
      ctx.fillRect(rx + rw, ry, 4, rh);
    } else {
      // top stub
      ctx.fillRect(rx, ry - 4, rw, 4);
      // bottom stub
      ctx.fillRect(rx, ry + rh, rw, 4);
    }

    // 3. Window frame (outer rect - wall thickness)
    ctx.strokeStyle = sel ? '#5c9fc0' : '#4a7a9a';
    ctx.lineWidth = sel ? 2.5 : 1.8;
    ctx.fillStyle = 'rgba(168, 214, 240, 0.55)';
    ctx.beginPath();
    ctx.rect(rx, ry, rw, rh);
    ctx.fill();
    ctx.stroke();

    // 4. Window type detail inside
    ctx.strokeStyle = sel ? '#4a9aba' : '#6aaac8';
    ctx.lineWidth = 1;
    if(w.wtype === 'sliding' || !w.wtype){
      // sliding: two panes with center line
      if(isHoriz){
        ctx.beginPath(); ctx.moveTo(rx + rw/2, ry); ctx.lineTo(rx + rw/2, ry+rh); ctx.stroke();
        // arrow marks for sliding direction
        const mid = ry + rh/2;
        ctx.beginPath();
        ctx.moveTo(rx + rw*.25, mid); ctx.lineTo(rx + rw*.45, mid);
        ctx.moveTo(rx + rw*.55, mid); ctx.lineTo(rx + rw*.75, mid);
        ctx.stroke();
      } else {
        ctx.beginPath(); ctx.moveTo(rx, ry+rh/2); ctx.lineTo(rx+rw, ry+rh/2); ctx.stroke();
      }
    } else if(w.wtype === 'fixed'){
      // fixed: X cross
      ctx.beginPath();
      ctx.moveTo(rx+2,ry+2); ctx.lineTo(rx+rw-2,ry+rh-2);
      ctx.moveTo(rx+rw-2,ry+2); ctx.lineTo(rx+2,ry+rh-2);
      ctx.stroke();
    } else if(w.wtype === 'slit'){
      // slit: single line through center
      if(isHoriz){
        ctx.beginPath(); ctx.moveTo(rx+4,ry+rh/2); ctx.lineTo(rx+rw-4,ry+rh/2); ctx.stroke();
      } else {
        ctx.beginPath(); ctx.moveTo(rx+rw/2,ry+4); ctx.lineTo(rx+rw/2,ry+rh-4); ctx.stroke();
      }
    }

    // 5. Selection highlight + handles
    if(sel){
      ctx.strokeStyle='rgba(92,159,192,.6)';
      ctx.lineWidth=2; ctx.setLineDash([4,3]);
      ctx.strokeRect(rx-4, ry-4, rw+8, rh+8);
      ctx.setLineDash([]);
      // width handles (ends of window)
      ctx.fillStyle='#5c9fc0';
      if(isHoriz){
        ctx.fillRect(rx-5,ry,5,rh);
        ctx.fillRect(rx+rw,ry,5,rh);
      } else {
        ctx.fillRect(rx,ry-5,rw,5);
        ctx.fillRect(rx,ry+rh,rw,5);
      }
    }

    // 5b. Curtain rail indicator
    if(w.curtainRail){
      const rlW = w.curtainRail*SCALE;
      ctx.save();
      ctx.strokeStyle = sel ? '#7a4aaa' : 'rgba(120,70,180,0.55)';
      ctx.lineWidth = sel ? 2.5 : 1.8;
      ctx.setLineDash([4,2]);
      if(isHoriz){
        // rail above window (outside wall)
        const ry2 = ry - 7;
        ctx.beginPath(); ctx.moveTo(rx+rw/2-rlW/2, ry2); ctx.lineTo(rx+rw/2+rlW/2, ry2); ctx.stroke();
        // end caps
        ctx.setLineDash([]);ctx.lineWidth=1.5;
        ctx.beginPath(); ctx.moveTo(rx+rw/2-rlW/2,ry2-3); ctx.lineTo(rx+rw/2-rlW/2,ry2+3); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(rx+rw/2+rlW/2,ry2-3); ctx.lineTo(rx+rw/2+rlW/2,ry2+3); ctx.stroke();
        // label
        ctx.font='7px DM Mono'; ctx.fillStyle='rgba(120,70,180,0.8)';
        ctx.textAlign='center'; ctx.textBaseline='bottom';
        ctx.fillText('rail '+Math.round(w.curtainRail*100)+'cm', rx+rw/2, ry2-4);
      } else {
        const rx2 = rx - 7;
        ctx.beginPath(); ctx.moveTo(rx2, ry+rh/2-rlW/2); ctx.lineTo(rx2, ry+rh/2+rlW/2); ctx.stroke();
        ctx.setLineDash([]);ctx.lineWidth=1.5;
        ctx.beginPath(); ctx.moveTo(rx2-3,ry+rh/2-rlW/2); ctx.lineTo(rx2+3,ry+rh/2-rlW/2); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(rx2-3,ry+rh/2+rlW/2); ctx.lineTo(rx2+3,ry+rh/2+rlW/2); ctx.stroke();
        ctx.save(); ctx.translate(rx2-5, ry+rh/2); ctx.rotate(-Math.PI/2);
        ctx.font='7px DM Mono'; ctx.fillStyle='rgba(120,70,180,0.8)';
        ctx.textAlign='center'; ctx.textBaseline='bottom';
        ctx.fillText('rail '+Math.round(w.curtainRail*100)+'cm', 0, 0);
        ctx.restore();
      }
      ctx.restore();
    }
    // 6. Label (window width â€” always reflects current w)
    ctx.fillStyle = sel ? '#2a6a8a' : '#5a7a8a';
    ctx.font = '8px DM Mono';
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    const winWidthCm = Math.round(w.w * 100);
    const winTypeStr = w.wtype==='sliding'?'å¼•é•':w.wtype==='fixed'?'FIX':w.wtype==='slit'?'ã‚¹ãƒªãƒƒãƒˆ':'';
    const labelW = `${winTypeStr} W${winWidthCm}`;
    if(isHoriz){
      ctx.fillText(labelW, rx + rw/2, ry - 8);
    } else {
      ctx.save(); ctx.translate(rx - 10, ry + rh/2);
      ctx.rotate(-Math.PI/2); ctx.fillText(labelW, 0, 0); ctx.restore();
    }
  });
}

// Hit test for windows
function winAt(mx, my){
  const fl = floors[curFloor];
  const {ox, oy} = offset();
  const wins = [...windows[curFloor]].reverse();
  const T = 8;
  for(const w of wins){
    const {rx,ry,rw,rh} = getWinRect(w, ox, oy, fl);
    if(mx >= rx-T && mx <= rx+rw+T && my >= ry-T && my <= ry+rh+T) return w;
  }
  return null;
}

// Width handle hit test
function getWinHandle(w, mx, my){
  const fl = floors[curFloor]; const {ox,oy} = offset();
  const {rx,ry,rw,rh,isHoriz} = getWinRect(w, ox, oy, fl);
  const T = 8;
  if(isHoriz){
    if(Math.abs(mx - rx) < T && my >= ry-T && my <= ry+rh+T) return 'left';
    if(Math.abs(mx - (rx+rw)) < T && my >= ry-T && my <= ry+rh+T) return 'right';
  } else {
    if(Math.abs(my - ry) < T && mx >= rx-T && mx <= rx+rw+T) return 'top';
    if(Math.abs(my - (ry+rh)) < T && mx >= rx-T && mx <= rx+rw+T) return 'bottom';
  }
  return null;
}

let _drawPending = false;
function draw(){
  if(_drawPending) return;
  _drawPending = true;
  requestAnimationFrame(()=>{
    _drawPending = false;
    _drawImmediate();
  });
}
function drawNow(){
  // Immediate draw for drag - bypasses RAF debounce for low latency
  _drawPending = false;
  _drawImmediate();
}
function _drawImmediate(){
  // Update global SCALE to reflect current zoom level
  SCALE = BASE_SCALE * viewScale;

  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle='#f5f0e8'; ctx.fillRect(0,0,canvas.width,canvas.height);

  const fl=floors[curFloor]; const {ox,oy}=offset();

  // grid
  if(appMode==='edit'){
    // fine snap grid (0.25m)
    const sg=SNAP*SCALE;
    ctx.strokeStyle='rgba(192,122,48,.12)'; ctx.lineWidth=.4;
    for(let x=ox%sg;x<canvas.width;x+=sg){ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,canvas.height);ctx.stroke();}
    for(let y=oy%sg;y<canvas.height;y+=sg){ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(canvas.width,y);ctx.stroke();}
  }
  ctx.strokeStyle='rgba(180,168,152,.22)'; ctx.lineWidth=.5;
  for(let x=ox%SCALE;x<canvas.width;x+=SCALE){ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,canvas.height);ctx.stroke();}
  for(let y=oy%SCALE;y<canvas.height;y+=SCALE){ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(canvas.width,y);ctx.stroke();}

  fl.rooms.forEach(r=>drawRoom(r,ox,oy));

  // Structural elements drawn BEFORE outer wall border so wall overlaps edge cols cleanly
  structEls[curFloor].forEach(s=>drawStructEl(s,ox,oy,s.id===selStructId));

  // outer wall border (drawn after structs - wraps outside room area)
  // Walls are now drawn at negative offset so this stroke marks the inner boundary
  ctx.strokeStyle='rgba(42,37,32,0.3)'; ctx.lineWidth=1;
  ctx.strokeRect(ox,oy,fl.W*SCALE,fl.H*SCALE);

  // Windows drawn ON TOP of outer wall (cuts through wall)
  drawWindows(ox, oy);

  // Dimension lines: skip during drag for performance
  const _isDragging = !!(roomDrag || furnDrag || structDrag || winDrag || _isTouchPanning);
  if(!_isDragging) drawDimensions(ox, oy);

  furniture[curFloor].forEach(f=>drawFurniture(f,ox,oy,f.id===selFurnId));

  // ghost
  if(structDrag&&structDrag.type==='palette'&&structDrag.ghostX!=null){
    const gs={...structDrag.item, x:(structDrag.ghostX-ox)/SCALE-structDrag.item.w/2, y:(structDrag.ghostY-oy)/SCALE-structDrag.item.h/2};
    ctx.globalAlpha=.5; drawStructEl(gs,ox,oy,false); ctx.globalAlpha=1;
  }
  // Window ghost during drag
  if(winDrag&&winDrag.type==='palette'&&winDrag.ghostX!=null){
    const fl=floors[curFloor];
    const fx=(winDrag.ghostX-ox)/SCALE, fy=(winDrag.ghostY-oy)/SCALE;
    const dN=fy,dS=fl.H-fy,dW=fx,dE=fl.W-fx;
    const mn=Math.min(dN,dS,dW,dE);
    let gwall='n',gwx=fx,gwy=fy;
    if(mn===dN){gwall='n';gwy=0;}else if(mn===dS){gwall='s';gwy=fl.H;}
    else if(mn===dW){gwall='w';gwx=0;}else{gwall='e';gwx=fl.W;}
    const ghw=winDrag.item.w/2;
    if(gwall==='n'||gwall==='s') gwx=Math.max(ghw,Math.min(fl.W-ghw,gwx));
    else gwy=Math.max(ghw,Math.min(fl.H-ghw,gwy));
    const ghostWin={...winDrag.item,id:-1,x:gwx,y:gwy,wall:gwall};
    ctx.globalAlpha=.5;
    const savedSel=selWinId; selWinId=-1;
    // Temporarily add to draw, then remove
    windows[curFloor].push(ghostWin);
    drawWindows(ox,oy);
    windows[curFloor].pop();
    selWinId=savedSel;
    ctx.globalAlpha=1;
  }
  if(furnDrag&&furnDrag.type==='palette'&&furnDrag.ghostX!=null){
    const g={...furnDrag.item, x:(furnDrag.ghostX-ox)/SCALE-furnDrag.item.w/2, y:(furnDrag.ghostY-oy)/SCALE-furnDrag.item.h/2};
    ctx.globalAlpha=.4; drawFurniture(g,ox,oy,false); ctx.globalAlpha=1;
  }

  if(appMode==='edit'&&selRoomId){
    const r=fl.rooms.find(r=>r.id===selRoomId);
    if(r) drawHandles(r,ox,oy);
  }
  if(appMode==='edit'&&selStructId){
    const s=structEls[curFloor].find(s=>s.id===selStructId);
    if(s) drawStructHandles(s,ox,oy);
  }

  if(!_isDragging) updateUI();
}

function drawRoom(r,ox,oy){
  const rx=ox+r.x*SCALE, ry=oy+r.y*SCALE, rw=r.w*SCALE, rh=r.h*SCALE;
  const rot = ((r.rotation||0) % 360) * Math.PI / 180;
  const hasRot = Math.abs(rot) > 0.001;

  if(hasRot){
    ctx.save();
    ctx.translate(rx+rw/2, ry+rh/2);
    ctx.rotate(rot);
    ctx.translate(-rw/2, -rh/2);
    // draw in local space (origin = top-left of room)
    _drawRoomContents(r, 0, 0, rw, rh);
    ctx.restore();
    return;
  }

  _drawRoomContents(r, rx, ry, rw, rh);
}

function _drawRoomContents(r, rx, ry, rw, rh){
  ctx.fillStyle=r.color; ctx.fillRect(rx,ry,rw,rh);

  // Zone overlays: dashed border with label and dimensions
  const zoneDef = r.zoneType ? ZONE_DEFS[r.zoneType] : (r.id==='dining_zone' ? ZONE_DEFS['dining_zone'] : null);
  if(zoneDef || r.id==='dining_zone'){
    const bc = (zoneDef&&zoneDef.borderColor)||'#c07a30';
    const dash = (zoneDef&&zoneDef.dash)||[6,4];
    ctx.save();
    ctx.strokeStyle=bc; ctx.lineWidth=1.5; ctx.setLineDash(dash);
    ctx.strokeRect(rx+2,ry+2,rw-4,rh-4);
    ctx.setLineDash([]);
    // Dimension labels
    ctx.fillStyle = r.tc||'rgba(90,80,60,.8)';
    ctx.font='bold 9px DM Mono'; ctx.textAlign='center'; ctx.textBaseline='middle';
    const wLabel = 'â† '+Math.round(r.w*100)+'cm â†’';
    const hLabel = 'â†• '+Math.round(r.h*100)+'cm';
    ctx.fillText(wLabel, rx+rw/2, ry+rh-10);
    ctx.save(); ctx.translate(rx+12, ry+rh/2); ctx.rotate(-Math.PI/2);
    ctx.fillText(hLabel, 0,0); ctx.restore();
    // Zone name label in center
    ctx.fillStyle=r.tc||'rgba(90,80,60,.8)';
    ctx.font=`bold ${Math.min(11,Math.max(8,rw/8))}px Noto Sans JP`;
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(r.name, rx+rw/2, ry+rh/2);
    // corner L-marks
    const ms=10;
    ctx.strokeStyle=bc; ctx.lineWidth=1.5;
    [[rx+2,ry+2,1,1],[rx+rw-2,ry+2,-1,1],[rx+rw-2,ry+rh-2,-1,-1],[rx+2,ry+rh-2,1,-1]].forEach(([cx2,cy2,sx2,sy2])=>{
      ctx.beginPath(); ctx.moveTo(cx2,cy2+sy2*ms); ctx.lineTo(cx2,cy2); ctx.lineTo(cx2+sx2*ms,cy2); ctx.stroke();
    });
    ctx.restore();
    return; // skip default border for this zone
  }

  if(r.stair){
    ctx.save(); ctx.strokeStyle='rgba(0,0,0,.12)'; ctx.lineWidth=.8;
    ctx.beginPath();
    for(let s=0;s<rw+rh;s+=9){
      const x1=rx+Math.max(0,s-rh),y1=ry+Math.min(rh,s);
      const x2=rx+Math.min(rw,s),  y2=ry+Math.max(0,s-rw);
      ctx.moveTo(x1,y1); ctx.lineTo(x2,y2);
    }
    ctx.stroke(); ctx.restore();
  }

  const isSel = appMode==='edit' && r.id===selRoomId;
  if(isSel){ ctx.fillStyle='rgba(192,122,48,.09)'; ctx.fillRect(rx,ry,rw,rh); }

  ctx.strokeStyle = isSel ? '#c07a30' : '#2a2520';
  ctx.lineWidth   = isSel ? 2.5 : 1.5;
  ctx.strokeRect(rx,ry,rw,rh);

  const fs=Math.min(12,Math.max(8,rw/7));
  ctx.fillStyle=r.tc||'#555'; ctx.font=`${fs}px Noto Sans JP`;
  ctx.textAlign='center'; ctx.textBaseline='middle';
  r.name.split('\n').forEach((ln,i,arr)=>ctx.fillText(ln,rx+rw/2,ry+rh/2+(i-(arr.length-1)/2)*fs*1.4));
}

function drawHandles(r,ox,oy){
  const rx=ox+r.x*SCALE, ry=oy+r.y*SCALE, rw=r.w*SCALE, rh=r.h*SCALE;
  // move handle (top bar)
  ctx.fillStyle='rgba(192,122,48,.18)';
  ctx.fillRect(rx+2, ry+2, rw-4, 18);
  ctx.fillStyle='#c07a30'; ctx.font='bold 10px DM Mono'; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText('âœ¥ ãƒ‰ãƒ©ãƒƒã‚°ã§ç§»å‹•', rx+rw/2, ry+11);
  // right-edge handle
  drawHandle(rx+rw, ry+rh/2, '#c07a30', 7);
  // bottom-edge handle
  drawHandle(rx+rw/2, ry+rh, '#c07a30', 7);
  // corner handle (bigger)
  drawHandle(rx+rw, ry+rh, '#9a5010', 9);
  // resize arrows on handles
  ctx.fillStyle='#fff'; ctx.font='bold 9px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText('â†”', rx+rw, ry+rh/2);
  ctx.fillText('â†•', rx+rw/2, ry+rh);
  ctx.fillText('â¤¡', rx+rw, ry+rh);
  // dimension labels
  ctx.fillStyle='#c07a30'; ctx.font='bold 11px DM Mono'; ctx.textAlign='center'; ctx.textBaseline='middle';
  // bg pill for dimension
  const wLabel = r.w.toFixed(2)+'m';
  const hLabel = r.h.toFixed(2)+'m';
  ctx.fillStyle='rgba(192,122,48,.15)';
  ctx.beginPath(); ctx.roundRect(rx+rw/2-22, ry+rh+8, 44, 16, 8); ctx.fill();
  ctx.fillStyle='#9a5010'; ctx.fillText(wLabel, rx+rw/2, ry+rh+16);
  ctx.save(); ctx.translate(rx+rw+20, ry+rh/2); ctx.rotate(Math.PI/2);
  ctx.fillStyle='rgba(192,122,48,.15)';
  ctx.beginPath(); ctx.roundRect(-22,-10,44,16,8); ctx.fill();
  ctx.fillStyle='#9a5010'; ctx.fillText(hLabel, 0, 0); ctx.restore();
}

function drawHandle(x,y,color,r=5){
  ctx.fillStyle=color;
  ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
  ctx.strokeStyle='#fff'; ctx.lineWidth=1.5;
  ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.stroke();
}

function drawFurniture(f,ox,oy,sel){
  const cx=ox+(f.x+f.w/2)*SCALE, cy=oy+(f.y+f.h/2)*SCALE;
  ctx.save(); ctx.translate(cx,cy); ctx.rotate((f.rotation||0)*Math.PI/180);
  const fw=f.w*SCALE, fh=f.h*SCALE;
  const type=f.type||'';
  if(sel){ctx.shadowColor='rgba(92,122,92,.4)';ctx.shadowBlur=12;}
  ctx.fillStyle=f.color||'#d0c8b8';
  const isRound = f.variant==='ä¸¸ãƒ†ãƒ¼ãƒ–ãƒ«' || f.st==='ä¸¸ãƒ†ãƒ¼ãƒ–ãƒ«';
  if(isRound){
    const r=Math.min(fw,fh)/2;
    ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();
    ctx.shadowBlur=0;
    ctx.strokeStyle=sel?'#5c7a5c':'rgba(0,0,0,.25)'; ctx.lineWidth=sel?2.5:1;
    ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.stroke();
  } else {
    ctx.beginPath(); ctx.roundRect(-fw/2,-fh/2,fw,fh,3); ctx.fill();
    ctx.shadowBlur=0;
    ctx.strokeStyle=sel?'#5c7a5c':'rgba(0,0,0,.25)'; ctx.lineWidth=sel?2.5:1;
    ctx.beginPath(); ctx.roundRect(-fw/2,-fh/2,fw,fh,3); ctx.stroke();
  }
  drawFurnDetail(f.type,fw,fh,f.styleVariant);
  // AI wood grain overlay
  if(f.aiWoodGrain && fw>20 && fh>20){
    ctx.save();
    ctx.globalAlpha=0.12;
    ctx.strokeStyle='rgba(80,40,10,1)';
    ctx.lineWidth=0.8;
    const isRoundG = f.variant==='ä¸¸ãƒ†ãƒ¼ãƒ–ãƒ«'||f.st==='ä¸¸ãƒ†ãƒ¼ãƒ–ãƒ«'||f.styleVariant==='ä¸¸ãƒ†ãƒ¼ãƒ–ãƒ«';
    if(isRoundG){
      const gr=Math.min(fw,fh)/2*0.9;
      for(let i=-3;i<=3;i++){
        const gx=i*gr/3;
        const gy=Math.sqrt(Math.max(0,gr*gr-gx*gx));
        ctx.beginPath(); ctx.moveTo(gx,-gy); ctx.lineTo(gx,gy); ctx.stroke();
      }
    } else {
      const step=Math.max(4,Math.min(fw,fh)/7);
      for(let gx=-fw/2+step;gx<fw/2;gx+=step){
        ctx.beginPath(); ctx.moveTo(gx,-fh/2+2); ctx.lineTo(gx,fh/2-2); ctx.stroke();
      }
    }
    ctx.restore();
  }
  // Counter, shelves, cabinets
  if(type==='counter_straight'||type==='counter_l'||type==='tv_board'||type==='sideboard'){
    ctx.fillStyle=f.color||'#c8c0b0'; ctx.fillRect(-fw/2,-fh/2,fw,fh);
    ctx.strokeStyle='rgba(0,0,0,.25)'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(-fw/2+2,fh/2-6); ctx.lineTo(fw/2-2,fh/2-6); ctx.stroke();
    if(type==='counter_l'){
      const cs=Math.min(fw,fh)*0.45;
      ctx.fillStyle='rgba(0,0,0,.12)'; ctx.fillRect(fw/2-cs,-fh/2,cs,fh/2);
    }
  } else if(type==='shelf'||type==='shelf_tall'){
    ctx.fillStyle=f.color||'#d4c8b0'; ctx.fillRect(-fw/2,-fh/2,fw,fh);
    ctx.strokeStyle='rgba(0,0,0,.2)'; ctx.lineWidth=1;
    const bCount=Math.max(2,Math.round(fw/40));
    for(let i=0;i<bCount;i++){
      const bx=-fw/2+(fw/(bCount-1||1))*i;
      ctx.beginPath(); ctx.moveTo(bx,-fh/2); ctx.lineTo(bx,fh/2); ctx.stroke();
    }
  } else if(type==='cabinet'||type==='shoe_rack'){
    ctx.fillStyle=f.color||'#c0b498'; ctx.fillRect(-fw/2,-fh/2,fw,fh);
    ctx.strokeStyle='rgba(0,0,0,.18)'; ctx.lineWidth=1;
    const doors=Math.max(1,Math.round(fw/35));
    for(let i=1;i<doors;i++){
      const dx=-fw/2+(fw/doors)*i;
      ctx.beginPath(); ctx.moveTo(dx,-fh/2+2); ctx.lineTo(dx,fh/2-2); ctx.stroke();
    }
    ctx.fillStyle='rgba(0,0,0,.25)';
    for(let i=0;i<doors;i++){
      const dx=-fw/2+(fw/doors)*(i+0.5);
      ctx.beginPath(); ctx.arc(dx,fh/4,2.5,0,Math.PI*2); ctx.fill();
    }
  }

  if(fw>30&&fh>18){
    ctx.fillStyle='rgba(0,0,0,.6)'; ctx.font=`${Math.max(8,Math.min(11,fw/6))}px Noto Sans JP`;
    ctx.textAlign='center'; ctx.textBaseline='middle';
    // Dynamic label: show current size instead of original name
    let dispLabel;
    const isRoundDisp = f.styleVariant==='ä¸¸ãƒ†ãƒ¼ãƒ–ãƒ«' || f.st==='ä¸¸ãƒ†ãƒ¼ãƒ–ãƒ«';
    if(isRoundDisp){
      dispLabel = 'Ï†'+Math.round(Math.min(f.w,f.h)*100)+'cm';
    } else if(f.type==='dining4'||f.type==='dining2'){
      dispLabel = Math.round(f.w*100)+'Ã—'+Math.round(f.h*100);
    } else if(f.type==='chair'||f.type==='chair_arm'||f.type==='chair_stool'){
      dispLabel = ''; // æ¤…å­ã¯ãƒ©ãƒ™ãƒ«ä¸è¦
    } else if(f.type==='folding_s'||f.type==='folding_m'||f.type==='folding_l'){
      // Folding table: show current state + actual size
      const state = f.styleVariant==='å±•é–‹' ? 'å±•é–‹' : 'åç´';
      dispLabel = state + ' ' + Math.round(f.w*100) + 'Ã—' + Math.round(f.h*100);
    } else {
      dispLabel = f.label.replace(/\(.*\)/,'').replace('ãƒ€ã‚¤ãƒ‹ãƒ³ã‚°','').trim();
    }
    if(dispLabel) ctx.fillText(dispLabel,0,0);
  }
  if(sel){
    ctx.fillStyle='#5c7a5c';
    [[-fw/2,-fh/2],[fw/2,-fh/2],[fw/2,fh/2],[-fw/2,fh/2]].forEach(([hx,hy])=>{ctx.beginPath();ctx.arc(hx,hy,4,0,Math.PI*2);ctx.fill();});
  }
  ctx.restore();
}

function drawFurnDetail(type,fw,fh,variant){
  ctx.strokeStyle='rgba(0,0,0,.2)'; ctx.lineWidth=1;

  if(type==='sofa3'||type==='sofa1'){
    const n=type==='sofa3'?3:1;
    if(variant==='ãƒ©ã‚¦ãƒ³ãƒ‰ãƒã‚§ã‚¢'||variant==='ã‚ªãƒƒãƒˆãƒãƒ³'){
      // round chair
      ctx.fillStyle='rgba(255,255,255,.35)';
      ctx.beginPath(); ctx.ellipse(0,0,fw*.42,fh*.42,0,0,Math.PI*2); ctx.fill(); ctx.stroke();
      ctx.beginPath(); ctx.ellipse(0,0,fw*.22,fh*.22,0,0,Math.PI*2); ctx.fill();
    } else if(variant==='ã‚³ãƒ¼ãƒŠãƒ¼ã‚½ãƒ•ã‚¡'||variant==='Lã‚·ã‚§ã‚¤ãƒ—'){
      ctx.fillStyle='rgba(255,255,255,.3)';
      ctx.fillRect(-fw/2+3,-fh/2+3,fw*.6,fh-6);
      ctx.fillRect(-fw/2+3,-fh/2+3,fw-6,fh*.5);
    } else {
      // default sofa
      ctx.fillStyle='rgba(255,255,255,.4)'; ctx.fillRect(-fw/2+3,-fh/2+3,fw-6,fh*.3);
      for(let i=0;i<n;i++){ctx.fillStyle='rgba(255,255,255,.22)';ctx.strokeRect(-fw/2+4+i*(fw-8)/n,-fh/2+fh*.38,(fw-8)/n-2,fh*.52);}
    }

  } else if(type==='table_low'){
    if(variant==='ä¸¸ãƒ†ãƒ¼ãƒ–ãƒ«'){
      // inner surface
      const lr=Math.min(fw,fh)*.40;
      ctx.beginPath(); ctx.arc(0,0,lr,0,Math.PI*2);
      ctx.fillStyle='rgba(255,255,255,.25)'; ctx.fill();
      ctx.strokeStyle='rgba(0,0,0,.15)'; ctx.lineWidth=1; ctx.stroke();
      // inner ring
      ctx.beginPath(); ctx.arc(0,0,lr*.55,0,Math.PI*2);
      ctx.strokeStyle='rgba(0,0,0,.1)'; ctx.stroke();
    } else if(variant==='ã‚¬ãƒ©ã‚¹å¤©æ¿'){
      ctx.fillStyle='rgba(180,220,255,.25)'; ctx.fillRect(-fw/2+4,-fh/2+4,fw-8,fh-8);
      ctx.strokeStyle='rgba(100,160,220,.5)'; ctx.strokeRect(-fw/2+4,-fh/2+4,fw-8,fh-8);
    } else {
      ctx.fillStyle='rgba(255,255,255,.25)'; ctx.fillRect(-fw/2+4,-fh/2+4,fw-8,fh-8);
      ctx.strokeRect(-fw/2+4,-fh/2+4,fw-8,fh-8);
    }

  } else if(type==='dining4'||type==='dining2'){
    const seated = type==='dining4'?4:2;
    if(variant==='ä¸¸ãƒ†ãƒ¼ãƒ–ãƒ«'){
      // table surface inner ring (the outer circle is drawn by drawFurniture)
      const tr=Math.min(fw,fh)*.38;
      ctx.beginPath(); ctx.arc(0,0,tr,0,Math.PI*2);
      ctx.fillStyle='rgba(255,255,255,.25)'; ctx.fill();
      ctx.strokeStyle='rgba(0,0,0,.15)'; ctx.lineWidth=1;
      ctx.stroke();
      // grain lines
      ctx.strokeStyle='rgba(0,0,0,.08)'; ctx.lineWidth=1;
      for(let g=-2;g<=2;g++){
        const gx=g*tr*.35;
        const gy=Math.sqrt(Math.max(0,tr*tr-gx*gx));
        ctx.beginPath(); ctx.moveTo(gx,-gy); ctx.lineTo(gx,gy); ctx.stroke();
      }
      // chairs around (nice chair silhouettes)
      const cr2=Math.min(fw,fh)*.50;
      const csr=Math.min(fw,fh)*.11;
      for(let i=0;i<seated;i++){
        const a=(i/seated)*Math.PI*2-Math.PI/2;
        const cx2=Math.cos(a)*cr2, cy2=Math.sin(a)*cr2;
        // seat circle
        ctx.fillStyle='rgba(80,60,40,.18)';
        ctx.beginPath(); ctx.arc(cx2,cy2,csr,0,Math.PI*2); ctx.fill();
        ctx.strokeStyle='rgba(0,0,0,.2)'; ctx.lineWidth=0.8;
        ctx.stroke();
        // backrest arc (away from table)
        ctx.beginPath();
        ctx.arc(cx2,cy2,csr*1.25,a+Math.PI-0.7,a+Math.PI+0.7);
        ctx.lineWidth=Math.max(2,csr*.6);
        ctx.strokeStyle='rgba(60,40,20,.25)';
        ctx.stroke();
      }
    } else {
      ctx.strokeRect(-fw/2+6,-fh/2+12,fw-12,fh-24);
      ctx.fillStyle='rgba(0,0,0,.1)';
      const cw=type==='dining4'?fw-20:fw*.5;
      ctx.fillRect(-cw/2,-fh/2+2,cw,8); ctx.fillRect(-cw/2,fh/2-10,cw,8);
      if(type==='dining4'){ctx.fillRect(-fw/2+2,-fh*.2,8,fh*.4);ctx.fillRect(fw/2-10,-fh*.2,8,fh*.4);}
    }

  } else if(type==='bed_double'||type==='bed_single'){
    if(variant==='ç•³ãƒ™ãƒƒãƒ‰'){
      // tatami pattern
      ctx.strokeStyle='rgba(0,0,0,.15)';
      ctx.strokeRect(-fw/2+2,-fh/2+2,fw-4,fh-4);
      ctx.beginPath(); ctx.moveTo(0,-fh/2+2); ctx.lineTo(0,fh/2-2); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(-fw/2+2,0); ctx.lineTo(fw/2-2,0); ctx.stroke();
    } else if(variant==='ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ '){
      ctx.fillStyle='rgba(0,0,0,.1)'; ctx.fillRect(-fw/2+2,-fh/2+2,fw-4,10);
      ctx.fillStyle='rgba(255,255,255,.5)';
      if(type==='bed_double'){ctx.fillRect(-fw/2+10,-fh/2+14,fw/2-12,fh*.18);ctx.fillRect(2,-fh/2+14,fw/2-12,fh*.18);}
      else ctx.fillRect(-fw/2+8,-fh/2+14,fw-16,fh*.18);
      ctx.fillStyle='rgba(255,255,255,.18)'; ctx.fillRect(-fw/2+4,-fh/2+fh*.35,fw-8,fh*.58);
    } else {
      ctx.fillStyle='rgba(255,255,255,.6)';
      if(type==='bed_double'){ctx.fillRect(-fw/2+8,-fh/2+6,fw/2-10,fh*.2);ctx.fillRect(2,-fh/2+6,fw/2-10,fh*.2);}
      else ctx.fillRect(-fw/2+6,-fh/2+6,fw-12,fh*.2);
      ctx.fillStyle='rgba(255,255,255,.2)'; ctx.fillRect(-fw/2+4,-fh/2+fh*.3,fw-8,fh*.6);
    }

  } else if(type==='kitchen_l'||type==='kitchen_i'||type==='island'){
    if(variant==='æœ¨ç›®'){
      // wood grain lines
      ctx.fillStyle='rgba(180,140,80,.15)'; ctx.fillRect(-fw/2+3,-fh/2+3,fw-6,fh-6);
      ctx.strokeStyle='rgba(140,100,50,.2)'; ctx.lineWidth=1.5;
      for(let i=0;i<5;i++){
        ctx.beginPath(); ctx.moveTo(-fw/2+3,  -fh/2+3+(fh-6)/5*i); ctx.lineTo(fw/2-3, -fh/2+3+(fh-6)/5*i); ctx.stroke();
      }
    } else if(variant==='ã‚¹ãƒ†ãƒ³ãƒ¬ã‚¹'){
      ctx.fillStyle='rgba(200,210,220,.4)'; ctx.fillRect(-fw/2+3,-fh/2+3,fw-6,fh-6);
      ctx.strokeStyle='rgba(150,160,170,.4)'; ctx.lineWidth=1;
      ctx.strokeRect(-fw/2+3,-fh/2+3,fw-6,fh-6);
    } else if(variant==='ã‚¢ã‚¤ãƒ©ãƒ³ãƒ‰é¢¨'||variant==='ãƒãƒ¼ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼'){
      ctx.fillStyle='rgba(255,255,255,.25)'; ctx.fillRect(-fw/2+4,-fh/2+4,fw-8,fh-8);
      // bar stools
      const ns=Math.floor(fw/24);
      for(let i=0;i<ns;i++){
        ctx.fillStyle='rgba(0,0,0,.15)';
        ctx.beginPath(); ctx.arc(-fw/2+12+i*(fw-24)/Math.max(1,ns-1), fh/2+8, 5, 0, Math.PI*2); ctx.fill();
      }
    } else {
      // default kitchen
      ctx.fillStyle='rgba(255,255,255,.3)'; ctx.fillRect(-fw/2+4,-fh/2+4,fw-8,fh-8);
      ctx.strokeStyle='rgba(0,0,0,.2)';
      ctx.beginPath(); ctx.arc(-fw/2+fw*.25,0,fh*.3,0,Math.PI*2); ctx.stroke();
      ctx.beginPath(); ctx.arc(0,0,fh*.22,0,Math.PI*2); ctx.stroke();
      ctx.beginPath(); ctx.arc(fw*.25,0,fh*.22,0,Math.PI*2); ctx.stroke();
    }

  } else if(type==='tv'){
    ctx.fillStyle='rgba(0,0,0,.5)'; ctx.fillRect(-fw/2+4,-fh/2+3,fw-8,fh-6);
    if(variant==='å£æ›ã‘é¢¨'){
      ctx.strokeStyle='rgba(255,255,255,.3)'; ctx.lineWidth=1;
      ctx.strokeRect(-fw/2+6,-fh/2+4,fw-12,fh-8);
    }
  } else if(type==='wardrobe'){
    if(variant==='ã‚ªãƒ¼ãƒ—ãƒ³ãƒ©ãƒƒã‚¯'){
      ctx.strokeStyle='rgba(0,0,0,.2)'; ctx.lineWidth=1;
      const ns=Math.round(fw/24);
      for(let i=1;i<ns;i++) { ctx.beginPath(); ctx.moveTo(-fw/2+i*(fw/ns),- fh/2+3); ctx.lineTo(-fw/2+i*(fw/ns),fh/2-3); ctx.stroke(); }
      for(let j=1;j<3;j++) { ctx.beginPath(); ctx.moveTo(-fw/2+3,-fh/2+j*fh/3); ctx.lineTo(fw/2-3,-fh/2+j*fh/3); ctx.stroke(); }
    } else {
      // sliding doors
      ctx.strokeStyle='rgba(0,0,0,.18)'; ctx.lineWidth=1.5;
      ctx.strokeRect(-fw/2+3,-fh/2+3,fw/2-3,fh-6);
      ctx.strokeRect(0,-fh/2+3,fw/2-3,fh-6);
    }
  } else if(type==='desk'){
    if(variant==='Lå­—ãƒ‡ã‚¹ã‚¯'||variant==='ã‚³ãƒ¼ãƒŠãƒ¼ãƒ‡ã‚¹ã‚¯'){
      ctx.strokeStyle='rgba(0,0,0,.2)';
      ctx.strokeRect(-fw/2+3,-fh/2+3,fw*.65,fh-6);
      ctx.strokeRect(-fw/2+3,-fh/2+3,fw-6,fh*.55);
    } else {
      ctx.strokeRect(-fw/2+4,-fh/2+4,fw-8,fh-8);
    }
  } else if(type==='bath'){
    if(variant==='ä¸¸å½¢ãƒã‚¹'){
      ctx.beginPath(); ctx.ellipse(0,0,fw*.42,fh*.42,0,0,Math.PI*2);
      ctx.fillStyle='rgba(180,220,240,.4)'; ctx.fill(); ctx.stroke();
    } else if(variant==='ã‚·ãƒ£ãƒ¯ãƒ¼å®¤'){
      ctx.fillStyle='rgba(180,220,240,.2)'; ctx.fillRect(-fw/2+3,-fh/2+3,fw-6,fh-6);
      ctx.strokeStyle='rgba(100,160,200,.4)';
      // shower head
      ctx.beginPath(); ctx.arc(0,-fh/2+fh*.25,fh*.15,0,Math.PI*2); ctx.stroke();
    } else {
      ctx.fillStyle='rgba(180,220,240,.35)'; ctx.fillRect(-fw/2+4,-fh/2+4,fw-8,fh-8);
      ctx.strokeRect(-fw/2+4,-fh/2+4,fw-8,fh-8);
      ctx.beginPath(); ctx.arc(0,fh/2-fh*.2,fh*.15,0,Math.PI*2); ctx.stroke();
    }
  } else if(type==='toilet'){
    if(variant==='ã‚¿ãƒ³ã‚¯ãƒ¬ã‚¹'){
      ctx.fillStyle='rgba(220,230,240,.5)';
      ctx.beginPath(); ctx.ellipse(0,fh*.1,fw*.38,fh*.35,0,0,Math.PI*2); ctx.fill(); ctx.stroke();
      ctx.fillRect(-fw*.28,-fh/2+3,fw*.56,fh*.32);
      ctx.strokeRect(-fw*.28,-fh/2+3,fw*.56,fh*.32);
    } else {
      ctx.fillStyle='rgba(220,230,240,.5)';
      ctx.beginPath(); ctx.ellipse(0,fh*.1,fw*.38,fh*.35,0,0,Math.PI*2); ctx.fill(); ctx.stroke();
      ctx.fillRect(-fw*.3,-fh/2+3,fw*.6,fh*.38);
      ctx.strokeRect(-fw*.3,-fh/2+3,fw*.6,fh*.38);
    }
  } else if(type==='plant'){
    const r=Math.min(fw,fh)*.38;
    ctx.fillStyle='rgba(80,160,80,.4)';
    if(variant==='ã‚µãƒœãƒ†ãƒ³'){
      ctx.fillStyle='rgba(80,140,60,.5)';
      ctx.beginPath(); ctx.ellipse(0,0,r*.5,r,0,0,Math.PI*2); ctx.fill(); ctx.stroke();
      ctx.beginPath(); ctx.ellipse(-r*.5,-r*.1,r*.3,r*.5,-.3,0,Math.PI*2); ctx.fill(); ctx.stroke();
    } else {
      // generic round plant
      ctx.beginPath(); ctx.arc(0,-fh*.08,r,0,Math.PI*2); ctx.fill(); ctx.stroke();
      ctx.fillStyle='rgba(100,60,20,.4)';
      ctx.fillRect(-fw*.12,fh*.1,fw*.24,fh*.28);
    }

  } else if(type==='chair'){
    // ãƒ€ã‚¤ãƒ‹ãƒ³ã‚°ãƒã‚§ã‚¢: seat + backrest
    ctx.strokeStyle='rgba(0,0,0,.25)'; ctx.lineWidth=1;
    const sr=Math.min(fw,fh)*.35;
    ctx.fillStyle='rgba(255,255,255,.35)';
    ctx.beginPath(); ctx.arc(0,fh*.08,sr,0,Math.PI*2); ctx.fill(); ctx.stroke();
    // backrest
    ctx.beginPath();
    ctx.arc(0,fh*.08,sr*1.28,-Math.PI*.82,-Math.PI*.18);
    ctx.lineWidth=Math.max(3,fw*.18);
    ctx.strokeStyle='rgba(0,0,0,.28)'; ctx.stroke();
    // legs
    ctx.lineWidth=1; ctx.fillStyle='rgba(0,0,0,.18)';
    [[-1,-1],[1,-1],[-1,1],[1,1]].forEach(([dx,dy])=>{
      ctx.beginPath(); ctx.arc(dx*fw*.26,dy*fh*.26+fh*.06,fw*.048,0,Math.PI*2); ctx.fill();
    });

  } else if(type==='chair_arm'){
    // ã‚¢ãƒ¼ãƒ ãƒã‚§ã‚¢
    ctx.strokeStyle='rgba(0,0,0,.22)'; ctx.lineWidth=1;
    const aw=fw*.44, ah=fh*.44;
    ctx.fillStyle='rgba(255,255,255,.4)';
    ctx.fillRect(-aw*.7,-fh*.42,aw*1.4,ah*.5); ctx.strokeRect(-aw*.7,-fh*.42,aw*1.4,ah*.5);
    ctx.fillStyle='rgba(255,255,255,.28)';
    ctx.beginPath(); ctx.roundRect(-aw*.7,-fh*.02+fh*.06,aw*1.4,ah*.92,3); ctx.fill(); ctx.stroke();
    // arms
    ctx.fillStyle='rgba(255,255,255,.4)';
    ctx.fillRect(-fw*.48,-fh*.42,fw*.14,fh*.88); ctx.strokeRect(-fw*.48,-fh*.42,fw*.14,fh*.88);
    ctx.fillRect( fw*.34,-fh*.42,fw*.14,fh*.88); ctx.strokeRect( fw*.34,-fh*.42,fw*.14,fh*.88);

  } else if(type==='chair_stool'){
    // ã‚¹ãƒ„ãƒ¼ãƒ«: round seat
    ctx.strokeStyle='rgba(0,0,0,.22)'; ctx.lineWidth=1;
    const r2=Math.min(fw,fh)*.38;
    ctx.fillStyle='rgba(255,255,255,.4)';
    ctx.beginPath(); ctx.arc(0,0,r2,0,Math.PI*2); ctx.fill(); ctx.stroke();
    ctx.beginPath(); ctx.arc(0,0,r2*.38,0,Math.PI*2);
    ctx.strokeStyle='rgba(0,0,0,.12)'; ctx.stroke();
    ctx.fillStyle='rgba(0,0,0,.18)';
    for(let i=0;i<4;i++){
      const a=i*Math.PI/2+Math.PI/4;
      ctx.beginPath(); ctx.arc(Math.cos(a)*r2*.72,Math.sin(a)*r2*.72,fw*.045,0,Math.PI*2); ctx.fill();
    }

  } else if(type==='sofa_l'){
    // Lå­—ã‚½ãƒ•ã‚¡: variant = 'NE'|'NW'|'SE'|'SW' â†’ which corner the L fills
    // The L consists of a main long section + a perpendicular side section
    const v = variant||'NE';
    // Arm thickness
    const arm = Math.min(fw,fh)*0.32;
    ctx.strokeStyle='rgba(0,0,0,.2)'; ctx.lineWidth=1;
    ctx.fillStyle='rgba(255,255,255,.35)';
    // Draw L shape as two overlapping rects
    // Main body: full width, arm height on one side
    // Side body: arm width, full height
    // Offset so the corner aligns to the specified quadrant
    let mainX, mainY, mainW, mainH, sideX, sideY, sideW, sideH;
    // NE: corner top-right
    if(v==='NE'){
      mainX=-fw/2; mainY=-fh/2;       mainW=fw;   mainH=arm;    // top bar
      sideX=fw/2-arm; sideY=-fh/2;   sideW=arm;  sideH=fh;     // right bar
    } else if(v==='NW'){
      mainX=-fw/2; mainY=-fh/2;       mainW=fw;   mainH=arm;
      sideX=-fw/2; sideY=-fh/2;      sideW=arm;  sideH=fh;
    } else if(v==='SE'){
      mainX=-fw/2; mainY=fh/2-arm;    mainW=fw;   mainH=arm;
      sideX=fw/2-arm; sideY=-fh/2;   sideW=arm;  sideH=fh;
    } else { // SW
      mainX=-fw/2; mainY=fh/2-arm;    mainW=fw;   mainH=arm;
      sideX=-fw/2; sideY=-fh/2;      sideW=arm;  sideH=fh;
    }
    // Fill
    ctx.fillRect(mainX, mainY, mainW, mainH);
    ctx.fillRect(sideX, sideY, sideW, sideH);
    ctx.strokeRect(mainX, mainY, mainW, mainH);
    ctx.strokeRect(sideX, sideY, sideW, sideH);
    // Cushions along the main bar
    const nCush = Math.max(1, Math.round((fw-arm) / 0.55 / SCALE));
    const cushW = (mainW - (v==='NE'||v==='SE' ? arm : arm)) / Math.max(nCush,1);
    const cushStartX = v==='NW'||v==='SW' ? mainX+arm : mainX;
    for(let i=0; i<nCush; i++){
      ctx.fillStyle='rgba(255,255,255,.45)';
      ctx.fillRect(cushStartX+i*cushW+2, mainY+2, cushW-4, mainH-4);
    }
    // Cushions along the side bar (minus corner overlap)
    const sideAvail = fh - arm;
    const nCushS = Math.max(1, Math.round(sideAvail / 0.55 / SCALE));
    const cushH2 = sideAvail / Math.max(nCushS,1);
    const cushSY = v==='NE'||v==='NW' ? sideY+arm : sideY;
    for(let i=0; i<nCushS; i++){
      ctx.fillStyle='rgba(255,255,255,.45)';
      ctx.fillRect(sideX+2, cushSY+i*cushH2+2, sideW-4, cushH2-4);
    }
    // Corner block (the corner of the L)
    ctx.fillStyle='rgba(255,255,255,.25)';
    if(v==='NE') ctx.fillRect(fw/2-arm, -fh/2, arm, arm);
    else if(v==='NW') ctx.fillRect(-fw/2, -fh/2, arm, arm);
    else if(v==='SE') ctx.fillRect(fw/2-arm, fh/2-arm, arm, arm);
    else ctx.fillRect(-fw/2, fh/2-arm, arm, arm);

  } else if(type==='folding_s'||type==='folding_m'||type==='folding_l'){
    // æŠ˜ã‚ŠãŸãŸã¿ãƒ†ãƒ¼ãƒ–ãƒ«: variant = 'åç´'|'å±•é–‹'
    const expanded = variant==='å±•é–‹';
    ctx.strokeStyle='rgba(0,0,0,.25)'; ctx.lineWidth=1;
    if(expanded){
      // Full rect with center fold line
      ctx.fillStyle='rgba(255,255,255,.3)';
      ctx.fillRect(-fw/2+2,-fh/2+2,fw-4,fh-4);
      ctx.strokeRect(-fw/2+2,-fh/2+2,fw-4,fh-4);
      // Fold line down center
      ctx.setLineDash([4,3]);
      ctx.strokeStyle='rgba(0,0,0,.3)';
      ctx.beginPath(); ctx.moveTo(0,-fh/2+2); ctx.lineTo(0,fh/2-2); ctx.stroke();
      ctx.setLineDash([]);
      // Legs
      ctx.fillStyle='rgba(0,0,0,.15)';
      [[-1,-1],[1,-1],[1,1],[-1,1]].forEach(([dx,dy])=>{
        ctx.beginPath(); ctx.arc(dx*(fw/2-8), dy*(fh/2-8), 4, 0, Math.PI*2); ctx.fill();
      });
    } else {
      // Folded: narrow rect (half width) with hatch
      const hw = fw/2 - 4;
      ctx.fillStyle='rgba(200,190,170,.4)';
      ctx.fillRect(-hw/2, -fh/2+2, hw, fh-4);
      ctx.strokeRect(-hw/2, -fh/2+2, hw, fh-4);
      // Hatch lines to indicate folded
      ctx.strokeStyle='rgba(0,0,0,.15)'; ctx.lineWidth=0.8;
      for(let i=0;i<5;i++){
        const yy = -fh/2+4 + i*(fh-8)/4;
        ctx.beginPath(); ctx.moveTo(-hw/2+2, yy); ctx.lineTo(hw/2-2, yy); ctx.stroke();
      }
      // Small fold arrow
      ctx.strokeStyle='rgba(0,0,0,.3)'; ctx.lineWidth=1;
      ctx.beginPath(); ctx.moveTo(hw/2+4, 0); ctx.lineTo(hw/2+10, 0); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(hw/2+6, -4); ctx.lineTo(hw/2+10, 0); ctx.lineTo(hw/2+6, 4); ctx.stroke();
    }
  }
}


// â”€â”€â”€ STRUCTURAL ELEMENTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawStructEl(s, ox, oy, selected){
  const rx=ox+s.x*SCALE, ry=oy+s.y*SCALE, rw=s.w*SCALE, rh=s.h*SCALE;
  const isCol = s.stype==='column'||s.stype==='wall_corner';

  // Fill â€” match outer wall color so columns look structural
  ctx.fillStyle = selected ? '#6a5a50' : '#2a2520';
  ctx.fillRect(rx, ry, rw, rh);

  // Column: crosshatch detail
  if(isCol){
    ctx.save();
    ctx.strokeStyle='rgba(255,255,255,.18)'; ctx.lineWidth=0.8;
    ctx.beginPath();
    ctx.moveTo(rx, ry); ctx.lineTo(rx+rw, ry+rh);
    ctx.moveTo(rx+rw, ry); ctx.lineTo(rx, ry+rh);
    ctx.stroke();
    ctx.restore();
  }

  // Wall: diagonal hatch
  if(s.stype==='wall_h'||s.stype==='wall_v'){
    ctx.save();
    ctx.strokeStyle='rgba(255,255,255,.1)'; ctx.lineWidth=0.6;
    ctx.beginPath();
    const step=6;
    for(let i=0;i<rw+rh;i+=step){
      const x1=rx+Math.max(0,i-rh), y1=ry+Math.min(rh,i);
      const x2=rx+Math.min(rw,i),   y2=ry+Math.max(0,i-rw);
      ctx.moveTo(x1,y1); ctx.lineTo(x2,y2);
    }
    ctx.stroke();
    ctx.restore();
  }

  // Border
  ctx.strokeStyle = selected ? '#e07030' : 'rgba(0,0,0,.6)';
  ctx.lineWidth   = selected ? 2 : 1;
  ctx.strokeRect(rx, ry, rw, rh);

  // Label only when selected
  if(selected){
    ctx.fillStyle='rgba(255,255,255,.9)';
    ctx.font='bold 9px DM Mono';
    ctx.textAlign='center'; ctx.textBaseline='middle';
    const cm=`${Math.round(s.w*100)}Ã—${Math.round(s.h*100)}cm`;
    // draw outside the element if too small
    const labelY = rh>10 ? ry+rh/2 : ry-8;
    ctx.fillText(cm, rx+rw/2, labelY);
  }
}

function drawStructHandles(s, ox, oy){
  const rx=ox+s.x*SCALE, ry=oy+s.y*SCALE, rw=s.w*SCALE, rh=s.h*SCALE;
  // resize handle: right
  drawHandle(rx+rw, ry+rh/2, '#e07030', 6);
  // resize handle: bottom
  drawHandle(rx+rw/2, ry+rh, '#e07030', 6);
  // corner
  drawHandle(rx+rw, ry+rh, '#b04010', 8);
  // dim labels
  ctx.fillStyle='#c05020'; ctx.font='bold 9px DM Mono';
  ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText(`${s.w.toFixed(2)}m`, rx+rw/2, ry+rh+13);
  ctx.save(); ctx.translate(rx+rw+13, ry+rh/2); ctx.rotate(Math.PI/2);
  ctx.fillText(`${s.h.toFixed(2)}m`, 0, 0); ctx.restore();
}

function structAt(mx, my, ox, oy){
  const list=[...structEls[curFloor]].reverse();
  for(const s of list){
    if(mx>=ox+s.x*SCALE&&mx<=ox+(s.x+s.w)*SCALE&&
       my>=oy+s.y*SCALE&&my<=oy+(s.y+s.h)*SCALE) return s;
  }
  return null;
}

function getStructHandle(s, mx, my, ox, oy){
  const rx=ox+s.x*SCALE, ry=oy+s.y*SCALE, rw=s.w*SCALE, rh=s.h*SCALE;
  const T=12;
  const nearR = Math.abs(mx-(rx+rw))<T && my>ry-T && my<ry+rh+T;
  const nearB = Math.abs(my-(ry+rh))<T && mx>rx-T && mx<rx+rw+T;
  const nearRB= Math.abs(mx-(rx+rw))<T && Math.abs(my-(ry+rh))<T;
  if(nearRB) return 'rb';
  if(nearR)  return 'r';
  if(nearB)  return 'b';
  return null;
}

function selectStruct(id){
  selStructId=id; selRoomId=null;
  renderEditRoomList();
  const ctrl=document.getElementById('structSelControls');
  const s=structEls[curFloor].find(s=>s.id===id);
  if(s){
    ctrl.style.display='block';
    document.getElementById('structSelName').innerHTML=
      `${s.label} <span style="font-family:'DM Mono',monospace;font-size:10px;color:var(--accent-edit);">`+
      `${Math.round(s.w*100)}cm Ã— ${Math.round(s.h*100)}cm</span>`;
    const fl=floors[curFloor];
    ['ssX','ssY'].forEach((el,i)=>{ document.getElementById(el).max=i?fl.H:fl.W; });
    setSlider('ssX','svX',s.x); setSlider('ssY','svY',s.y);
    setSlider('ssW','svW',s.w); setSlider('ssH','svH',s.h);
  } else {
    ctrl.style.display='none';
  }
  draw();
}

function onStructSlider(prop, val){
  const s=structEls[curFloor].find(s=>s.id===selStructId); if(!s) return;
  s[prop]=snapS(parseFloat(val));
  document.getElementById('sv'+prop.toUpperCase()).textContent=parseFloat(val).toFixed(2);
  // update size display
  document.getElementById('structSelName').innerHTML=
    `${s.label} <span style="font-family:'DM Mono',monospace;font-size:10px;color:var(--accent-edit);">`+
    `${Math.round(s.w*100)}cm Ã— ${Math.round(s.h*100)}cm</span>`;
  draw();
}

function deleteStructEl(){
  if(!selStructId) return;
  structEls[curFloor]=structEls[curFloor].filter(s=>s.id!==selStructId);
  selStructId=null;
  document.getElementById('structSelControls').style.display='none';
  draw();
}

// Current wall thickness setting (shared with corner columns)
let wallThk = 0.12;

function onWallThkChange(val){
  wallThk = parseFloat(val);
  document.getElementById('wallThkVal').textContent = Math.round(wallThk*100)+'cm';
}

function autoPlacePerimeterWalls(){
  const fl = floors[curFloor];
  const t = wallThk;
  // Labels for the 4 perimeter walls
  const LABELS = ['å£N','å£S','å£W','å£E'];
  // Remove existing perimeter walls first
  structEls[curFloor] = structEls[curFloor].filter(s => !LABELS.includes(s.label));

  const walls = [
    // North wall (top):  drawn ABOVE y=0 so rooms at y=0 are at inner wall surface
    { x:-t,      y:-t,      w:fl.W+2*t, h:t,    label:'å£N', stype:'wall_h' },
    // South wall (bottom): drawn BELOW fl.H
    { x:-t,      y:fl.H,    w:fl.W+2*t, h:t,    label:'å£S', stype:'wall_h' },
    // West wall (left):  drawn LEFT of x=0
    { x:-t,      y:-t,      w:t,    h:fl.H+2*t, label:'å£W', stype:'wall_v' },
    // East wall (right): drawn RIGHT of fl.W
    { x:fl.W,    y:-t,      w:t,    h:fl.H+2*t, label:'å£E', stype:'wall_v' },
  ];

  walls.forEach(w => {
    structEls[curFloor].push({ id:nStructId++, ...w });
  });
  draw();
}

function autoPlaceCornerColumns(){
  const fl=floors[curFloor];
  const cw=wallThk, ch=wallThk;
  // Place columns flush with each corner â€” x/y at 0 means top-left of column = top-left of floor
  const corners=[
    {x:0,          y:0,          label:'æŸ±NW'},
    {x:fl.W-cw,    y:0,          label:'æŸ±NE'},
    {x:0,          y:fl.H-ch,    label:'æŸ±SW'},
    {x:fl.W-cw,    y:fl.H-ch,    label:'æŸ±SE'},
  ];
  // Remove old corner columns first, then re-add
  structEls[curFloor] = structEls[curFloor].filter(s=>
    !(s.stype==='column' && ['æŸ±NW','æŸ±NE','æŸ±SW','æŸ±SE'].includes(s.label))
  );
  corners.forEach(co=>{
    structEls[curFloor].push({id:nStructId++, stype:'column', x:co.x, y:co.y, w:cw, h:ch, label:co.label});
  });
  draw();
}

// â”€â”€â”€ MODE & FLOOR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function setMode(m){
  appMode=m;
  const is3d = m==='3d';
  document.getElementById('furniturePalette').style.display = m==='furniture'?'block':'none';
  document.getElementById('editPanel').style.display        = m==='edit'     ?'block':'none';
  document.getElementById('modeEditBtn').className = 'mode-btn'+(m==='edit'     ?' active-edit':'');
  document.getElementById('modeFurnBtn').className = 'mode-btn'+(m==='furniture'?' active-furn':'');
  document.getElementById('mode3dBtn').className   = 'mode-btn'+(m==='3d'        ?' active-3d':'');
  document.getElementById('furnitureActions').style.display = m==='furniture'?'':'none';
  document.getElementById('c').style.display = is3d ? 'none' : '';
  document.getElementById('threeContainer').style.display = is3d ? 'block' : 'none';
  document.getElementById('view3dControls').style.display  = is3d ? 'flex'  : 'none';
  document.getElementById('canvasHint').style.display = is3d ? 'none' : '';
  if(is3d){
    init3D();
  } else {
    stop3D();
    draw();
  }
  selFurnId=null; selRoomId=null; selStructId=null; selWinId=null;
  renderEditRoomList();
  if(!is3d) draw();
}

function setFloor(f,e){
  curFloor=f;
  if(appMode==='edit') syncFloorSizeControls(); selFurnId=null; selRoomId=null;
  document.querySelectorAll('.tab').forEach(t=>t.classList.remove('active'));
  e.target.classList.add('active');
  renderEditRoomList(); renderLegend(); updateAreaLabel();
  document.getElementById('diningTip').style.display = f==='2f' ? 'block' : 'none';
  if(window.innerWidth <= 680){ viewScale=1; viewPanX=0; viewPanY=0; } // reset zoom on floor switch
  if(appMode==='3d'){ stop3D(); buildScene3D(); animate3D(); }
  else draw();
}

// â”€â”€â”€ EDIT ROOM PANEL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let _renderListPending = false;
function renderEditRoomList(){
  if(_renderListPending) return;
  _renderListPending = true;
  requestAnimationFrame(()=>{
    _renderListPending = false;
    _renderEditRoomListImmediate();
  });
}
function _renderEditRoomListImmediate(){
  const list=document.getElementById('epRoomList'); list.innerHTML='';
  floors[curFloor].rooms.forEach(r=>{
    const d=document.createElement('div');
    d.className='ep-room-item'+(r.id===selRoomId?' active':'');
    d.innerHTML=`<div class="ep-room-name" style="color:${r.tc||'#333'}">${r.name.replace('\n',' ')}</div>
                 <div class="ep-room-size">${r.w.toFixed(1)}m Ã— ${r.h.toFixed(1)}m</div>`;
    d.onclick=()=>selectRoom(r.id);
    list.appendChild(d);
  });
}

function onRoomNameInput(val){
  const r=floors[curFloor].rooms.find(r=>r.id===selRoomId); if(!r) return;
  r.name=val;
  renderEditRoomList(); draw();
}

// â”€â”€â”€ ZONE MANAGEMENT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const ZONE_DEFS = {
  kitchen_walk: { name:'ã‚­ãƒƒãƒãƒ³æ­©è¡Œã‚¾ãƒ¼ãƒ³', w:1.0, h:2.4, color:'rgba(200,230,255,0.35)', tc:'#2a6a9a', dash:[6,3], borderColor:'#5a9adf' },
  dining_zone:  { name:'ãƒ€ã‚¤ãƒ‹ãƒ³ã‚°ã‚¾ãƒ¼ãƒ³',   w:3.0, h:2.0, color:'rgba(240,232,216,0.5)', tc:'#8a6030', dash:[6,4], borderColor:'#c07a30' },
  storage_zone: { name:'åç´ã‚¾ãƒ¼ãƒ³',         w:2.0, h:1.0, color:'rgba(220,210,195,0.4)', tc:'#6a5a40', dash:[4,4], borderColor:'#9a8060' },
  passage_zone: { name:'é€šè·¯ã‚¾ãƒ¼ãƒ³',         w:0.9, h:3.0, color:'rgba(210,240,210,0.35)', tc:'#3a6a3a', dash:[4,3], borderColor:'#5a9a5a' },
  work_zone:    { name:'ãƒ¯ãƒ¼ã‚¯ã‚¾ãƒ¼ãƒ³',        w:2.0, h:2.0, color:'rgba(230,220,255,0.35)', tc:'#5a3a8a', dash:[6,3], borderColor:'#8a6acf' },
  free_zone:    { name:'ãƒ•ãƒªãƒ¼ã‚¾ãƒ¼ãƒ³',        w:2.0, h:2.0, color:'rgba(220,240,230,0.3)', tc:'#3a6a5a', dash:[4,4], borderColor:'#6aaa8a' },
};

let zoneCounter = 1;
function addZone(type){
  const def = ZONE_DEFS[type];
  if(!def) return;
  const fl = floors[curFloor];
  const id = type + '_' + (zoneCounter++);
  fl.rooms.push({
    id, name: def.name, x:0.5, y:0.5,
    w: def.w, h: def.h,
    color: def.color, tc: def.tc,
    zoneType: type,  // marks it as a zone overlay
  });
  renderEditRoomList();
  draw();
}

function rotateRoom(deg){
  const r = floors[curFloor].rooms.find(r=>r.id===selRoomId);
  if(!r) return;
  r.rotation = ((r.rotation||0) + deg + 360) % 360;
  updateSliders(); draw();
}

function setRoomRotation(deg){
  const r = floors[curFloor].rooms.find(r=>r.id===selRoomId);
  if(!r) return;
  r.rotation = deg;
  updateSliders(); draw();
}

function onRoomRotInput(val){
  const v = parseInt(val);
  if(isNaN(v)) return;
  const r = floors[curFloor].rooms.find(r=>r.id===selRoomId);
  if(!r) return;
  r.rotation = ((v % 360) + 360) % 360;
  draw();
}

function nudgeRoom(prop, delta){
  const r = floors[curFloor].rooms.find(r=>r.id===selRoomId);
  if(!r) return;
  if(prop==='x' || prop==='y'){
    const vtl = roomVisualTL(r);
    const vx = prop==='x' ? Math.round((vtl.x+delta)*100)/100 : vtl.x;
    const vy = prop==='y' ? Math.round((vtl.y+delta)*100)/100 : vtl.y;
    const stored = roomXYfromVisualTL(r, vx, vy);
    r.x = Math.round(stored.x*100)/100;
    r.y = Math.round(stored.y*100)/100;
  } else if(prop==='w') r.w = Math.max(0.1, Math.round((r.w+delta)*100)/100);
  else if(prop==='h') r.h = Math.max(0.1, Math.round((r.h+delta)*100)/100);
  updateSliders();
  draw();
}

// â”€â”€ Rotation-aware coordinate helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Returns visual bounding-box top-left (what the user sees as x,y)
function roomVisualTL(r){
  const rot = ((r.rotation||0) % 360) * Math.PI / 180;
  const cx = r.x + r.w/2, cy = r.y + r.h/2;
  const ac = Math.abs(Math.cos(rot)), as = Math.abs(Math.sin(rot));
  const hw = ac*r.w/2 + as*r.h/2;
  const hh = as*r.w/2 + ac*r.h/2;
  return { x: cx - hw, y: cy - hh, hw, hh };
}

// Given desired visual top-left (vx,vy), compute stored r.x, r.y
function roomXYfromVisualTL(r, vx, vy){
  const rot = ((r.rotation||0) % 360) * Math.PI / 180;
  const ac = Math.abs(Math.cos(rot)), as = Math.abs(Math.sin(rot));
  const hw = ac*r.w/2 + as*r.h/2;
  const hh = as*r.w/2 + ac*r.h/2;
  const cx = vx + hw, cy = vy + hh;
  return { x: cx - r.w/2, y: cy - r.h/2 };
}

function selectRoom(id){
  selRoomId=id; renderEditRoomList(); updateSliders(); draw();
}

function updateSliders(){
  const r=floors[curFloor].rooms.find(r=>r.id===selRoomId);
  const ctrl=document.getElementById('epRoomControls');
  if(!r){ctrl.style.display='none';return;}
  ctrl.style.display='block';
  const fl=floors[curFloor];
  ['slX','slY'].forEach((id,i)=>document.getElementById(id).max=i?fl.H:fl.W);
  ['slW','slH'].forEach((id,i)=>document.getElementById(id).max=i?fl.H:fl.W);
  const vtl = roomVisualTL(r);
  const visW = Math.round(vtl.hw*2*100)/100; // visual width (accounts for rotation)
  const visH = Math.round(vtl.hh*2*100)/100; // visual height
  ['slX','slY','slW','slH'].forEach((id,i)=>{
    const val = [vtl.x, vtl.y, visW, visH][i];
    const el = document.getElementById(id);
    if(el) el.value = val.toFixed(2);
  });
  const nameEl=document.getElementById('roomNameInput');
  if(nameEl) nameEl.value=r.name.replace('\n',' ');
  const rotEl=document.getElementById('slR_room');
  if(rotEl) rotEl.value = (r.rotation||0);
  showWallColorSwatch(r);
}

function setSlider(slId,valId,v){
  document.getElementById(slId).value=v;
  document.getElementById(valId).textContent=parseFloat(v).toFixed(2);
}

function onSlider(prop,val){
  const r=floors[curFloor].rooms.find(r=>r.id===selRoomId); if(!r) return;
  const fl=floors[curFloor]; const v=parseFloat(val);
  if(isNaN(v) || val==='' || val==='-') return;
  if(prop==='x' || prop==='y'){
    // User inputs visual top-left â†’ convert to stored x,y
    const vtl = roomVisualTL(r);
    const vx = prop==='x' ? Math.round(v*100)/100 : vtl.x;
    const vy = prop==='y' ? Math.round(v*100)/100 : vtl.y;
    const stored = roomXYfromVisualTL(r, vx, vy);
    r.x = Math.round(stored.x*100)/100;
    r.y = Math.round(stored.y*100)/100;
  } else if(prop==='w' || prop==='h'){
    // Convert visual w/h back to stored r.w, r.h (accounts for rotation)
    const rot = ((r.rotation||0) % 360) * Math.PI / 180;
    const ac = Math.abs(Math.cos(rot)), as = Math.abs(Math.sin(rot));
    const vtl2 = roomVisualTL(r);
    const curVisW = vtl2.hw*2, curVisH = vtl2.hh*2;
    const newVisW = prop==='w' ? Math.max(0.1, Math.round(v*100)/100) : curVisW;
    const newVisH = prop==='h' ? Math.max(0.1, Math.round(v*100)/100) : curVisH;
    // Inverse of [[ac,as],[as,ac]]: det = acÂ²-asÂ²
    const det = ac*ac - as*as;
    if(Math.abs(det) > 0.01){
      r.w = Math.max(0.1, Math.round((ac*newVisW - as*newVisH)/det * 100)/100);
      r.h = Math.max(0.1, Math.round((-as*newVisW + ac*newVisH)/det * 100)/100);
    } else {
      // Near 45Â°: just swap or keep
      r.w = Math.max(0.1, Math.round(newVisH*100)/100);
      r.h = Math.max(0.1, Math.round(newVisW*100)/100);
    }
  }
  // sync display with visual coordinates
  const vtl3 = roomVisualTL(r);
  const syncVisW = Math.round(vtl3.hw*2*100)/100;
  const syncVisH = Math.round(vtl3.hh*2*100)/100;
  ['x','y','w','h'].forEach(k=>{
    const el=document.getElementById({x:'slX',y:'slY',w:'slW',h:'slH'}[k]);
    if(el && el!==document.activeElement){
      const val = k==='x'?vtl3.x : k==='y'?vtl3.y : k==='w'?syncVisW : syncVisH;
      el.value = val.toFixed(2);
    }
  });
  renderEditRoomList(); draw();
}

// â”€â”€â”€ HIT TESTING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function getHandle(r,mx,my,ox,oy){
  const rx=ox+r.x*SCALE, ry=oy+r.y*SCALE, rw=r.w*SCALE, rh=r.h*SCALE;
  const T=14;
  const nearR  = Math.abs(mx-(rx+rw))<T && my>ry-T && my<ry+rh+T;
  const nearB  = Math.abs(my-(ry+rh))<T && mx>rx-T && mx<rx+rw+T;
  const nearRB = Math.abs(mx-(rx+rw))<T && Math.abs(my-(ry+rh))<T;
  if(nearRB) return 'rb';
  if(nearR)  return 'r';
  if(nearB)  return 'b';
  return null;
}

function roomAt(mx,my,ox,oy){
  const rooms=[...floors[curFloor].rooms].reverse();
  for(const r of rooms){
    const rot = ((r.rotation||0)) * Math.PI / 180;
    if(Math.abs(rot) < 0.001){
      // No rotation - simple AABB
      if(mx>=ox+r.x*SCALE&&mx<=ox+(r.x+r.w)*SCALE&&my>=oy+r.y*SCALE&&my<=oy+(r.y+r.h)*SCALE) return r;
    } else {
      // Rotate the mouse point into the room's local space
      const cx = ox+(r.x+r.w/2)*SCALE, cy = oy+(r.y+r.h/2)*SCALE;
      const dx = mx-cx, dy = my-cy;
      const cos = Math.cos(-rot), sin = Math.sin(-rot);
      const lx = dx*cos - dy*sin, ly = dx*sin + dy*cos;
      if(Math.abs(lx)<=r.w*SCALE/2 && Math.abs(ly)<=r.h*SCALE/2) return r;
    }
  }
  return null;
}

function furnAt(mx,my){
  const {ox,oy}=offset();
  const list=[...furniture[curFloor]].reverse();
  for(const f of list){
    const cx=ox+(f.x+f.w/2)*SCALE, cy=oy+(f.y+f.h/2)*SCALE;
    const rad=(-(f.rotation||0))*Math.PI/180;
    const dx=mx-cx,dy=my-cy;
    const rx=dx*Math.cos(rad)-dy*Math.sin(rad);
    const ry=dx*Math.sin(rad)+dy*Math.cos(rad);
    const isRound = f.variant==='ä¸¸ãƒ†ãƒ¼ãƒ–ãƒ«'||f.st==='ä¸¸ãƒ†ãƒ¼ãƒ–ãƒ«'||f.type==='chair_stool';
    if(isRound){
      const r=Math.min(f.w,f.h)*SCALE/2;
      if(rx*rx+ry*ry<r*r) return f;
    } else {
      if(Math.abs(rx)<f.w*SCALE/2&&Math.abs(ry)<f.h*SCALE/2) return f;
    }
  }
  return null;
}

// â”€â”€â”€ MOUSE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function cxy(e){const r=canvas.getBoundingClientRect();return{x:e.clientX-r.left,y:e.clientY-r.top};}

canvas.addEventListener('mousedown',e=>{
  const {x,y}=cxy(e); const {ox,oy}=offset();

  // Dimension click (both modes) â€” open edit popup
  if(appMode!=='3d'){
    const ds = dimAt(x,y,ox,oy);
    if(ds){ openDimEdit(ds); return; }
  }

  if(appMode==='furniture'){
    // furniture mode: windows first, then furniture, then structs
    const wh=winAt(x,y);
    if(wh){
      const whandle=getWinHandle(wh,x,y);
      if(whandle){
        selectWin(wh.id);
        winDrag={type:'resize',id:wh.id,handle:whandle,startX:x,startY:y,origW:wh.w,origX:wh.x,origY:wh.y};
      } else {
        selectWin(wh.id);
        winDrag={type:'move',id:wh.id,startX:x,startY:y,origX:wh.x,origY:wh.y};
      }
      selFurnId=null; selStructId=null; furnDrag=null; structDrag=null;
    } else {
      const hit=furnAt(x,y);
      if(hit){
        // Folding table: double-click or re-click toggles expand/collapse
        const isFolding = hit.type==='folding_s'||hit.type==='folding_m'||hit.type==='folding_l';
        if(isFolding && hit.id===selFurnId){
          toggleFoldingTable(hit);
          return;
        }
        selFurnId=hit.id; selStructId=null; selWinId=null; selRoomId=null;
        furnDrag={type:'move',id:hit.id,startX:x,startY:y,origX:hit.x,origY:hit.y};
        document.getElementById('winPanel').style.display='none';
      } else {
        const sh=structAt(x,y,ox,oy);
        if(sh){
          selStructId=sh.id; selFurnId=null; selWinId=null; selRoomId=null; furnDrag=null;
          structDrag={type:'move',id:sh.id,startX:x,startY:y,origX:sh.x,origY:sh.y};
          document.getElementById('winPanel').style.display='none';
        } else {
          selFurnId=null; selWinId=null; selRoomId=null; furnDrag=null;
          document.getElementById('winPanel').style.display='none';
        }
      }
    }

  } else {
    // edit mode: structs take priority

    // 1) resize handle on selected struct
    if(selStructId){
      const s=structEls[curFloor].find(s=>s.id===selStructId);
      if(s){
        const h=getStructHandle(s,x,y,ox,oy);
        if(h){
          structDrag={type:'resize',id:selStructId,handle:h,
            startX:x,startY:y,origW:s.w,origH:s.h,origX:s.x,origY:s.y};
          draw(); return;
        }
        // move selected struct
        if(x>=ox+s.x*SCALE&&x<=ox+(s.x+s.w)*SCALE&&
           y>=oy+s.y*SCALE&&y<=oy+(s.y+s.h)*SCALE){
          structDrag={type:'move',id:selStructId,startX:x,startY:y,origX:s.x,origY:s.y};
          draw(); return;
        }
      }
    }

    // 2) hit any struct
    const sh=structAt(x,y,ox,oy);
    if(sh){
      selStructId=sh.id; selRoomId=null;
      structDrag={type:'move',id:sh.id,startX:x,startY:y,origX:sh.x,origY:sh.y};
      selectStruct(sh.id);
      draw(); return;
    }

    // 3) resize handle on selected room
    if(selRoomId){
      const r=floors[curFloor].rooms.find(r=>r.id===selRoomId);
      if(r){
        const h=getHandle(r,x,y,ox,oy);
        if(h){
          roomDrag={type:'resize',roomId:selRoomId,handle:h,
            startX:x,startY:y,origW:r.w,origH:r.h,origX:r.x,origY:r.y};
          return;
        }
        if(x>=ox+r.x*SCALE&&x<=ox+(r.x+r.w)*SCALE&&
           y>=oy+r.y*SCALE&&y<=oy+(r.y+r.h)*SCALE){
          roomDrag={type:'move',roomId:selRoomId,startX:x,startY:y,origX:r.x,origY:r.y};
          return;
        }
      }
    }

    // 4) hit any room
    const rh=roomAt(x,y,ox,oy);
    if(rh){
      selStructId=null;
      document.getElementById('structSelControls').style.display='none';
      selectRoom(rh.id);
      roomDrag={type:'move',roomId:rh.id,startX:x,startY:y,origX:rh.x,origY:rh.y};
    } else {
      selRoomId=null; selStructId=null;
      renderEditRoomList();
      document.getElementById('epRoomControls').style.display='none';
      document.getElementById('structSelControls').style.display='none';
      draw();
    }
  }
  draw();
});

canvas.addEventListener('mousemove',e=>{
  const {x,y}=cxy(e); const {ox,oy}=offset();
  const _dragging = !!(roomDrag||furnDrag||structDrag||winDrag);

  // Dimension hover (both modes)
  if(appMode!=='3d'){
    const ds = dimAt(x,y,ox,oy);
    if(ds){
      if(!hoveredDim || hoveredDim.id!==ds.id){ hoveredDim=ds; draw(); }
      canvas.style.cursor='pointer';
    } else {
      if(hoveredDim){ hoveredDim=null; draw(); }
    }
  }

  if(appMode==='furniture'){
    // window move/resize
    if(winDrag&&winDrag.type==='move'){
      const w=windows[curFloor].find(w=>w.id===winDrag.id); if(w){
        const fl=floors[curFloor];
        const nx=winDrag.origX+(x-winDrag.startX)/SCALE;
        const ny=winDrag.origY+(y-winDrag.startY)/SCALE;
        const hw=w.w/2;
        // constrain along wall
        const wl=w.wall;
        if(wl==='n'||wl==='s'){ w.x=Math.max(hw,Math.min(fl.W-hw,nx)); }
        else { w.y=Math.max(hw,Math.min(fl.H-hw,ny)); }
        draw();
      }
    } else if(winDrag&&winDrag.type==='resize'){
      const w=windows[curFloor].find(w=>w.id===winDrag.id); if(w){
        const {isHoriz}=getWinRect(w,ox,oy,floors[curFloor]);
        const delta=isHoriz ? (x-winDrag.startX)/SCALE : (y-winDrag.startY)/SCALE;
        const sign=(winDrag.handle==='right'||winDrag.handle==='bottom') ? 1 : -1;
        w.w=Math.max(0.2,Math.min(3.0, winDrag.origW + sign*delta*2));
        document.getElementById('wslW').value=w.w;
        document.getElementById('wvalW').textContent=Math.round(w.w*100)+'cm';
        draw();
      }
    } else if(structDrag&&structDrag.type==='move'){
      const s=structEls[curFloor].find(s=>s.id===structDrag.id);
      if(s){ s.x=snapS(Math.max(0,structDrag.origX+(x-structDrag.startX)/SCALE));
             s.y=snapS(Math.max(0,structDrag.origY+(y-structDrag.startY)/SCALE)); drawNow(); }
    } else if(furnDrag&&furnDrag.type==='move'){
      const f=furniture[curFloor].find(f=>f.id===furnDrag.id);
      if(f){f.x=furnDrag.origX+(x-furnDrag.startX)/SCALE; f.y=furnDrag.origY+(y-furnDrag.startY)/SCALE; drawNow();}
    }
    const overStruct=structAt(x,y,ox,oy);
    canvas.style.cursor = (structDrag&&structDrag.type==='move')||(furnDrag&&furnDrag.type==='move') ? 'grabbing'
      : overStruct ? 'grab' : (furnAt(x,y)?'grab':'default');
  } else {
    if(structDrag&&(structDrag.type==='move'||structDrag.type==='resize')){
      const s=structEls[curFloor].find(s=>s.id===structDrag.id);
      if(s){
        const dx=(x-structDrag.startX)/SCALE, dy=(y-structDrag.startY)/SCALE;
        if(structDrag.type==='move'){
          s.x=snapS(Math.max(0,structDrag.origX+dx));
          s.y=snapS(Math.max(0,structDrag.origY+dy));
        } else {
          const h=structDrag.handle;
          if(h==='r'||h==='rb') s.w=snapS(Math.max(.01,structDrag.origW+dx));
          if(h==='b'||h==='rb') s.h=snapS(Math.max(.01,structDrag.origH+dy));
        }
        setSlider('ssX','svX',s.x); setSlider('ssY','svY',s.y);
        setSlider('ssW','svW',s.w); setSlider('ssH','svH',s.h);
        draw();
      }
    } else if(roomDrag){
      const r=floors[curFloor].rooms.find(r=>r.id===roomDrag.roomId);
      if(r){
        const dx=(x-roomDrag.startX)/SCALE, dy=(y-roomDrag.startY)/SCALE;
        if(roomDrag.type==='move'){
          const _fl=floors[curFloor];
          r.x=snapS(Math.max(0, Math.min(_fl.W - Math.max(r.w,0.1), roomDrag.origX+dx)));
          r.y=snapS(Math.max(0, Math.min(_fl.H - Math.max(r.h,0.1), roomDrag.origY+dy)));
        } else {
          const h=roomDrag.handle;
          const fl=floors[curFloor];
          if(h==='r'||h==='rb') r.w=snapS(Math.max(.1, Math.min(fl.W-r.x, roomDrag.origW+dx)));
          if(h==='b'||h==='rb') r.h=snapS(Math.max(.1, Math.min(fl.H-r.y, roomDrag.origH+dy)));
        }
        drawNow(); // immediate draw during drag for smoothness
      }
    } else {
      // cursor hints
      if(selRoomId){
        const r=floors[curFloor].rooms.find(r=>r.id===selRoomId);
        if(r){
          const h=getHandle(r,x,y,ox,oy);
          if(h==='rb'){canvas.style.cursor='nwse-resize';return;}
          if(h==='r') {canvas.style.cursor='ew-resize'; return;}
          if(h==='b') {canvas.style.cursor='ns-resize'; return;}
        }
      }
      canvas.style.cursor=roomAt(x,y,ox,oy)?'move':'default';
    }
  }
});

canvas.addEventListener('mouseup', ()=>{
  const wasRoomDrag = roomDrag && roomDrag.type === 'move';
  const wasFurnDrag = !!furnDrag;
  furnDrag=null; roomDrag=null; structDrag=null; winDrag=null;
  if(wasRoomDrag){ updateSliders(); renderEditRoomList(); }
  // Always redraw after drag ends to restore dims/highlights
  draw();
});
canvas.addEventListener('mouseleave',()=>{furnDrag=null;roomDrag=null;structDrag=null;winDrag=null;if(hoveredDim){hoveredDim=null;draw();}});

// â”€â”€ TOUCH EVENTS (iPad/mobile) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function touchToMouse(touch){
  const r=canvas.getBoundingClientRect();
  return {x:touch.clientX-r.left, y:touch.clientY-r.top};
}

// â”€â”€â”€ MOBILE PAN / PINCH-ZOOM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let viewScale = 1.0;
let viewPanX  = 0;
let viewPanY  = 0;
let _pinchStartDist = 0;
let _pinchStartScale = 1;
let _pinchStartPanX = 0;
let _pinchStartPanY = 0;
let _pinchMidX = 0;
let _pinchMidY = 0;
let _touchPanStartX = 0;
let _touchPanStartY = 0;
let _touchPanStartPanX = 0;
let _touchPanStartPanY = 0;
let _isTouchPanning = false; // true when panning (not dragging a room/furniture)

function isMobile(){ return window.innerWidth <= 680; }

function resetView(){
  viewScale = 1.0; viewPanX = 0; viewPanY = 0; draw();
}

function effectiveScale(){ return SCALE * viewScale; }

// Override offset() to include pan
// (will be patched below)

function _pinchDist(t){ return Math.hypot(t[0].clientX-t[1].clientX, t[0].clientY-t[1].clientY); }
function _pinchMid(t,r){ return { x:(t[0].clientX+t[1].clientX)/2-r.left, y:(t[0].clientY+t[1].clientY)/2-r.top }; }

canvas.addEventListener('touchstart',e=>{
  if(appMode==='3d') return;
  e.preventDefault();

  if(e.touches.length === 2){
    // Pinch start
    canvas.dispatchEvent(new MouseEvent('mouseup',{bubbles:true})); // cancel any drag
    _isTouchPanning = false;
    const r = canvas.getBoundingClientRect();
    _pinchStartDist  = _pinchDist(e.touches);
    _pinchStartScale = viewScale;
    _pinchStartPanX  = viewPanX;
    _pinchStartPanY  = viewPanY;
    const mid = _pinchMid(e.touches, r);
    _pinchMidX = mid.x; _pinchMidY = mid.y;
    return;
  }

  if(e.touches.length === 1){
    const t = e.touches[0];
    const r = canvas.getBoundingClientRect();
    const x = t.clientX - r.left, y = t.clientY - r.top;
    const {ox,oy} = offset();
    // Check if finger is on a room/furniture/struct â€” if so, dispatch mousedown
    const hitRoom  = appMode==='edit' && roomAt(x,y,ox,oy);
    const hitFurn  = appMode==='furniture' && furnAt(x,y);
    const hitStruct= appMode==='edit' && structAt(x,y,ox,oy);
    if(hitRoom || hitFurn || hitStruct){
      _isTouchPanning = false;
      canvas.dispatchEvent(new MouseEvent('mousedown',{clientX:t.clientX,clientY:t.clientY,button:0,bubbles:true}));
    } else {
      // Pan mode
      _isTouchPanning = true;
      _touchPanStartX = t.clientX;
      _touchPanStartY = t.clientY;
      _touchPanStartPanX = viewPanX;
      _touchPanStartPanY = viewPanY;
    }
  }
},{passive:false});

canvas.addEventListener('touchmove',e=>{
  if(appMode==='3d') return;
  e.preventDefault();

  if(e.touches.length === 2){
    const r = canvas.getBoundingClientRect();
    const dist = _pinchDist(e.touches);
    const newScale = Math.max(0.3, Math.min(4.0, _pinchStartScale * dist / _pinchStartDist));
    const mid = _pinchMid(e.touches, r);
    // Zoom toward pinch center
    const scaleDiff = newScale - _pinchStartScale;
    viewPanX = _pinchStartPanX - (_pinchMidX) * scaleDiff;
    viewPanY = _pinchStartPanY - (_pinchMidY) * scaleDiff;
    // Also pan with midpoint movement
    viewPanX += mid.x - _pinchMidX;
    viewPanY += mid.y - _pinchMidY;
    viewScale = newScale;
    draw();
    return;
  }

  if(e.touches.length === 1){
    const t = e.touches[0];
    if(_isTouchPanning){
      viewPanX = _touchPanStartPanX + (t.clientX - _touchPanStartX);
      viewPanY = _touchPanStartPanY + (t.clientY - _touchPanStartY);
      draw();
    } else {
      canvas.dispatchEvent(new MouseEvent('mousemove',{clientX:t.clientX,clientY:t.clientY,bubbles:true}));
    }
  }
},{passive:false});

canvas.addEventListener('touchend',e=>{
  if(appMode==='3d') return;
  e.preventDefault();
  _isTouchPanning = false;
  if(e.touches.length === 0){
    canvas.dispatchEvent(new MouseEvent('mouseup',{bubbles:true}));
  }
},{passive:false});

// â”€â”€â”€ PALETTE DRAG-AND-DROP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Struct drag â€” use event delegation so it works even if panel was hidden at init
document.addEventListener('dragstart', e=>{
  const item = e.target.closest('.struct-item');
  if(!item) return;
  const d=item.dataset;
  furnDrag=null;
  structDrag={type:'palette', item:{stype:d.stype, label:d.label, w:parseFloat(d.sw), h:parseFloat(d.sh)}};
  e.dataTransfer.effectAllowed='copy';
});
document.addEventListener('dragend', e=>{
  if(e.target.closest('.struct-item')) structDrag=null;
});

// Struct touch drag for iPad (event delegation on editPanel)
document.getElementById('editPanel').addEventListener('touchstart',e=>{
  const item=e.target.closest('.struct-item');
  if(!item) return;
  const d=item.dataset;
  furnDrag=null;
  structDrag={type:'palette',item:{stype:d.stype,label:d.label,w:parseFloat(d.sw),h:parseFloat(d.sh)},ghostX:null,ghostY:null};
  e.preventDefault();
},{passive:false});

document.getElementById('editPanel').addEventListener('touchmove',e=>{
  if(!structDrag||structDrag.type!=='palette') return;
  e.preventDefault();
  const t=e.touches[0];
  const cr=canvas.getBoundingClientRect();
  structDrag.ghostX=t.clientX-cr.left;
  structDrag.ghostY=t.clientY-cr.top;
  draw();
},{passive:false});

document.getElementById('editPanel').addEventListener('touchend',e=>{
  if(!structDrag||structDrag.type!=='palette') return;
  e.preventDefault();
  const t=e.changedTouches[0];
  const cr=canvas.getBoundingClientRect();
  const mx=t.clientX-cr.left, my=t.clientY-cr.top;
  if(mx>=0&&my>=0&&mx<=canvas.width&&my<=canvas.height){
    const {ox,oy}=offset();
    const ns={...structDrag.item,id:nStructId++,
      x:snapS(Math.max(0,(mx-ox)/SCALE-structDrag.item.w/2)),
      y:snapS(Math.max(0,(my-oy)/SCALE-structDrag.item.h/2))};
    structEls[curFloor].push(ns);
    selectStruct(ns.id);
  }
  structDrag=null; draw();
},{passive:false});

document.querySelectorAll('.furniture-item').forEach(item=>{
  item.addEventListener('dragstart',e=>{
    const d=item.dataset;
    structDrag=null;
    furnDrag={type:'palette',item:{type:d.type,label:d.label,color:d.color,w:parseFloat(d.w),h:parseFloat(d.h),rotation:0,st:d.style||''}};
    e.dataTransfer.effectAllowed='copy';
  });
  item.addEventListener('dragend', ()=>{ furnDrag=null; });

  // Touch drag for iPad
  item.addEventListener('touchstart',e=>{
    const d=item.dataset;
    structDrag=null;
    furnDrag={type:'palette',item:{type:d.type,label:d.label,color:d.color,w:parseFloat(d.w),h:parseFloat(d.h),rotation:0},ghostX:null,ghostY:null};
    e.preventDefault();
  },{passive:false});
  item.addEventListener('touchmove',e=>{
    if(!furnDrag||furnDrag.type!=='palette') return;
    e.preventDefault();
    const t=e.touches[0];
    const cr=canvas.getBoundingClientRect();
    furnDrag.ghostX=t.clientX-cr.left;
    furnDrag.ghostY=t.clientY-cr.top;
    draw();
  },{passive:false});
  item.addEventListener('touchend',e=>{
    if(!furnDrag||furnDrag.type!=='palette') return;
    e.preventDefault();
    const t=e.changedTouches[0];
    const cr=canvas.getBoundingClientRect();
    const mx=t.clientX-cr.left, my=t.clientY-cr.top;
    // only place if touch ended over canvas
    if(mx>=0&&my>=0&&mx<=canvas.width&&my<=canvas.height){
      const {ox,oy}=offset();
      furniture[curFloor].push({...furnDrag.item,id:nid++,
        x:(mx-ox)/SCALE-furnDrag.item.w/2,
        y:(my-oy)/SCALE-furnDrag.item.h/2});
      selFurnId=furniture[curFloor][furniture[curFloor].length-1].id;
    }
    furnDrag=null; draw();
  },{passive:false});
});
wrap.addEventListener('dragover',e=>{
  e.preventDefault();
  const rc=canvas.getBoundingClientRect();
  if(winDrag&&winDrag.type==='palette'){
    winDrag.ghostX=e.clientX-rc.left; winDrag.ghostY=e.clientY-rc.top; draw();
  } else if(structDrag&&structDrag.type==='palette'){
    structDrag.ghostX=e.clientX-rc.left; structDrag.ghostY=e.clientY-rc.top; draw();
  } else if(furnDrag&&furnDrag.type==='palette'){
    furnDrag.ghostX=e.clientX-rc.left; furnDrag.ghostY=e.clientY-rc.top; draw();
  }
});
wrap.addEventListener('dragleave',()=>{
  if(structDrag&&structDrag.type==='palette'){structDrag.ghostX=null;draw();}
  if(furnDrag&&furnDrag.type==='palette'){furnDrag.ghostX=null;draw();}
});
wrap.addEventListener('drop',e=>{
  e.preventDefault();
  const rc2=canvas.getBoundingClientRect();
  const mx=e.clientX-rc2.left, my=e.clientY-rc2.top;
  const {ox,oy}=offset();
  // Window drop
  if(winDrag&&winDrag.type==='palette'){
    const fl=floors[curFloor];
    const fx=(mx-ox)/SCALE, fy=(my-oy)/SCALE;
    // Snap to nearest wall edge
    const distN=fy, distS=fl.H-fy, distW=fx, distE=fl.W-fx;
    const mn=Math.min(distN,distS,distW,distE);
    let wall='n', wx=fx, wy=fy;
    if(mn===distN){wall='n'; wy=0;}
    else if(mn===distS){wall='s'; wy=fl.H;}
    else if(mn===distW){wall='w'; wx=0;}
    else{wall='e'; wx=fl.W;}
    // Clamp position within floor bounds
    const hw=winDrag.item.w/2;
    if(wall==='n'||wall==='s') wx=Math.max(hw,Math.min(fl.W-hw, wx));
    else wy=Math.max(hw,Math.min(fl.H-hw, wy));
    const nw={...winDrag.item, id:nWinId++, x:wx, y:wy, wall};
    windows[curFloor].push(nw);
    selectWin(nw.id);
    winDrag=null; draw();
    return;
  }
  if(structDrag&&structDrag.type==='palette'){
    const ns={...structDrag.item, id:nStructId++,
      x:snapS(Math.max(0,(mx-ox)/SCALE - structDrag.item.w/2)),
      y:snapS(Math.max(0,(my-oy)/SCALE - structDrag.item.h/2))};
    structEls[curFloor].push(ns);
    selectStruct(ns.id);
    structDrag=null; draw();
    return;
  }
  if(furnDrag&&furnDrag.type==='palette'){
    furniture[curFloor].push({...furnDrag.item,id:nid++,
      x:(mx-ox)/SCALE-furnDrag.item.w/2,
      y:(my-oy)/SCALE-furnDrag.item.h/2});
    selFurnId=furniture[curFloor][furniture[curFloor].length-1].id;
    furnDrag=null; draw();
  }
});

// â”€â”€â”€ FURNITURE ACTIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function rotateFurniture(deg){
  const f=furniture[curFloor].find(f=>f.id===selFurnId);
  if(f){f.rotation=((f.rotation||0)+deg+360)%360;draw();}
}
function deleteSelected(){
  if(!selFurnId) return;
  furniture[curFloor]=furniture[curFloor].filter(f=>f.id!==selFurnId);
  selFurnId=null; draw();
}
function clearAll(){
  if(confirm('ã“ã®ãƒ•ãƒ­ã‚¢ã®å®¶å…·ã‚’ã™ã¹ã¦å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')){furniture[curFloor]=[];selFurnId=null;draw();}
}

// â”€â”€â”€ KEYBOARD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
window.addEventListener('keydown',e=>{
  if(document.activeElement.tagName==='INPUT') return;
  if(appMode==='furniture'){
    if(e.key==='r'||e.key==='R'){
    if(appMode==='edit' && selRoomId) rotateRoom(90);
    else rotateFurniture(90);
  }
    if(e.key==='Delete'||e.key==='Backspace'){
      if(selWinId) deleteWin();
      else if(selStructId) deleteStructEl();
      else deleteSelected();
    }
    const f=furniture[curFloor].find(f=>f.id===selFurnId);
    if(f&&e.key.startsWith('Arrow')){
      e.preventDefault();
      const s=e.shiftKey?.001:.01; // Shift=1mm, normal=1cm
      if(e.key==='ArrowLeft')  f.x=Math.round((f.x-s)*1000)/1000;
      if(e.key==='ArrowRight') f.x=Math.round((f.x+s)*1000)/1000;
      if(e.key==='ArrowUp')    f.y=Math.round((f.y-s)*1000)/1000;
      if(e.key==='ArrowDown')  f.y=Math.round((f.y+s)*1000)/1000;
      syncCoordPanel(f); // keep coord panel in sync
      draw(); e.preventDefault();
    }
  } else {
    // struct selected â†’ move with arrow keys (1cm steps)
    const se=structEls[curFloor].find(s=>s.id===selStructId);
    if(se&&e.key.startsWith('Arrow')){
      const step=e.shiftKey?0.001:0.01;
      if(e.key==='ArrowLeft')  se.x=snapS(se.x-step);
      if(e.key==='ArrowRight') se.x=snapS(se.x+step);
      if(e.key==='ArrowUp')    se.y=snapS(se.y-step);
      if(e.key==='ArrowDown')  se.y=snapS(se.y+step);
      setSlider('ssX','svX',se.x); setSlider('ssY','svY',se.y);
      draw(); e.preventDefault(); return;
    }
    const r=floors[curFloor].rooms.find(r=>r.id===selRoomId);
    if(r&&e.key.startsWith('Arrow')){
      const s=e.shiftKey?.02:.1;
      if(e.key==='ArrowLeft')  r.x-=s;
      if(e.key==='ArrowRight') r.x+=s;
      if(e.key==='ArrowUp')    r.y-=s;
      if(e.key==='ArrowDown')  r.y+=s;
      updateSliders(); renderEditRoomList(); draw(); e.preventDefault();
    }
  }
});


// â”€â”€â”€ FURNITURE STYLE DATA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const COLORS = [
  '#b8d4b8','#8ab8a8','#5c8a7c','#d4b896','#c8906a','#a06040',
  '#d4c0d4','#a888b8','#7858a0','#c8dce8','#6898b8','#3868a0',
  '#e8e0d0','#d0c0a0','#b8a070','#f0d8b8','#e0b880','#c89040',
  '#c0c8d4','#8a9ab0','#586880','#e8c8c8','#d09090','#b06060',
  '#d8e4d0','#a8c898','#78a868','#f0f0d8','#e0d8a8','#c0c080',
  '#ffffff','#e8e4e0','#c8c4c0','#a0a0a0','#606060','#2a2520',
];

const STYLE_VARIANTS = {
  kitchen_l:   ['Lå‹ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼','ã‚¢ã‚¤ãƒ©ãƒ³ãƒ‰é¢¨','ã‚·ãƒ³ãƒ—ãƒ«','æœ¨ç›®'],
  kitchen_i:   ['Iå‹ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼','ã‚·ãƒ³ãƒ—ãƒ«','æœ¨ç›®','ã‚¹ãƒ†ãƒ³ãƒ¬ã‚¹'],
  island:      ['ã‚¢ã‚¤ãƒ©ãƒ³ãƒ‰','ãƒãƒ¼ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼','ä½œæ¥­å°'],
  sofa3:       ['3äººæ›ã‘','ã‚³ãƒ¼ãƒŠãƒ¼ã‚½ãƒ•ã‚¡','Lã‚·ã‚§ã‚¤ãƒ—'],
  sofa_l:      ['NE','NW','SE','SW'],  // L corner direction
  sofa1:       ['1äººæ›ã‘','ãƒ©ã‚¦ãƒ³ãƒ‰ãƒã‚§ã‚¢','ã‚ªãƒƒãƒˆãƒãƒ³'],
  table_low:   ['é•·æ–¹å½¢','ä¸¸ãƒ†ãƒ¼ãƒ–ãƒ«','æ­£æ–¹å½¢','ã‚¬ãƒ©ã‚¹å¤©æ¿'],
  dining4:     ['é•·æ–¹å½¢4äºº','ä¸¸ãƒ†ãƒ¼ãƒ–ãƒ«','æ­£æ–¹å½¢'],
  dining2:     ['é•·æ–¹å½¢2äºº','ä¸¸ãƒ†ãƒ¼ãƒ–ãƒ«','ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼'],
  folding_s:   ['åç´','å±•é–‹'],
  folding_m:   ['åç´','å±•é–‹'],
  folding_l:   ['åç´','å±•é–‹'],
  bed_double:  ['ãƒ€ãƒ–ãƒ«','ãƒ¯ã‚¤ãƒ‰ã‚­ãƒ³ã‚°','ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ '],
  bed_single:  ['ã‚·ãƒ³ã‚°ãƒ«','ã‚»ãƒŸãƒ€ãƒ–ãƒ«','ç•³ãƒ™ãƒƒãƒ‰'],
  desk:        ['ãƒ¯ãƒ¼ã‚¯ãƒ‡ã‚¹ã‚¯','Lå­—ãƒ‡ã‚¹ã‚¯','ã‚³ãƒ¼ãƒŠãƒ¼ãƒ‡ã‚¹ã‚¯'],
  wardrobe:    ['å¼•ãæˆ¸','è¦³éŸ³æ‰‰','ã‚ªãƒ¼ãƒ—ãƒ³ãƒ©ãƒƒã‚¯'],
  tv:          ['ãƒ†ãƒ¬ãƒ“å°','ãƒ†ãƒ¬ãƒ“ãƒœãƒ¼ãƒ‰','å£æ›ã‘é¢¨'],
  fridge:      ['å†·è”µåº«','å¤§å‹å†·è”µåº«'],
  bath:        ['ãƒã‚¹ã‚¿ãƒ–','ä¸¸å½¢ãƒã‚¹','ã‚·ãƒ£ãƒ¯ãƒ¼å®¤'],
  toilet:      ['ãƒˆã‚¤ãƒ¬','ã‚¿ãƒ³ã‚¯ãƒ¬ã‚¹'],
  washing:     ['æ´—æ¿¯æ©Ÿ','ä¹¾ç‡¥æ©Ÿ'],
  plant:       ['è¦³è‘‰æ¤ç‰©','ãƒ•ã‚£ã‚«ã‚¹','ã‚µãƒœãƒ†ãƒ³'],
  chair:       ['ãƒ€ã‚¤ãƒ‹ãƒ³ã‚°ãƒã‚§ã‚¢','ã‚¹ãƒªãƒ ','ã‚¦ãƒƒãƒ‰','ãƒ¡ã‚¿ãƒ«'],
  chair_arm:   ['ã‚¢ãƒ¼ãƒ ãƒã‚§ã‚¢','ã‚¤ãƒ¼ãƒ ã‚ºé¢¨','ãƒãƒ¬ãƒ«ãƒã‚§ã‚¢'],
  chair_stool: ['ã‚¹ãƒ„ãƒ¼ãƒ«','ãƒãƒ¼ã‚¹ãƒ„ãƒ¼ãƒ«','ä¸¸ã‚¹ãƒ„ãƒ¼ãƒ«'],
};

function buildStylePanel(f) {
  const panel = document.getElementById('stylePanel');
  if(!f){ panel.style.display='none'; return; }
  panel.style.display='block';

  // Color swatches
  const cg = document.getElementById('colorGrid');
  cg.innerHTML='';
  COLORS.forEach(c=>{
    const sw=document.createElement('div');
    sw.className='color-swatch'+(f.color===c?' active':'');
    sw.style.background=c;
    sw.title=c;
    sw.onclick=()=>{ f.color=c; buildStylePanel(f); draw(); };
    cg.appendChild(sw);
  });

  // Style chips
  const sc = document.getElementById('styleChips');
  sc.innerHTML='';
  const variants = STYLE_VARIANTS[f.type]||[];
  variants.forEach(v=>{
    const chip=document.createElement('div');
    chip.className='style-chip'+((f.styleVariant||variants[0])===v?' active':'');
    chip.textContent=v;
    chip.onclick=()=>{ f.styleVariant=v; f.st=v; buildStylePanel(f); draw(); };
    sc.appendChild(chip);
  });

  // Size sliders: round table vs normal
  const isRoundTbl = f.styleVariant==='ä¸¸ãƒ†ãƒ¼ãƒ–ãƒ«' || f.st==='ä¸¸ãƒ†ãƒ¼ãƒ–ãƒ«';
  const sizeNEl = document.getElementById('sizeNormal');
  const sizeDEl = document.getElementById('sizeDiameter');
  if(sizeNEl) sizeNEl.style.display = isRoundTbl ? 'none' : 'block';
  if(sizeDEl) sizeDEl.style.display = isRoundTbl ? 'block' : 'none';
  if(isRoundTbl){
    const d = Math.min(f.w, f.h);
    const slD = document.getElementById('fslD');
    if(slD){ slD.value=d; document.getElementById('fvalD').textContent=Math.round(d*100)+'cm'; }
  } else {
    document.getElementById('fslW').value=f.w;
    document.getElementById('fvalW').textContent=f.w.toFixed(2)+'m';
    document.getElementById('fslH').value=f.h;
    document.getElementById('fvalH').textContent=f.h.toFixed(2)+'m';
  }
  // Rotation slider sync
  const rot = ((f.rotation||0)%360+360)%360;
  const slR = document.getElementById('fslR');
  if(slR){ slR.value=Math.round(rot/5)*5; document.getElementById('fvalR').textContent=Math.round(rot)+'Â°'; }
}

function onFurnSize(prop, val){
  const f=furniture[curFloor].find(f=>f.id===selFurnId); if(!f) return;
  f[prop]=parseFloat(val);
  document.getElementById('fval'+prop.toUpperCase()).textContent=parseFloat(val).toFixed(2)+'m';
  draw();
}

function setExpandDir(dir){
  const f=furniture[curFloor].find(f=>f.id===selFurnId); if(!f) return;
  f.expandDir=dir;
  ['up','down','left','right'].forEach(d=>{
    const btn=document.getElementById('foldDir_'+d);
    if(btn) btn.classList.toggle('active', d===dir);
  });
  draw();
}

function toggleSelectedFolding(){
  const f=furniture[curFloor].find(f=>f.id===selFurnId); if(!f) return;
  toggleFoldingTable(f);
}

function setLSofaCorner(corner){
  const f=furniture[curFloor].find(f=>f.id===selFurnId); if(!f) return;
  f.styleVariant=corner; f.st=corner;
  ['NW','NE','SW','SE'].forEach(d=>{
    const btn=document.getElementById('lc_'+d);
    if(btn) btn.classList.toggle('active', d===corner);
  });
  draw();
}

function onFurnDiameter(val){
  const f=furniture[curFloor].find(f=>f.id===selFurnId); if(!f) return;
  const d=parseFloat(val);
  f.w=d; f.h=d;
  document.getElementById('fvalD').textContent=Math.round(d*100)+'cm';
  draw();
}

function onFurnRotation(val){
  const f=furniture[curFloor].find(f=>f.id===selFurnId); if(!f) return;
  f.rotation=parseFloat(val);
  document.getElementById('fvalR').textContent=parseFloat(val)+'Â°';
  draw();
}

function setFurnRotation(deg){
  const f=furniture[curFloor].find(f=>f.id===selFurnId); if(!f) return;
  f.rotation=deg;
  document.getElementById('fslR').value=deg;
  document.getElementById('fvalR').textContent=deg+'Â°';
  draw();
}

// â”€â”€â”€ COORDINATE PANEL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function syncCoordPanel(f){
  if(!f){ document.getElementById('coordPanel').style.display='none'; return; }
  document.getElementById('coordPanel').style.display='block';
  const isRound = f.styleVariant==='ä¸¸ãƒ†ãƒ¼ãƒ–ãƒ«'||f.st==='ä¸¸ãƒ†ãƒ¼ãƒ–ãƒ«';
  // show/hide W/H vs diameter
  document.getElementById('coordW_row').style.display = isRound ? 'none' : 'flex';
  document.getElementById('coordH_row').style.display = isRound ? 'none' : 'flex';
  document.getElementById('coordD_row').style.display = isRound ? 'flex' : 'none';
  // set values (X/Y = top-left corner position, display in cm)
  document.getElementById('cinX').value = Math.round(f.x * 100) / 100;
  document.getElementById('cinY').value = Math.round(f.y * 100) / 100;
  if(isRound){
    document.getElementById('cinD').value = Math.round(Math.min(f.w,f.h)*100)/100;
  } else {
    document.getElementById('cinW').value = Math.round(f.w*100)/100;
    document.getElementById('cinH').value = Math.round(f.h*100)/100;
  }
  document.getElementById('cinR').value = Math.round(((f.rotation||0)%360+360)%360);
}

function onCoordInput(prop, val){
  const f=furniture[curFloor].find(f=>f.id===selFurnId); if(!f) return;
  const v = parseFloat(val);
  if(isNaN(v) || val==='' || val==='-') return;
  if(prop==='rotation'){
    f.rotation = ((v%360)+360)%360;
    // sync rotation slider too
    const slR=document.getElementById('fslR');
    if(slR){ slR.value=Math.round(f.rotation/5)*5; document.getElementById('fvalR').textContent=Math.round(f.rotation)+'Â°'; }
  } else {
    f[prop] = Math.max(prop==='x'||prop==='y' ? -1 : 0.05, v);
    // sync size sliders
    if(prop==='w'){ const s=document.getElementById('fslW'); if(s){s.value=f.w; document.getElementById('fvalW').textContent=f.w.toFixed(2)+'m';} }
    if(prop==='h'){ const s=document.getElementById('fslH'); if(s){s.value=f.h; document.getElementById('fvalH').textContent=f.h.toFixed(2)+'m';} }
  }
  draw();
}

function onCoordInputDiam(val){
  const f=furniture[curFloor].find(f=>f.id===selFurnId); if(!f) return;
  const v=Math.max(0.1,parseFloat(val)||0.1);
  f.w=v; f.h=v;
  const slD=document.getElementById('fslD');
  if(slD){ slD.value=v; document.getElementById('fvalD').textContent=Math.round(v*100)+'cm'; }
  draw();
}

function nudgeFurn(prop, delta){
  const f=furniture[curFloor].find(f=>f.id===selFurnId); if(!f) return;
  if(prop==='rotation'){
    f.rotation=((((f.rotation||0)+delta)%360)+360)%360;
    document.getElementById('cinR').value=Math.round(f.rotation);
    const slR=document.getElementById('fslR');
    if(slR){ slR.value=Math.round(f.rotation/5)*5; document.getElementById('fvalR').textContent=Math.round(f.rotation)+'Â°'; }
  } else {
    f[prop]=Math.max(prop==='x'||prop==='y' ? -1 : 0.05, (f[prop]||0)+delta);
    f[prop]=Math.round(f[prop]*1000)/1000; // 1mm precision
    const input=document.getElementById('cin'+prop.charAt(0).toUpperCase()+prop.slice(1));
    if(input) input.value=Math.round(f[prop]*100)/100;
    if(prop==='w'){ const s=document.getElementById('fslW'); if(s){s.value=f.w; document.getElementById('fvalW').textContent=f.w.toFixed(2)+'m';} }
    if(prop==='h'){ const s=document.getElementById('fslH'); if(s){s.value=f.h; document.getElementById('fvalH').textContent=f.h.toFixed(2)+'m';} }
  }
  draw();
}

function nudgeFurnDiam(delta){
  const f=furniture[curFloor].find(f=>f.id===selFurnId); if(!f) return;
  const d=Math.max(0.1, Math.round((Math.min(f.w,f.h)+delta)*1000)/1000);
  f.w=d; f.h=d;
  document.getElementById('cinD').value=Math.round(d*100)/100;
  const slD=document.getElementById('fslD');
  if(slD){ slD.value=d; document.getElementById('fvalD').textContent=Math.round(d*100)+'cm'; }
  draw();
}


// â”€â”€â”€ RIGHT PANEL UI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateUI(){
  document.getElementById('furnitureCount').textContent=furniture[curFloor].length;
  const info=document.getElementById('selectedInfo');
  const rr=document.getElementById('rotateRow');
  if(appMode==='furniture'){
    const f=furniture[curFloor].find(f=>f.id===selFurnId);
    if(f){
      info.innerHTML=`<b>${f.label}</b><br><span style="font-family:'DM Mono',monospace;font-size:10px;color:var(--muted)">${f.w.toFixed(2)}mÃ—${f.h.toFixed(2)}m  ${f.rotation||0}Â°</span>`;
      rr.style.display='flex';
      buildStylePanel(f);
    } else {
      info.innerHTML='<span style="color:var(--muted);font-size:11px;">å®¶å…·ã‚’é¸æŠã—ã¦ãã ã•ã„</span>';
      rr.style.display='none';
      buildStylePanel(null);
    }
  } else {
    const r=floors[curFloor].rooms.find(r=>r.id===selRoomId);
    if(r){
      info.innerHTML=`<b>${r.name.replace('\n',' ')}</b><br><span style="font-family:'DM Mono',monospace;font-size:10px;color:var(--muted)">X:${r.x.toFixed(2)} Y:${r.y.toFixed(2)}<br>W:${r.w.toFixed(2)} H:${r.h.toFixed(2)}</span>`;
    } else {
      info.innerHTML='<span style="color:var(--muted);font-size:11px;">éƒ¨å±‹ã‚’é¸æŠã—ã¦ãã ã•ã„</span>';
    }
    rr.style.display='none';
  }
}

function renderLegend(){
  const leg=document.getElementById('roomLegend'); leg.innerHTML='';
  floors[curFloor].rooms.slice(0,6).forEach(r=>{
    const row=document.createElement('div'); row.className='legend-row';
    row.innerHTML=`<div class="legend-dot" style="background:${r.color}"></div><span style="font-size:10px;color:var(--muted)">${r.name.split('\n')[0]}</span>`;
    leg.appendChild(row);
  });
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 3D ENGINE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let threeRenderer=null, threeScene=null, threeCamera=null;
let threeAnimId=null;
let orbitState={isDragging:false,isRight:false,lastX:0,lastY:0,theta:0.55,phi:0.72,radius:16,tx:0,ty:0};

function hexToThree(hex){
  const r=parseInt(hex.slice(1,3),16)/255;
  const g=parseInt(hex.slice(3,5),16)/255;
  const b=parseInt(hex.slice(5,7),16)/255;
  return new THREE.Color(r,g,b);
}

function cssColorToThree(css){
  // handle hex
  if(css&&css.startsWith('#')) return hexToThree(css);
  return new THREE.Color(0xd0c8b8);
}

function init3D(){
  const container = document.getElementById('threeContainer');
  const W = container.clientWidth, H = container.clientHeight;

  // Renderer
  if(!threeRenderer){
    threeRenderer = new THREE.WebGLRenderer({antialias:true});
    threeRenderer.shadowMap.enabled = true;
    threeRenderer.shadowMap.type = THREE.PCFSoftShadowMap;
    threeRenderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(threeRenderer.domElement);
    threeRenderer.domElement.style.width='100%';
    threeRenderer.domElement.style.height='100%';
    setup3DControls(threeRenderer.domElement);
  }
  threeRenderer.setSize(W, H);

  // Camera
  threeCamera = new THREE.PerspectiveCamera(55, W/H, 0.1, 200);
  updateCamera3D();

  // Scene
  buildScene3D();
  animate3D();
}

function buildScene3D(){
  wallMaterials3D = [];  // reset
  threeScene = new THREE.Scene();
  threeScene.background = new THREE.Color(0x18201a);

  // Lights â€” brighter so transparent walls look good
  const ambient = new THREE.AmbientLight(0xfff8f0, 1.0);
  threeScene.add(ambient);

  const sun = new THREE.DirectionalLight(0xfff5e0, 1.4);
  sun.position.set(10, 18, 8);
  sun.castShadow = true;
  sun.shadow.mapSize.set(2048,2048);
  sun.shadow.camera.near=0.5; sun.shadow.camera.far=80;
  sun.shadow.camera.left=-25; sun.shadow.camera.right=25;
  sun.shadow.camera.top=25;   sun.shadow.camera.bottom=-25;
  threeScene.add(sun);

  const fill = new THREE.DirectionalLight(0xd0e8ff, 0.5);
  fill.position.set(-8, 8, -6);
  threeScene.add(fill);

  const back = new THREE.DirectionalLight(0xffe8d0, 0.3);
  back.position.set(0, 4, -12);
  threeScene.add(back);

  const fl = floors[curFloor];
  const WALL_H = 2.8;
  const S = 1.0;

  // Ground / base plate
  const groundGeo = new THREE.PlaneGeometry(fl.W*S+6, fl.H*S+6);
  const groundMat = new THREE.MeshLambertMaterial({color:0x1e2820});
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI/2;
  ground.position.set(fl.W*S/2, -0.02, fl.H*S/2);
  ground.receiveShadow = true;
  threeScene.add(ground);

  // Walls: highly transparent so interior is always visible from any angle
  const WALL_OPACITY = 0.13;
  // wallMat is now created per-room â€” see below
  // Shared default for outer walls
  const defaultWallColor = new THREE.Color(0xf0ede8);

  // Outer wall â€” slightly more visible but still very transparent
  const outerWallMat = new THREE.MeshPhongMaterial({
    color: 0xd8d0c4,
    transparent: true,
    opacity: 0.18,
    side: THREE.DoubleSide,
    depthWrite: false,
    shininess: 40,
  });

  // Ceiling â€” almost invisible, just a faint plane
  const ceilMat = new THREE.MeshPhongMaterial({
    color: 0xfaf8f4,
    transparent: true,
    opacity: 0.06,
    side: THREE.DoubleSide,
    depthWrite: false,
  });

  // Edge lines: brighter so walls are outlined even when very transparent
  const edgeMat = new THREE.LineBasicMaterial({color: 0xd8c8b0, transparent:true, opacity:0.7});

  const WALL_THK = 0.08;

  fl.rooms.forEach(room=>{
    const rx=room.x*S, rz=room.y*S, rw=room.w*S, rd=room.h*S;
    const cx=rx+rw/2, cz=rz+rd/2;

    // Floor slab
    const floorColor = cssColorToThree(room.color);
    floorColor.multiplyScalar(0.88);
    const floorMat = new THREE.MeshLambertMaterial({color:floorColor});
    const floorMesh = new THREE.Mesh(new THREE.BoxGeometry(rw-0.04,0.08,rd-0.04), floorMat);
    floorMesh.position.set(cx, 0.04, cz);
    floorMesh.receiveShadow = true;
    threeScene.add(floorMesh);

    // Room label
    addRoomLabel(room.name.replace('\n',' '), cx, 0.2, cz);

    // 4 walls â€” per-room material with optional wallColor from photo
    const roomWallColor = room.wallColor
      ? cssColorToThree(room.wallColor)
      : defaultWallColor.clone();
    // Rooms with a photo color get slightly higher opacity so color is visible
    const roomWallOpacity = room.wallColor ? Math.max(WALL_OPACITY, 0.38) : WALL_OPACITY;
    const wallMat = new THREE.MeshPhongMaterial({
      color: roomWallColor,
      transparent: true,
      opacity: roomWallOpacity,
      side: THREE.DoubleSide,
      depthWrite: false,
      shininess: room.wallFinish==='gloss' ? 120 : room.wallFinish==='semi-gloss' ? 60 : 20,
      specular: new THREE.Color(room.wallColor ? 0xffffff : 0x444444),
    });
    // Left
    addWallPlane(threeScene, wallMat, edgeMat, rx, WALL_H/2, cz,  WALL_THK, WALL_H, rd, 0);
    // Right
    addWallPlane(threeScene, wallMat, edgeMat, rx+rw, WALL_H/2, cz,  WALL_THK, WALL_H, rd, 0);
    // Front (z-)
    addWallPlane(threeScene, wallMat, edgeMat, cx, WALL_H/2, rz,  rw, WALL_H, WALL_THK, 1);
    // Back  (z+)
    addWallPlane(threeScene, wallMat, edgeMat, cx, WALL_H/2, rz+rd, rw, WALL_H, WALL_THK, 1);
    if(room.wallColor) wallMat._hasPhotoColor = true;
    wallMaterials3D.push(wallMat);

    // Ceiling plane
    const ceilMesh = new THREE.Mesh(new THREE.PlaneGeometry(rw, rd), ceilMat);
    ceilMesh.rotation.x = -Math.PI/2;
    ceilMesh.position.set(cx, WALL_H, cz);
    threeScene.add(ceilMesh);

    // Stair
    if(room.stair) drawStairMesh(threeScene, rx, rz, rw, rd, S);
  });

  // Outer boundary walls (thicker, slightly more opaque)
  const outerH = WALL_H + 0.05;
  const OWT = 0.16;
  [
    [fl.W*S/2, outerH/2, 0,        fl.W*S, outerH, OWT],
    [fl.W*S/2, outerH/2, fl.H*S,   fl.W*S, outerH, OWT],
    [0,        outerH/2, fl.H*S/2, OWT, outerH, fl.H*S],
    [fl.W*S,   outerH/2, fl.H*S/2, OWT, outerH, fl.H*S],
  ].forEach(([x,y,z,w,h,d])=>{
    wallMaterials3D.push(outerWallMat);
  const mesh = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), outerWallMat);
    mesh.position.set(x,y,z);
    threeScene.add(mesh);
    // Edge lines
    const edges = new THREE.EdgesGeometry(new THREE.BoxGeometry(w,h,d));
    const line  = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({color:0x8a8070,transparent:true,opacity:0.6}));
    line.position.set(x,y,z);
    threeScene.add(line);
  });

  // Structural elements in 3D
  structEls[curFloor].forEach(s=>{
    const sm = new THREE.MeshPhongMaterial({color:0x3a3028, shininess:20});
    const sg = new THREE.BoxGeometry(s.w*S, WALL_H, s.h*S);
    const mesh = new THREE.Mesh(sg, sm);
    mesh.position.set((s.x+s.w/2)*S, WALL_H/2, (s.y+s.h/2)*S);
    mesh.castShadow=true; mesh.receiveShadow=true;
    threeScene.add(mesh);
  });

  // Furniture
  furniture[curFloor].forEach(f=>{
    add3DFurniture(f, S, WALL_H);
  });
}

// Translucent wall: thin box + edge lines
function addWallPlane(scene, mat, edgeMat, x, y, z, w, h, d, axis){
  const geo = new THREE.BoxGeometry(w, h, d);
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.set(x,y,z);
  scene.add(mesh);
  // Edge highlight
  const edges = new THREE.EdgesGeometry(geo);
  const line  = new THREE.LineSegments(edges, edgeMat);
  line.position.set(x,y,z);
  scene.add(line);
}

function buildWall(scene, mat, x, y, z, w, h, d, side){
  const geo = new THREE.BoxGeometry(w, h, d);
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.set(x, y+h/2, z);
  mesh.castShadow=true; mesh.receiveShadow=true;
  scene.add(mesh);
}

function drawStairMesh(scene, rx, rz, rw, rd, S){
  const steps = 10;
  const stepH = 2.8/steps;
  const stepD = rd/steps;
  const stairMat = new THREE.MeshLambertMaterial({color:0xc8b89a});
  for(let i=0;i<steps;i++){
    const geo = new THREE.BoxGeometry(rw*0.9, stepH*(i+1), stepD*0.9);
    const mesh = new THREE.Mesh(geo, stairMat);
    mesh.position.set(rx+rw/2, stepH*(i+1)/2, rz+stepD*(i+0.5));
    mesh.castShadow=true; mesh.receiveShadow=true;
    scene.add(mesh);
  }
}

function add3DFurniture(f, S, WALL_H){
  const fc = cssColorToThree(f.color||'#d0c8b8');
  // Use AI accent color for legs/frame if available
  const ac = f.accentColor ? cssColorToThree(f.accentColor) : fc.clone().multiplyScalar(0.65);
  const mat = new THREE.MeshLambertMaterial({color:fc});
  const darkMat = new THREE.MeshLambertMaterial({color:ac});
  const lightMat = new THREE.MeshLambertMaterial({color:0xfafafa});
  // Upgrade to Phong for wood/marble materials (shinier)
  if(f.aiMaterial==='marble'){
    mat.color = cssColorToThree(f.color||'#e8e4e0');
  }
  const cx = (f.x + f.w/2)*S;
  const cz = (f.y + f.h/2)*S;
  const fw = f.w*S, fd = f.h*S;
  const rot = (f.rotation||0)*Math.PI/180;

  const group = new THREE.Group();
  group.position.set(cx,0,cz);
  group.rotation.y = -rot;

  const type = f.type;

  if(type==='sofa3'||type==='sofa1'){
    const n = type==='sofa3'?3:1;
    // Base
    addBox(group,mat,0,0.22,0, fw,0.44,fd);
    // Back
    addBox(group,darkMat,0,0.55,-fd/2+0.1, fw,0.6,0.18);
    // Arms
    addBox(group,darkMat,-fw/2+0.08,0.44,0, 0.14,0.52,fd);
    addBox(group,darkMat, fw/2-0.08,0.44,0, 0.14,0.52,fd);
    // Cushions
    const csW=(fw-0.32)/n;
    for(let i=0;i<n;i++){
      const cx2=-fw/2+0.16+csW*(i+0.5);
      addBox(group,lightMat,cx2,0.5,0.04, csW-0.06,0.14,fd-0.22);
    }

  }else if(type==='table_low'){
    addBox(group,mat,0,0.2,0, fw,0.06,fd);
    // legs
    [[-1,-1],[1,-1],[1,1],[-1,1]].forEach(([sx,sz])=>{
      addBox(group,darkMat,sx*(fw/2-0.06),0.1,sz*(fd/2-0.06), 0.06,0.2,0.06);
    });

  }else if(type==='dining4'||type==='dining2'){
    // table
    addBox(group,mat,0,0.38,0, fw,0.05,fd);
    addBox(group,darkMat,0,0.2,0, 0.08,0.38,0.08);
    // chairs
    const seats=type==='dining4'?4:2;
    const cpos=type==='dining4'
      ?[[-fw/2-0.2,0,0],[fw/2+0.2,0,0],[0,0,-fd/2-0.2],[0,0,fd/2+0.2]]
      :[[0,0,-fd/2-0.2],[0,0,fd/2+0.2]];
    cpos.slice(0,seats).forEach(([cx2,cy2,cz2])=>{
      const chairG=new THREE.Group();
      addBox(chairG,mat,0,0.22,0, 0.42,0.04,0.42);
      addBox(chairG,darkMat,0,0.44,-0.19, 0.42,0.44,0.06);
      [[-0.16,0,-0.16],[0.16,0,-0.16],[0.16,0,0.16],[-0.16,0,0.16]].forEach(([lx,ly,lz])=>addBox(chairG,darkMat,lx,0.11,lz,0.04,0.22,0.04));
      chairG.position.set(cx2,0,cz2);
      if(Math.abs(cz2)>0.1) chairG.rotation.y=cz2>0?Math.PI:0;
      else chairG.rotation.y=cx2>0?Math.PI/2:-Math.PI/2;
      group.add(chairG);
    });

  }else if(type==='bed_double'||type==='bed_single'){
    // frame
    addBox(group,mat,0,0.12,0, fw,0.24,fd);
    // mattress
    const mattMat=new THREE.MeshLambertMaterial({color:0xf0ecf0});
    addBox(group,mattMat,0,0.3,0, fw-0.1,0.16,fd-0.1);
    // pillow(s)
    const pillMat=new THREE.MeshLambertMaterial({color:0xffffff});
    if(type==='bed_double'){
      addBox(group,pillMat,-fw*0.18,0.4,-fd/2+0.25, fw*0.34,0.08,0.24);
      addBox(group,pillMat, fw*0.18,0.4,-fd/2+0.25, fw*0.34,0.08,0.24);
    }else{
      addBox(group,pillMat,0,0.4,-fd/2+0.25, fw*0.55,0.08,0.24);
    }
    // blanket
    const blankMat=new THREE.MeshLambertMaterial({color:cssColorToThree(f.color||'#d4c0d4').multiplyScalar(0.8)});
    addBox(group,blankMat,0,0.4,fd*0.1, fw-0.12,0.07,fd*0.6);
    // headboard
    addBox(group,darkMat,0,0.55,-fd/2+0.06, fw,0.52,0.1);

  }else if(type==='kitchen_l'||type==='kitchen_i'||type==='island'){
    // counter body
    addBox(group,mat,0,0.45,0, fw,0.9,fd);
    // countertop (lighter)
    const topMat=new THREE.MeshLambertMaterial({color:0xf0ede8});
    addBox(group,topMat,0,0.91,0, fw+0.02,0.06,fd+0.02);
    // sink
    const sinkMat=new THREE.MeshLambertMaterial({color:0xd0d8e0});
    addBox(group,sinkMat,-fw*0.22,0.95,0, fw*0.28,0.06,fd*0.55);
    // burners
    const burnMat=new THREE.MeshLambertMaterial({color:0x555555});
    [0.15,-0.15].forEach(oz=>{
      const burnGeo=new THREE.CylinderGeometry(fd*0.15,fd*0.15,0.03,16);
      const burn=new THREE.Mesh(burnGeo,burnMat);
      burn.position.set(fw*0.2,0.95,oz*fd);
      group.add(burn);
    });

  }else if(type==='tv'){
    // stand
    addBox(group,darkMat,0,0.08,0, fw*0.3,0.16,fd);
    // screen
    const scrMat=new THREE.MeshLambertMaterial({color:0x111111});
    addBox(group,scrMat,0,0.5,0, fw,0.7,0.06);
    const glowMat=new THREE.MeshLambertMaterial({color:0x334466,emissive:new THREE.Color(0x112244),emissiveIntensity:0.4});
    addBox(group,glowMat,0,0.5,0.04, fw-0.06,0.62,0.01);

  }else if(type==='desk'){
    addBox(group,mat,0,0.38,0, fw,0.04,fd);
    [[-1,-1],[1,-1],[1,1],[-1,1]].forEach(([sx,sz])=>addBox(group,darkMat,sx*(fw/2-0.05),0.19,sz*(fd/2-0.05),0.06,0.38,0.06));

  }else if(type==='wardrobe'){
    addBox(group,mat,0,1.0,0, fw,2.0,fd);
    // doors
    addBox(group,darkMat,-fw*0.25,1.0,fd/2+0.01, fw*0.48,1.9,0.03);
    addBox(group,darkMat, fw*0.25,1.0,fd/2+0.01, fw*0.48,1.9,0.03);
    // handles
    addBox(group,new THREE.MeshLambertMaterial({color:0xaaaaaa}),-fw*0.02,1.0,fd/2+0.05,0.03,0.15,0.03);
    addBox(group,new THREE.MeshLambertMaterial({color:0xaaaaaa}), fw*0.02,1.0,fd/2+0.05,0.03,0.15,0.03);

  }else if(type==='fridge'){
    addBox(group,mat,0,0.9,0, fw,1.8,fd);
    addBox(group,darkMat,0,1.6,fd/2+0.01, fw*0.9,0.72,0.03);
    addBox(group,darkMat,0,0.5,fd/2+0.01, fw*0.9,0.56,0.03);
    addBox(group,new THREE.MeshLambertMaterial({color:0xaaaaaa}),fw*0.35,1.6,fd/2+0.06,0.03,0.2,0.03);

  }else if(type==='bath'){
    // tub outer
    addBox(group,mat,0,0.3,0, fw,0.6,fd);
    // tub inner (darker, inset)
    const innerMat=new THREE.MeshLambertMaterial({color:cssColorToThree(f.color||'#b8d8ec').multiplyScalar(1.2)});
    addBox(group,innerMat,0,0.38,0, fw-0.12,0.25,fd-0.12);
    // faucet
    addBox(group,new THREE.MeshLambertMaterial({color:0xcccccc}),fw*0.3,0.62,0, 0.04,0.18,0.04);

  }else if(type==='toilet'){
    // base
    addBox(group,mat,0,0.2,fd*0.1, fw*0.7,0.4,fd*0.65);
    // tank
    addBox(group,mat,0,0.52,-fd*0.35, fw*0.65,0.3,fd*0.25);
    // seat
    const seatMat=new THREE.MeshLambertMaterial({color:0xffffff});
    addBox(group,seatMat,0,0.42,fd*0.08, fw*0.66,0.04,fd*0.62);

  }else if(type==='plant'){
    // pot
    const potMat=new THREE.MeshLambertMaterial({color:0xc87840});
    const potGeo=new THREE.CylinderGeometry(fw*0.3,fw*0.22,0.3,12);
    const pot=new THREE.Mesh(potGeo,potMat);
    pot.position.set(0,0.15,0);
    group.add(pot);
    // leaves (stacked spheres)
    const leafMat=new THREE.MeshLambertMaterial({color:0x4a9a48});
    [[0,0.65,0,fw*0.38],[fw*0.18,0.5,fd*0.18,fw*0.25],[-fw*0.15,0.55,-fd*0.12,fw*0.22]].forEach(([lx,ly,lz,lr])=>{
      const geo=new THREE.SphereGeometry(lr,8,6);
      const m=new THREE.Mesh(geo,leafMat);
      m.position.set(lx,ly,lz);
      m.castShadow=true;
      group.add(m);
    });

  }else if(type==='washing'){
    addBox(group,mat,0,0.45,0, fw,0.9,fd);
    const doorMat=new THREE.MeshLambertMaterial({color:0xd0dce8});
    const doorGeo=new THREE.CylinderGeometry(fw*0.32,fw*0.32,0.05,20);
    const door=new THREE.Mesh(doorGeo,doorMat);
    door.rotation.x=Math.PI/2;
    door.position.set(0,0.72,fd/2+0.03);
    group.add(door);

  }else if(type==='sofa_l'){
    // Lå­—ã‚½ãƒ•ã‚¡ 3D: two box sections forming an L
    const corner = f.styleVariant || f.st || 'NE';
    const arm = Math.min(fw,fd)*0.32;
    const SH = 0.44; // seat height
    const BH = 0.60; // back height
    const BT = 0.18; // back thickness
    const lightMat2 = new THREE.MeshLambertMaterial({color:fc.clone().multiplyScalar(1.2)});

    // Horizontal section (along X axis)
    let hx=0, hz=0, hw2=fw, hd2=arm;
    // Vertical section (along Z axis)
    let vx=0, vz=0, vw2=arm, vd2=fd;

    if(corner==='NE'){ hz=-fd/2+arm/2; vx=fw/2-arm/2; }
    else if(corner==='NW'){ hz=-fd/2+arm/2; vx=-fw/2+arm/2; }
    else if(corner==='SE'){ hz=fd/2-arm/2; vx=fw/2-arm/2; }
    else{ hz=fd/2-arm/2; vx=-fw/2+arm/2; }

    // Seat sections
    addBox(group,mat, hx, SH/2, hz, hw2, SH, hd2);
    addBox(group,mat, vx, SH/2, vz, vw2, SH, vd2);
    // Backs (on the outer edges of each section)
    // Horizontal back
    const hBackZ = (corner==='NE'||corner==='NW') ? hz-hd2/2+BT/2 : hz+hd2/2-BT/2;
    addBox(group,darkMat, hx, SH+BH/2, hBackZ, hw2, BH, BT);
    // Vertical back
    const vBackX = (corner==='NE'||corner==='SE') ? vx+vw2/2-BT/2 : vx-vw2/2+BT/2;
    addBox(group,darkMat, vBackX, SH+BH/2, vz, BT, BH, vd2);
    // Cushions on horizontal section
    const nc = Math.max(1,Math.round(hw2/0.55));
    for(let i=0;i<nc;i++){
      const cx2=-hw2/2+(i+0.5)*hw2/nc;
      addBox(group,lightMat2, cx2, SH+0.08, hz, hw2/nc-0.06, 0.14, hd2-0.16);
    }

  }else if(type==='folding_s'||type==='folding_m'||type==='folding_l'){
    // æŠ˜ã‚ŠãŸãŸã¿ãƒ†ãƒ¼ãƒ–ãƒ« 3D
    const expanded = f.styleVariant==='å±•é–‹';
    const TH = 0.72; // table height
    const TT = 0.04; // top thickness
    if(expanded){
      // Full table: top + 4 legs
      addBox(group,mat,0,TH,0, fw,TT,fd);
      [[-1,-1],[1,-1],[1,1],[-1,1]].forEach(([sx,sz])=>{
        addBox(group,darkMat,sx*(fw/2-0.06),TH/2,sz*(fd/2-0.06), 0.05,TH,0.05);
      });
      // Fold line (thin dark strip)
      addBox(group,darkMat,0,TH+TT/2,0, 0.02,TT+0.01,fd);
    }else{
      // Folded: half-width, legs folded flat (thin profile)
      const hw2=fw/2*0.9;
      addBox(group,mat,0,0.06,0, hw2,0.12,fd);
      // Visible fold crease
      addBox(group,darkMat,hw2/2,0.07,0, 0.01,0.14,fd);
    }

  }else{
    // fallback box
    addBox(group,mat,0,0.2,0, fw,0.4,fd);
  }

  group.traverse(c=>{ if(c.isMesh){c.castShadow=true;c.receiveShadow=true;} });
  threeScene.add(group);
}

function addBox(parent, mat, x, y, z, w, h, d){
  const geo=new THREE.BoxGeometry(w,h,d);
  const mesh=new THREE.Mesh(geo,mat);
  mesh.position.set(x,y,z);
  parent.add(mesh);
  return mesh;
}

function addRoomLabel(text, x, y, z){
  const canvas2=document.createElement('canvas');
  canvas2.width=256; canvas2.height=64;
  const c2=canvas2.getContext('2d');
  c2.fillStyle='rgba(0,0,0,0)'; c2.fillRect(0,0,256,64);
  c2.fillStyle='rgba(42,37,32,0.65)'; c2.roundRect(4,8,248,48,8); c2.fill();
  c2.fillStyle='#f0ece4'; c2.font='bold 18px sans-serif';
  c2.textAlign='center'; c2.textBaseline='middle';
  c2.fillText(text,128,34);
  const tex=new THREE.CanvasTexture(canvas2);
  const spriteMat=new THREE.SpriteMaterial({map:tex,transparent:true,opacity:0.85,depthTest:false});
  const sprite=new THREE.Sprite(spriteMat);
  sprite.position.set(x,y,z);
  sprite.scale.set(2,0.5,1);
  threeScene.add(sprite);
}

function updateCamera3D(){
  if(!threeCamera) return;
  const fl=floors[curFloor];
  const cx=fl.W/2, cz=fl.H/2;
  const {theta,phi,radius,tx,ty}=orbitState;
  threeCamera.position.set(
    cx+tx+radius*Math.sin(phi)*Math.sin(theta),
    ty+radius*Math.cos(phi),
    cz+radius*Math.sin(phi)*Math.cos(theta)
  );
  threeCamera.lookAt(new THREE.Vector3(cx+tx,ty,cz));
}

function animate3D(){
  if(appMode!=='3d') return;
  threeAnimId=requestAnimationFrame(animate3D);
  const container=document.getElementById('threeContainer');
  const W=container.clientWidth, H=container.clientHeight;
  if(threeRenderer.domElement.width!==W||threeRenderer.domElement.height!==H){
    threeRenderer.setSize(W,H);
    threeCamera.aspect=W/H;
    threeCamera.updateProjectionMatrix();
  }
  threeRenderer.render(threeScene,threeCamera);
}

function set3DView(preset){
  if(preset==='top'){
    orbitState.theta=0; orbitState.phi=0.06; orbitState.radius=12; orbitState.tx=0; orbitState.ty=0;
  } else if(preset==='iso'){
    orbitState.theta=0.55; orbitState.phi=0.72; orbitState.radius=14; orbitState.tx=0; orbitState.ty=0;
  } else if(preset==='side'){
    orbitState.theta=Math.PI/2; orbitState.phi=1.2; orbitState.radius=10; orbitState.tx=0; orbitState.ty=1.4;
  } else if(preset==='inside'){
    orbitState.theta=0.2; orbitState.phi=1.45; orbitState.radius=4; orbitState.tx=0; orbitState.ty=1.2;
  }
  updateCamera3D();
}

function stop3D(){
  if(threeAnimId){ cancelAnimationFrame(threeAnimId); threeAnimId=null; }
}

function setup3DControls(el){
  el.addEventListener('mousedown',e=>{
    orbitState.isDragging=true;
    orbitState.isRight=(e.button===2);
    orbitState.lastX=e.clientX;
    orbitState.lastY=e.clientY;
  });
  window.addEventListener('mouseup',()=>orbitState.isDragging=false);
  window.addEventListener('mousemove',e=>{
    if(!orbitState.isDragging||appMode!=='3d') return;
    const dx=e.clientX-orbitState.lastX;
    const dy=e.clientY-orbitState.lastY;
    orbitState.lastX=e.clientX; orbitState.lastY=e.clientY;
    if(orbitState.isRight){
      orbitState.tx-=dx*0.02;
      orbitState.ty+=dy*0.02;
    }else{
      orbitState.theta-=dx*0.008;
      orbitState.phi=Math.max(0.05,Math.min(Math.PI-0.05,orbitState.phi-dy*0.008));
    }
    updateCamera3D();
  });
  el.addEventListener('wheel',e=>{
    if(appMode!=='3d') return;
    orbitState.radius=Math.max(2,Math.min(50,orbitState.radius+e.deltaY*0.025));
    updateCamera3D();
    e.preventDefault();
  },{passive:false});
  el.addEventListener('contextmenu',e=>e.preventDefault());

  // Touch
  let lastTouchDist=0;
  el.addEventListener('touchstart',e=>{
    if(e.touches.length===1){orbitState.isDragging=true;orbitState.lastX=e.touches[0].clientX;orbitState.lastY=e.touches[0].clientY;}
    else if(e.touches.length===2){lastTouchDist=Math.hypot(e.touches[0].clientX-e.touches[1].clientX,e.touches[0].clientY-e.touches[1].clientY);}
  });
  el.addEventListener('touchmove',e=>{
    if(appMode!=='3d') return;
    if(e.touches.length===1&&orbitState.isDragging){
      const dx=e.touches[0].clientX-orbitState.lastX, dy=e.touches[0].clientY-orbitState.lastY;
      orbitState.theta-=dx*0.01; orbitState.phi=Math.max(0.05,Math.min(Math.PI-0.05,orbitState.phi-dy*0.01));
      orbitState.lastX=e.touches[0].clientX; orbitState.lastY=e.touches[0].clientY;
      updateCamera3D();
    }else if(e.touches.length===2){
      const d=Math.hypot(e.touches[0].clientX-e.touches[1].clientX,e.touches[0].clientY-e.touches[1].clientY);
      orbitState.radius=Math.max(2,Math.min(50,orbitState.radius*(lastTouchDist/d)));
      lastTouchDist=d; updateCamera3D();
    }
    e.preventDefault();
  },{passive:false});
  el.addEventListener('touchend',()=>orbitState.isDragging=false);
}

// â”€â”€â”€ AREA DISPLAY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateAreaLabel(){
  const fl = floors[curFloor];
  const area = fl.W * fl.H;
  document.getElementById('floorAreaLabel').textContent = area.toFixed(2) + ' mÂ²';
}

function syncFloorSizeControls(){
  const fl = floors[curFloor];
  const sw = document.getElementById('flW');
  const sh = document.getElementById('flH');
  if(!sw) return;
  sw.value = fl.W; sh.value = fl.H;
  document.getElementById('fvW').textContent = fl.W.toFixed(2) + 'm';
  document.getElementById('fvH').textContent = fl.H.toFixed(2) + 'm';
  document.getElementById('floorSizeDisplay').textContent =
    fl.W.toFixed(2) + ' Ã— ' + fl.H.toFixed(2) + ' m';
}

function onFloorSize(dim, val){
  const fl = floors[curFloor];
  fl[dim] = Math.round(parseFloat(val) * 100) / 100;
  document.getElementById(dim==='W' ? 'fvW' : 'fvH').textContent =
    fl[dim].toFixed(2) + 'm';
  document.getElementById('floorSizeDisplay').textContent =
    fl.W.toFixed(2) + ' Ã— ' + fl.H.toFixed(2) + ' m';
  updateAreaLabel();
  // Clamp rooms to new floor bounds
  floors[curFloor].rooms.forEach(r => {
    r.x = Math.min(r.x, fl.W - r.w);
    r.y = Math.min(r.y, fl.H - r.h);
    r.x = Math.max(0, r.x);
    r.y = Math.max(0, r.y);
  });
  draw();
}

// â”€â”€â”€ INIT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
window.addEventListener('resize', resize);
window.addEventListener('orientationchange', ()=>{ setTimeout(resize, 100); });
if(window.visualViewport){
  window.visualViewport.addEventListener('resize', resize);
}
resize();
renderLegend();
renderEditRoomList();
updateAreaLabel();

// â”€â”€â”€ FOLDING TABLE + L-SOFA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Folding table sizes: [collapsed_w, collapsed_h, expanded_w, expanded_h]
const FOLDING_SIZES = {
  folding_s: { cw:0.60, ch:0.45, ew:1.20, eh:0.75 },
  folding_m: { cw:0.80, ch:0.80, ew:1.60, eh:0.80 },
  folding_l: { cw:0.90, ch:0.90, ew:1.80, eh:0.90 },
};
// expandDir: 'right'|'left'|'up'|'down' â€” which direction table opens
// Default 'right'

function toggleFoldingTable(f){
  const sz = FOLDING_SIZES[f.type];
  if(!sz) return;
  const expanding = f.styleVariant !== 'å±•é–‹';

  // Save current size before toggling so custom sizes are preserved
  if(expanding){
    // Currently collapsed â†’ save collapsed size, will expand
    f._closedW = f.w; f._closedH = f.h;
  } else {
    // Currently expanded â†’ save expanded size, will collapse
    f._openW = f.w; f._openH = f.h;
  }

  f.styleVariant = expanding ? 'å±•é–‹' : 'åç´';
  f.st = f.styleVariant;

  // Determine target sizes (use saved custom sizes if available)
  const targetW = expanding ? (f._openW  || sz.ew) : (f._closedW || sz.cw);
  const targetH = expanding ? (f._openH  || sz.eh) : (f._closedH || sz.ch);

  const dir = f.expandDir || 'right';
  const rot = (f.rotation || 0) * Math.PI / 180;
  const localVec = {
    right: { lx:1, ly:0 }, left:  { lx:-1, ly:0 },
    down:  { lx:0, ly:1 }, up:    { lx:0, ly:-1 },
  }[dir] || { lx:1, ly:0 };

  const cos = Math.cos(rot), sin = Math.sin(rot);
  const worldDx = localVec.lx * cos - localVec.ly * sin;
  const worldDy = localVec.lx * sin + localVec.ly * cos;

  // Size delta from current to target
  const dLen = targetW - f.w;

  if(expanding){
    f.x += worldDx * dLen / 2;
    f.y += worldDy * dLen / 2;
    f.w = targetW; f.h = targetH;
  } else {
    f.x -= worldDx * dLen / 2;
    f.y -= worldDy * dLen / 2;
    f.w = targetW; f.h = targetH;
  }

  // Round to 1mm
  f.x = Math.round(f.x * 1000) / 1000;
  f.y = Math.round(f.y * 1000) / 1000;
  f.w = Math.round(f.w * 1000) / 1000;
  f.h = Math.round(f.h * 1000) / 1000;

  buildStylePanel(f);
  syncCoordPanel(f);
  draw();
}

// L-sofa: get the corner direction from variant
function getLSofaCorner(f){ return f.styleVariant || f.st || 'NE'; }

// â”€â”€â”€ WINDOW SYSTEM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Palette drag setup for win-items
document.querySelectorAll('.win-item').forEach(item=>{
  item.addEventListener('dragstart', e=>{
    furnDrag=null; structDrag=null;
    winDrag={type:'palette', item:{
      wtype: item.dataset.wtype,
      w: parseFloat(item.dataset.ww),
      label: item.dataset.label,
      wall:'auto'
    }};
    e.dataTransfer.effectAllowed='copy';
  });
  item.addEventListener('dragend', ()=>{ winDrag=null; });

  // Touch drag
  item.addEventListener('touchstart', e=>{
    const d = item.dataset;
    furnDrag=null; structDrag=null;
    winDrag={type:'palette', item:{wtype:d.wtype, w:parseFloat(d.ww), label:d.label, wall:'auto'}};
    const touch=e.touches[0];
    winDrag.ghostX=touch.clientX; winDrag.ghostY=touch.clientY;
    e.preventDefault();
  },{passive:false});
});

function onWinRailInput(val){
  const w=windows[curFloor].find(w=>w.id===selWinId); if(!w) return;
  const v=parseFloat(val);
  w.curtainRail = isNaN(v)||v<=0 ? null : Math.round(v*1000)/1000;
  draw();
}

function nudgeWinRail(delta){
  const w=windows[curFloor].find(w=>w.id===selWinId); if(!w) return;
  const cur = w.curtainRail||w.w;
  const nv = Math.max(0.1, Math.round((cur+delta)*1000)/1000);
  w.curtainRail = nv;
  const inp=document.getElementById('winRailInput');
  if(inp) inp.value = nv.toFixed(2);
  draw();
}

function selectWin(id){
  selWinId = id;
  selFurnId = null; selStructId = null;
  const w = windows[curFloor].find(w=>w.id===id);
  const panel = document.getElementById('winPanel');
  if(!w){ panel.style.display='none'; return; }
  panel.style.display='block';
  document.getElementById('winSelName').textContent = w.label || 'çª“';
  document.getElementById('wslW').value = w.w;
  document.getElementById('wvalW').textContent = Math.round(w.w*100)+'cm';
  // highlight active type button
  document.querySelectorAll('.win-type-btn').forEach(b=>{
    b.classList.toggle('active',
      (b.textContent==='å¼•ãé•ã„'&&w.wtype==='sliding')||
      (b.textContent==='FIX'&&w.wtype==='fixed')||
      (b.textContent==='ã‚¹ãƒªãƒƒãƒˆ'&&w.wtype==='slit')||
      (b.textContent==='åŒ—'&&w.wall==='n')||(b.textContent==='å—'&&w.wall==='s')||
      (b.textContent==='è¥¿'&&w.wall==='w')||(b.textContent==='æ±'&&w.wall==='e')||
      (b.textContent==='è‡ªå‹•'&&(w.wall==='auto'||!w.wall))
    );
  });
  // Sync curtain rail input
  const railInp = document.getElementById('winRailInput');
  if(railInp) railInp.value = w.curtainRail ? w.curtainRail.toFixed(2) : '';
  draw();
}

function deselectWin(){
  selWinId=null;
  document.getElementById('winPanel').style.display='none';
  draw();
}

function onWinWidth(val){
  const w=windows[curFloor].find(w=>w.id===selWinId); if(!w) return;
  w.w=parseFloat(val);
  document.getElementById('wvalW').textContent=Math.round(w.w*100)+'cm';
  draw();
}

function setWinType(t){
  const w=windows[curFloor].find(w=>w.id===selWinId); if(!w) return;
  w.wtype=t; selectWin(selWinId);
}

function setWinWall(wall){
  const w=windows[curFloor].find(w=>w.id===selWinId); if(!w) return;
  w.wall=wall; selectWin(selWinId);
}

function deleteWin(){
  windows[curFloor]=windows[curFloor].filter(w=>w.id!==selWinId);
  deselectWin();
}

// Wall opacity slider (3D controls)
function updateWallOpacity(val){
  const v = parseFloat(val)/100;
  document.getElementById('wallOpacityVal').textContent = val+'%';
  wallMaterials3D.forEach(mat=>{
    // Rooms with photo wallColor keep at least their base opacity
    // All others scale with slider
    if(mat._hasPhotoColor){
      mat.opacity = Math.max(v, 0.28);
    } else {
      mat.opacity = v;
    }
    mat.needsUpdate = true;
  });
}

// â”€â”€â”€ LOCAL STORAGE SAVE / LOAD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const SAVE_KEY = 'madori_simulator_v1';

function getAppState(){
  return {
    floors: floors,
    furniture: furniture,
    structEls: structEls,
    windows: windows,
    curFloor: curFloor,
    savedAt: new Date().toISOString()
  };
}

function applyAppState(state){
  if(!state) return;
  // Deep restore â€” preserve floor structure, only overwrite saved keys
  if(state.floors){
    Object.keys(state.floors).forEach(k=>{
      if(!floors[k]) floors[k] = {};
      const sf = state.floors[k];
      if(sf.W !== undefined) floors[k].W = sf.W;
      if(sf.H !== undefined) floors[k].H = sf.H;
      if(sf.rooms){
        // Sanitize: clamp room coordinates to valid range on load
        floors[k].rooms = sf.rooms.map(r=>({
          ...r,
          x: Math.max(0, r.x||0),
          y: Math.max(0, r.y||0),
          w: Math.max(0.1, r.w||1),
          h: Math.max(0.1, r.h||1),
        }));
      }
      if(sf.wallColor !== undefined) floors[k].wallColor = sf.wallColor;
    });
  }
  if(state.furniture) Object.keys(state.furniture).forEach(k=>{ furniture[k] = state.furniture[k] || []; });
  if(state.structEls) Object.keys(state.structEls).forEach(k=>{ structEls[k] = state.structEls[k] || []; });
  if(state.windows)   Object.keys(state.windows).forEach(k=>{ windows[k] = state.windows[k] || []; });
  if(state.curFloor)  curFloor = state.curFloor;
  // Recalculate nid to avoid ID collisions with loaded furniture
  let maxId = nid;
  Object.values(furniture).forEach(list=>(list||[]).forEach(f=>{ if(typeof f.id==='number' && f.id>=maxId) maxId=f.id+1; }));
  Object.values(structEls).forEach(list=>(list||[]).forEach(s=>{ if(typeof s.id==='number' && s.id>=maxId) maxId=s.id+1; }));
  nid = maxId;
}

function setSaveStatus(msg, color='rgba(180,220,180,.8)'){
  const el = document.getElementById('saveStatus');
  if(el){ el.style.color=color; el.textContent=msg; }
}

function saveToCloud(){
  const btn = document.getElementById('saveBtn');
  const icon = document.getElementById('saveBtnIcon');
  if(btn) btn.classList.add('saving');
  if(icon) icon.textContent = 'â³';
  setSaveStatus('ä¿å­˜ä¸­...');
  try {
    const state = getAppState();
    const json = JSON.stringify(state);
    localStorage.setItem(SAVE_KEY, json);
    // Verify it was actually saved
    const verify = localStorage.getItem(SAVE_KEY);
    if(!verify) throw new Error('ä¿å­˜ãƒ‡ãƒ¼ã‚¿ã®ç¢ºèªã«å¤±æ•—');
    if(icon) icon.textContent = 'âœ…';
    setSaveStatus('ä¿å­˜å®Œäº† ' + new Date().toLocaleTimeString('ja-JP',{hour:'2-digit',minute:'2-digit'}));
    setTimeout(()=>{ if(icon) icon.textContent='ğŸ’¾'; }, 2000);
  } catch(e){
    if(icon) icon.textContent = 'âŒ';
    // More specific error message
    const msg = e.name==='QuotaExceededError' ? 'å®¹é‡ä¸è¶³' : 'ä¿å­˜å¤±æ•—';
    setSaveStatus(msg, 'rgba(255,160,160,.9)');
    console.error('save error:', e.name, e.message);
    setTimeout(()=>{ if(icon) icon.textContent='ğŸ’¾'; setSaveStatus(''); }, 3000);
  }
  if(btn) btn.classList.remove('saving');
}

function loadFromCloud(){
  setSaveStatus('èª­è¾¼ä¸­...');
  try {
    const raw = localStorage.getItem(SAVE_KEY);
    if(raw){
      const state = JSON.parse(raw);
      applyAppState(state);
      draw();
      updateAreaLabel();
      renderEditRoomList();
      document.querySelectorAll('.tab').forEach(t=>t.classList.remove('active'));
      const tab = document.querySelector(`.tab[onclick*="${curFloor}"]`);
      if(tab) tab.classList.add('active');
      const d = new Date(state.savedAt);
      setSaveStatus('èª­è¾¼å®Œäº† ' + d.toLocaleString('ja-JP',{month:'2-digit',day:'2-digit',hour:'2-digit',minute:'2-digit'}));
      setTimeout(()=>setSaveStatus(''), 3000);
      return true;
    } else {
      setSaveStatus('');
      return false;
    }
  } catch(e){
    setSaveStatus('èª­è¾¼å¤±æ•—', 'rgba(255,160,160,.9)');
    console.error('load error:', e);
    setTimeout(()=>setSaveStatus(''), 3000);
    return false;
  }
}

// â”€â”€â”€ ONBOARDING WIZARD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// (obStep, obData declared early at top of script to prevent TDZ errors)

function showOnboarding(){
  document.getElementById('onboardingOverlay').style.display='flex';
  goObStep(0);
}

function goObStep(n){
  obStep = n;
  document.querySelectorAll('.ob-panel').forEach((p,i)=>{
    p.classList.toggle('active', i===n);
  });
  // Map logical step to dot index (5 dots for 0-4 visible steps)
  // house flow: 0â†’1â†’5â†’6â†’3â†’4 maps to dots 0â†’1â†’2â†’2â†’3â†’4
  // non-house:  0â†’1â†’2â†’3â†’4   maps to dots 0â†’1â†’2â†’3â†’4
  const dotMap = {0:0, 1:1, 2:2, 3:3, 4:4, 5:2, 6:2};
  const dotIdx = dotMap[n] ?? n;
  document.querySelectorAll('.ob-step-dot').forEach((d,i)=>{
    d.classList.toggle('active', i===dotIdx);
    d.classList.toggle('done', i<dotIdx);
  });
  if(n===2) buildRoomInputs();
  if(n===4) buildSummary();
}

function obBack(){
  if(obStep>0) goObStep(obStep-1);
}

function selectBuildingType(t){
  obData.buildingType = t;
  document.querySelectorAll('#buildingTypeGrid .ob-card').forEach(b=>{
    b.classList.toggle('selected',
      (b.textContent.includes('ä¸€æˆ¸å»ºã¦')&&t==='house')||
      (b.textContent.includes('ãƒãƒ³ã‚·ãƒ§ãƒ³')&&t==='mansion')||
      (b.textContent.includes('ã‚¢ãƒ‘ãƒ¼ãƒˆ')&&t==='apartment')||
      (b.textContent.includes('ãã®ä»–')&&t==='other'));
  });
  goObStep(1);
}

function selectLayout(l){
  obData.layout = l;
  document.querySelectorAll('#layoutTypeGrid .ob-card').forEach(b=>b.classList.remove('selected'));
  event.currentTarget.classList.add('selected');
  // Set default room configs per layout
  const configs = {
    '1r':  [{ id:'main',  name:'éƒ¨å±‹',   w:4.0, h:3.0 }],
    '1k':  [{ id:'ldk',   name:'LDK',    w:5.0, h:3.0 }, { id:'kitchen', name:'ã‚­ãƒƒãƒãƒ³', w:2.0, h:3.0 }],
    '1ldk':[{ id:'ldk',   name:'LDK',    w:6.5, h:3.5 }, { id:'room1',   name:'æ´‹å®¤',     w:4.0, h:3.0 }],
    '2ldk':[{ id:'ldk',   name:'LDK',    w:7.0, h:3.5 }, { id:'room1',   name:'æ´‹å®¤â‘ ',   w:4.0, h:3.0 }, { id:'room2', name:'æ´‹å®¤â‘¡', w:3.5, h:3.0 }],
    '3ldk':[{ id:'ldk',   name:'LDK',    w:7.5, h:4.0 }, { id:'room1',   name:'æ´‹å®¤â‘ ',   w:4.5, h:3.0 }, { id:'room2', name:'æ´‹å®¤â‘¡', w:3.5, h:3.0 }, { id:'room3', name:'å’Œå®¤', w:3.5, h:3.0 }],
    '4ldk':[{ id:'ldk',   name:'LDK',    w:8.0, h:4.0 }, { id:'room1',   name:'æ´‹å®¤â‘ ',   w:4.5, h:3.5 }, { id:'room2', name:'æ´‹å®¤â‘¡', w:4.0, h:3.0 }, { id:'room3', name:'æ´‹å®¤â‘¢', w:3.5, h:3.0 }, { id:'room4', name:'æ´‹å®¤â‘£', w:3.5, h:3.0 }],
  };
  obData.rooms = (configs[l]||configs['1ldk']).map(r=>({...r}));
  // House â†’ ask floor count; others â†’ ask room sizes
  if(obData.buildingType === 'house'){
    goObStep(5);
  } else {
    goObStep(2);
  }
}

function buildRoomInputs(){
  const wrap = document.getElementById('obRoomInputs');
  wrap.innerHTML = '';
  obData.rooms.forEach((r,i)=>{
    const row = document.createElement('div');
    row.className = 'ob-room-row';
    row.innerHTML = `
      <label>${r.name}</label>
      <div class="ob-dim">
        <input type="number" value="${r.w.toFixed(1)}" step="0.1" min="1" max="20"
          onchange="obData.rooms[${i}].w=parseFloat(this.value)||r.w" placeholder="å¹…">
        <span class="ob-unit">m</span>
        <span style="color:rgba(255,255,255,.3);font-size:12px;">Ã—</span>
        <input type="number" value="${r.h.toFixed(1)}" step="0.1" min="1" max="20"
          onchange="obData.rooms[${i}].h=parseFloat(this.value)||r.h" placeholder="å¥¥è¡Œ">
        <span class="ob-unit">m</span>
      </div>
    `;
    wrap.appendChild(row);
  });
  // Next button
  const btn = document.createElement('button');
  btn.className = 'ob-start-btn';
  btn.style.marginTop = '16px';
  btn.textContent = 'æ¬¡ã¸ â†’';
  btn.onclick = ()=>goObStep(3);
  wrap.appendChild(btn);
}

function selectHousehold(h){
  obData.household = h;
  document.querySelectorAll('#ob3 .ob-card').forEach(b=>b.classList.remove('selected'));
  event.currentTarget.classList.add('selected');
  goObStep(4);
}

function buildSummary(){
  const typeLabel = {house:'ä¸€æˆ¸å»ºã¦',mansion:'ãƒãƒ³ã‚·ãƒ§ãƒ³',apartment:'ã‚¢ãƒ‘ãƒ¼ãƒˆ',other:'ãã®ä»–'}[obData.buildingType]||'';
  const layoutLabel = {
    '1r':'ãƒ¯ãƒ³ãƒ«ãƒ¼ãƒ ','1k':'1K/1DK','1ldk':'1LDK','2ldk':'2LDK','3ldk':'3LDK','4ldk':'4LDKä»¥ä¸Š'
  }[obData.layout]||'';
  const hhLabel = {
    single:'ä¸€äººæš®ã‚‰ã—',couple:'ã‚«ãƒƒãƒ—ãƒ«ãƒ»å¤«å©¦',family_small:'å®¶æ—ï¼ˆå­ã‚ã‚Šï¼‰',
    family_large:'å®¶æ—ï¼ˆå­3äººä»¥ä¸Šï¼‰',roommate:'ãƒ«ãƒ¼ãƒ ã‚·ã‚§ã‚¢',other:'ãã®ä»–'
  }[obData.household]||'';

  let detailHTML = '';
  if(obData.buildingType==='house' && obData.floorDetails){
    const total = obData.floorCount||3;
    const roomLabel = {ldk:'LDK',living:'ãƒªãƒ“ãƒ³ã‚°',dining:'ãƒ€ã‚¤ãƒ‹ãƒ³ã‚°',kitchen:'ã‚­ãƒƒãƒãƒ³',
      bedroom:'å¯å®¤',washroom:'æ´—é¢ãƒ»æµ´å®¤',toilet:'ãƒˆã‚¤ãƒ¬',entrance:'ç„é–¢',garage:'ã‚¬ãƒ¬ãƒ¼ã‚¸',
      storage:'åç´',balcony:'ãƒ™ãƒ©ãƒ³ãƒ€',rooftop:'ãƒ«ãƒ¼ãƒ•ãƒãƒ«ã‚³ãƒ‹ãƒ¼',study:'æ›¸æ–',
      kids:'å­ä¾›éƒ¨å±‹',tatami:'å’Œå®¤',stair:'éšæ®µ',roof_only:'å±‹ä¸Š'};
    for(let f=1;f<=total;f++){
      const fd = obData.floorDetails[f];
      if(!fd) continue;
      const rooms = fd.rooms.map(r=>roomLabel[r]||r).join('ãƒ»');
      const note = fd.note ? `ï¼ˆ${fd.note}ï¼‰` : '';
      detailHTML += `ã€€${f}F: ${rooms||'æœªè¨­å®š'}${note}<br>`;
    }
    detailHTML = `ğŸ“ ${total}éšå»ºã¦ï¼š<br>${detailHTML}`;
  } else {
    const roomLines = obData.rooms.map(r=>`ã€€${r.name}ï¼š${r.w.toFixed(1)}m Ã— ${r.h.toFixed(1)}m`).join('<br>');
    detailHTML = `ğŸ“ å„éƒ¨å±‹ã®ã‚µã‚¤ã‚ºï¼š<br>${roomLines}`;
  }

  document.getElementById('obSummary').innerHTML = `
    ğŸ  <b>${typeLabel}</b>ã€€${layoutLabel}<br>
    ğŸ‘¥ ${hhLabel}<br>
    ${detailHTML}
  `;
}

function finishOnboarding(){
  // Build the floor plan from obData
  applyOnboardingToFloor();
  document.getElementById('onboardingOverlay').style.display='none';
  draw();
  updateAreaLabel();
  renderEditRoomList();
  renderLegend();
}

function applyOnboardingToFloor(){
  const layout = obData.layout;
  const isMultiFloor = obData.buildingType === 'house';

  // For house: build each floor from floorDetails
  if(isMultiFloor && obData.floorDetails){
    const total = obData.floorCount || 3;
    const floorIds = ['1f','2f','3f','rf','5f'];
    const COLORS = [
      [{color:'#e8dcc8',tc:'#6a5a40'},{color:'#c8dce8',tc:'#3a5a70'},{color:'#d8e8f0',tc:'#4a6a80'},{color:'#e4dfd4',tc:'#5a5040'},{color:'#d0e0f0',tc:'#3a5a90'}],
      [{color:'#e8f0e0',tc:'#3a5a30'},{color:'#f0e8d8',tc:'#8a6030'},{color:'#ddeedd',tc:'#3a6a40'}],
      [{color:'#e8e0f0',tc:'#4a3a70'},{color:'#f0e8f4',tc:'#5a3a78'},{color:'#e4e0ec',tc:'#6a5a80'}],
      [{color:'#e0f0e4',tc:'#2a5a38'},{color:'#dce8f0',tc:'#3a5a70'}],
    ];
    const roomNameMap = {ldk:'LDK',living:'ãƒªãƒ“ãƒ³ã‚°',dining:'ãƒ€ã‚¤ãƒ‹ãƒ³ã‚°',kitchen:'ã‚­ãƒƒãƒãƒ³',
      bedroom:'å¯å®¤',washroom:'æ´—é¢ãƒ»æµ´å®¤',toilet:'ãƒˆã‚¤ãƒ¬',entrance:'ç„é–¢åç´',garage:'ã‚¬ãƒ¬ãƒ¼ã‚¸',
      storage:'åç´ãƒ»ç´æˆ¸',balcony:'ãƒ™ãƒ©ãƒ³ãƒ€',rooftop:'ãƒ«ãƒ¼ãƒ•ãƒãƒ«ã‚³ãƒ‹ãƒ¼',study:'æ›¸æ–',
      kids:'å­ä¾›éƒ¨å±‹',tatami:'å’Œå®¤',stair:'éšæ®µ'};
    const roomSizeMap = {ldk:{w:6,h:3},living:{w:4,h:3},dining:{w:3,h:2.5},kitchen:{w:2.5,h:3},
      bedroom:{w:4,h:3},washroom:{w:2,h:1.6},toilet:{w:1,h:1.2},entrance:{w:2,h:1.5},
      garage:{w:3,h:5},storage:{w:2,h:1.5},balcony:{w:3,h:1},rooftop:{w:6,h:4},
      study:{w:3,h:2.5},kids:{w:3,h:3},tatami:{w:3,h:3},stair:{w:1.5,h:1.5}};

    // Show appropriate floor tabs
    document.querySelectorAll('.tab').forEach(t=>{
      const fid=t.getAttribute('onclick')?.match(/'(\w+)'/)?.[1];
      if(fid) t.style.display = floorIds.indexOf(fid)<total ? 'block':'none';
    });

    for(let fi=0;fi<total;fi++){
      const fid = floorIds[fi];
      const fd = obData.floorDetails[fi+1] || {rooms:[],note:''};
      const roomIds = fd.rooms.length>0 ? fd.rooms : (fi===0?['entrance','washroom','toilet']:fi===total-1&&total>=4?['rooftop']:['bedroom']);
      let xOff=0, maxH=3;
      const rooms = roomIds.map((rid,i)=>{
        const sz = roomSizeMap[rid]||{w:3,h:3};
        maxH=Math.max(maxH,sz.h);
        const r={id:rid+'_'+fi, name:roomNameMap[rid]||rid, x:xOff, y:0, w:sz.w, h:sz.h,
          ...(COLORS[fi%COLORS.length][i%COLORS[fi%COLORS.length].length])};
        xOff+=sz.w;
        return r;
      });
      floors[fid].rooms = rooms;
      floors[fid].W = Math.max(xOff, 4);
      floors[fid].H = maxH;
      furniture[fid] = [];
    }
    curFloor='1f';
    document.querySelectorAll('.tab').forEach(t=>t.classList.remove('active'));
    const tab=document.querySelector('.tab[onclick*="1f"]');
    if(tab) tab.classList.add('active');
    return;
  }

  // Build rooms for current floor (2f or main floor)
  const floorId = isMultiFloor ? '2f' : '1f';
  curFloor = floorId;

  const COLORS = [
    { color:'#e8f0e0', tc:'#3a5a30' },
    { color:'#e8e0f0', tc:'#4a3a6a' },
    { color:'#f0e8e0', tc:'#6a4a30' },
    { color:'#e0e8f0', tc:'#3a4a6a' },
    { color:'#f0f0e0', tc:'#5a5a30' },
  ];

  let totalW = 0, maxH = 0;
  obData.rooms.forEach(r=>{ totalW+=r.w; maxH=Math.max(maxH,r.h); });

  // Update floor dimensions
  floors[floorId].W = Math.max(totalW, 4.0);
  floors[floorId].H = Math.max(maxH, 2.5);

  // Replace rooms
  let xOff = 0;
  floors[floorId].rooms = obData.rooms.map((r,i)=>({
    id: r.id,
    name: r.name,
    x: xOff,
    y: (maxH - r.h) / 2,
    w: r.w,
    h: r.h,
    ...(COLORS[i % COLORS.length])
  }));
  // Advance xOff after building
  obData.rooms.forEach(r=>{ xOff+=r.w; });

  // Clear furniture for fresh start
  furniture[floorId] = [];

  // Update floor tabs visibility based on building type
  if(!isMultiFloor){
    // Single floor â€” show only 1F tab
    document.querySelectorAll('.tab').forEach(t=>{
      const fid = t.getAttribute('onclick')?.match(/'(\w+)'/)?.[1];
      if(fid && fid !== '1f') t.style.display='none';
    });
    curFloor='1f';
    // Apply to 1f instead
    floors['1f'].W = floors[floorId].W;
    floors['1f'].H = floors[floorId].H;
    floors['1f'].rooms = floors[floorId].rooms.map(r=>({...r}));
    furniture['1f'] = [];
    if(floorId !== '1f'){
      floors[floorId].rooms = floors['1f'].rooms.map(r=>({...r}));
    }
  }

  // Update tab active state
  document.querySelectorAll('.tab').forEach(t=>t.classList.remove('active'));
  const activeTab = document.querySelector(`.tab[onclick*="${curFloor}"]`);
  if(activeTab) activeTab.classList.add('active');
}

// â”€â”€â”€ HOUSE FLOOR DETAIL WIZARD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const FLOOR_ROOM_OPTIONS = [
  { id:'ldk',      label:'LDK',         emoji:'ğŸ³' },
  { id:'living',   label:'ãƒªãƒ“ãƒ³ã‚°',     emoji:'ğŸ›‹ï¸' },
  { id:'dining',   label:'ãƒ€ã‚¤ãƒ‹ãƒ³ã‚°',   emoji:'ğŸ½ï¸' },
  { id:'kitchen',  label:'ã‚­ãƒƒãƒãƒ³',     emoji:'ğŸ¥˜' },
  { id:'bedroom',  label:'å¯å®¤',         emoji:'ğŸ›ï¸' },
  { id:'washroom', label:'æ´—é¢ãƒ»æµ´å®¤',   emoji:'ğŸš¿' },
  { id:'toilet',   label:'ãƒˆã‚¤ãƒ¬',       emoji:'ğŸš½' },
  { id:'entrance', label:'ç„é–¢ãƒ»åœŸé–“',   emoji:'ğŸšª' },
  { id:'garage',   label:'ã‚¬ãƒ¬ãƒ¼ã‚¸',     emoji:'ğŸš—' },
  { id:'storage',  label:'åç´ãƒ»ç´æˆ¸',   emoji:'ğŸ“¦' },
  { id:'balcony',  label:'ãƒ™ãƒ©ãƒ³ãƒ€',     emoji:'ğŸª´' },
  { id:'rooftop',  label:'ãƒ«ãƒ¼ãƒ•ãƒãƒ«ã‚³ãƒ‹ãƒ¼', emoji:'â˜€ï¸' },
  { id:'study',    label:'æ›¸æ–ãƒ»ä»•äº‹éƒ¨å±‹', emoji:'ğŸ’»' },
  { id:'kids',     label:'å­ä¾›éƒ¨å±‹',     emoji:'ğŸ§’' },
  { id:'tatami',   label:'å’Œå®¤',         emoji:'ğŸ' },
  { id:'stair',    label:'éšæ®µãƒ»ãƒ›ãƒ¼ãƒ«', emoji:'ğŸªœ' },
  { id:'roof_only',label:'å±‹ä¸Šã®ã¿',     emoji:'ğŸ ' },
];

// obCurrentFloor, obFloorDetails declared early at top of script

function selectFloorCount(n){
  obData.floorCount = n;
  obFloorDetails = {};
  obCurrentFloor = 1;
  document.querySelectorAll('#ob5 .ob-card').forEach(b=>{
    b.classList.toggle('selected', b.textContent.startsWith(String(n)));
  });
  showFloorDetailStep(1);
}

function showFloorDetailStep(floorNum){
  obCurrentFloor = floorNum;
  const total = obData.floorCount || 3;
  // Initialize floor detail if not exists
  if(!obFloorDetails[floorNum]) obFloorDetails[floorNum] = { rooms:[], note:'' };

  // Update title
  const isRoof = floorNum === total && total >= 4;
  const floorLabel = isRoof ? `${floorNum}éšï¼ˆå±‹ä¸Šãƒ»RFï¼‰` : `${floorNum}éš`;
  document.getElementById('ob6Title').textContent = `${floorLabel}ã®æ§‹æˆ`;

  // Build room option grid
  const grid = document.getElementById('ob6RoomGrid');
  grid.innerHTML = '';
  FLOOR_ROOM_OPTIONS.forEach(opt=>{
    // Skip rooftop option for non-top floors, skip roof_only for lower floors
    if(opt.id==='rooftop' && floorNum < total) return;
    if(opt.id==='roof_only' && floorNum < total) return;
    if(opt.id==='garage' && floorNum > 1) return;

    const btn = document.createElement('button');
    btn.className = 'ob-card' + (obFloorDetails[floorNum].rooms.includes(opt.id) ? ' selected' : '');
    btn.style.fontSize = '11px';
    btn.innerHTML = `${opt.emoji}<span>${opt.label}</span>`;
    btn.onclick = ()=>{
      btn.classList.toggle('selected');
      const rooms = obFloorDetails[floorNum].rooms;
      const idx = rooms.indexOf(opt.id);
      if(idx>=0) rooms.splice(idx,1); else rooms.push(opt.id);
    };
    grid.appendChild(btn);
  });

  // Restore note
  document.getElementById('ob6Note').value = obFloorDetails[floorNum].note || '';

  // Progress dots: show current floor in subtitle
  document.querySelector('#ob6 .ob-sub').innerHTML =
    `ã“ã®éšã«ã¯ä½•ãŒã‚ã‚Šã¾ã™ã‹ï¼Ÿ <b style="color:#7aba7a;">${floorNum} / ${total}éš</b><br>
     <small style="color:rgba(255,255,255,.45);">è¤‡æ•°é¸æŠã§ãã¾ã™</small>`;

  goObStep(6);
}

function nextFloorDetail(){
  const total = obData.floorCount || 3;
  // Save note
  obFloorDetails[obCurrentFloor].note = document.getElementById('ob6Note').value;

  if(obCurrentFloor < total){
    showFloorDetailStep(obCurrentFloor + 1);
  } else {
    // All floors done â†’ world info into obData.floorDetails, go to household
    obData.floorDetails = {...obFloorDetails};
    goObStep(3);
  }
}

// Override obBack to handle floor detail navigation
function obBack(){
  if(obStep === 6){
    if(obCurrentFloor > 1){
      showFloorDetailStep(obCurrentFloor - 1);
    } else {
      goObStep(5);
    }
  } else if(obStep === 5){
    goObStep(1);
  } else if(obStep > 0){
    goObStep(obStep - 1);
  }
}

// â”€â”€â”€ SHARE VIA URL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function showShareModal(){
  const modal = document.getElementById('shareModal');
  modal.style.display = 'flex';
  const input = document.getElementById('shareUrlInput');
  const btn = document.getElementById('copyShareBtn');
  input.value = 'ç”Ÿæˆä¸­...';
  btn.textContent = 'ã‚³ãƒ”ãƒ¼';
  btn.disabled = true;
  try {
    const url = await generateShareUrl();
    input.value = url;
    btn.disabled = false;
    const warn = document.getElementById('shareUrlWarn');
    warn.style.display = url.length > 4000 ? 'block' : 'none';
    warn.style.display = 'block';
    if(url.length <= 2000){
      warn.style.color = 'rgba(150,220,150,.8)';
      warn.textContent = `âœ… URLé•·ã•: ${url.length}æ–‡å­—`;
    } else if(url.length <= 4000){
      warn.style.color = 'rgba(255,200,100,.8)';
      warn.textContent = `âš ï¸ URLé•·ã•: ${url.length}æ–‡å­—ï¼ˆé•·ã‚ï¼‰`;
    } else {
      warn.style.color = 'rgba(255,120,120,.8)';
      warn.textContent = `âŒ URLé•·ã•: ${url.length}æ–‡å­—ï¼ˆé•·ã™ãã‚‹å¯èƒ½æ€§ï¼‰`;
    }
  } catch(e){
    input.value = 'ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ';
    console.error('share url error:', e);
  }
}

// Compress bytes â†’ base64url string
async function deflateB64(str){
  const bytes = new TextEncoder().encode(str);
  const cs = new CompressionStream('deflate-raw');
  const writer = cs.writable.getWriter();
  writer.write(bytes); writer.close();
  const chunks = [];
  const reader = cs.readable.getReader();
  while(true){ const {done,value}=await reader.read(); if(done) break; chunks.push(value); }
  const buf = new Uint8Array(chunks.reduce((a,b)=>a+b.length,0));
  let off=0; chunks.forEach(ch=>{ buf.set(ch,off); off+=ch.length; });
  // base64url (no padding, URL-safe)
  return btoa(String.fromCharCode(...buf)).replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
}

// Decompress base64url string â†’ original string
async function inflateB64(b64){
  const std = b64.replace(/-/g,'+').replace(/_/g,'/');
  const bin = atob(std);
  const bytes = Uint8Array.from(bin, c=>c.charCodeAt(0));
  const ds = new DecompressionStream('deflate-raw');
  const writer = ds.writable.getWriter();
  writer.write(bytes); writer.close();
  const chunks = [];
  const reader = ds.readable.getReader();
  while(true){ const {done,value}=await reader.read(); if(done) break; chunks.push(value); }
  const buf = new Uint8Array(chunks.reduce((a,b)=>a+b.length,0));
  let off=0; chunks.forEach(ch=>{ buf.set(ch,off); off+=ch.length; });
  return new TextDecoder().decode(buf);
}

function buildCompactState(){
  // v3: cm integers + skip empty floors, same structure as v2
  const state = getAppState();
  const cm = v => Math.round(v * 100); // meters â†’ cm integer
  const compact = { v:3, cf:state.curFloor, f:{}, fu:{}, w:{}, se:{} };
  Object.keys(state.floors).forEach(k=>{
    const fl = state.floors[k];
    const fu = (state.furniture[k]||[]);
    const wi = (state.windows[k]||[]);
    const se = (state.structEls[k]||[]);
    // Skip completely empty floors to save space
    const hasData = (fl.rooms&&fl.rooms.length) || fu.length || wi.length || se.length;
    if(!hasData) return;
    compact.f[k] = { W:cm(fl.W), H:cm(fl.H),
      r:(fl.rooms||[]).map(r=>{
        const o={id:r.id, n:r.name, x:cm(r.x), y:cm(r.y), w:cm(r.w), h:cm(r.h), c:r.color, tc:r.tc};
        if(r.stair) o.st=1;
        if(r.zoneType) o.zt=r.zoneType;
        if(r.rotation) o.rot=r.rotation;
        return o;
      })
    };
    compact.fu[k] = fu.map(f=>{
      const o={id:f.id, t:f.type, x:cm(f.x), y:cm(f.y), w:cm(f.w), h:cm(f.h), c:f.color, l:f.label};
      if(f.rotation) o.r=f.rotation;
      if(f.styleVariant) o.sv=f.styleVariant;
      if(f.expandDir) o.ed=f.expandDir;
      if(f._openW) { o.ow=cm(f._openW); o.oh=cm(f._openH); }
      if(f._closedW) { o.cw=cm(f._closedW); o.ch=cm(f._closedH); }
      return o;
    });
    compact.w[k] = wi.map(w=>{
      const o={id:w.id, wt:w.wtype, x:cm(w.x), y:cm(w.y), ww:cm(w.w)};
      if(w.wall) o.wa=w.wall;
      if(w.curtainRail) o.cr=w.curtainRail;
      return o;
    });
    compact.se[k] = se.map(s=>({id:s.id, t:s.stype, x:cm(s.x), y:cm(s.y), w:cm(s.w), h:cm(s.h)}));
  });
  return compact;
}

async function generateShareUrl(){
  const compact = buildCompactState();
  const json = JSON.stringify(compact);
  const encoded = await deflateB64(json);
  const base = location.href.split('?')[0].split('#')[0];
  return base + '?d=' + encoded;
}

function copyShareUrl(){
  const input = document.getElementById('shareUrlInput');
  input.select();
  try {
    navigator.clipboard.writeText(input.value).then(()=>{
      document.getElementById('copyShareBtn').textContent = 'âœ… ã‚³ãƒ”ãƒ¼å®Œäº†';
      setTimeout(()=>{ document.getElementById('copyShareBtn').textContent = 'ã‚³ãƒ”ãƒ¼'; }, 2000);
    });
  } catch(e){
    document.execCommand('copy');
    document.getElementById('copyShareBtn').textContent = 'âœ… ã‚³ãƒ”ãƒ¼å®Œäº†';
    setTimeout(()=>{ document.getElementById('copyShareBtn').textContent = 'ã‚³ãƒ”ãƒ¼'; }, 2000);
  }
}

async function loadFromShareUrl(){
  const params = new URLSearchParams(location.search);
  const d = params.get('d');
  if(!d) return false;
  try {
    let json;
    try { json = await inflateB64(d); }
    catch(e) { json = decodeURIComponent(atob(d)); } // legacy v1 fallback
    const compact = JSON.parse(json);
    const v = compact.v||1;

    if(v === 3){
      // v3: cm integers, same f/fu/w/se key structure as v2
      const m = v => v / 100; // cm â†’ meters
      Object.keys(compact.f||{}).forEach(k=>{
        if(!floors[k]) return;
        const cf = compact.f[k];
        floors[k].W = m(cf.W); floors[k].H = m(cf.H);
        floors[k].rooms = (cf.r||[]).map(r=>({
          id:r.id, name:r.n,
          x:m(r.x), y:m(r.y), w:m(r.w), h:m(r.h),
          color:r.c, tc:r.tc,
          ...(r.st?{stair:true}:{}),
          ...(r.zt?{zoneType:r.zt}:{}),
          ...(r.rot?{rotation:r.rot}:{})
        }));
      });
      Object.keys(compact.fu||{}).forEach(k=>{
        furniture[k] = (compact.fu[k]||[]).map(f=>({
          id:f.id, type:f.t,
          x:m(f.x), y:m(f.y), w:m(f.w), h:m(f.h),
          color:f.c, rotation:f.r||0, label:f.l,
          ...(f.sv?{styleVariant:f.sv,st:f.sv}:{}),
          ...(f.ed?{expandDir:f.ed}:{}),
          ...(f.ow?{_openW:m(f.ow),_openH:m(f.oh)}:{}),
          ...(f.cw?{_closedW:m(f.cw),_closedH:m(f.ch)}:{})
        }));
      });
      Object.keys(compact.w||{}).forEach(k=>{
        windows[k] = (compact.w[k]||[]).map(w=>({
          id:w.id, wtype:w.wt,
          x:m(w.x), y:m(w.y), w:m(w.ww),
          ...(w.wa?{wall:w.wa}:{}),
          ...(w.cr?{curtainRail:w.cr}:{})
        }));
      });
      Object.keys(compact.se||{}).forEach(k=>{
        structEls[k] = (compact.se[k]||[]).map(s=>({
          id:s.id, stype:s.t,
          x:m(s.x), y:m(s.y), w:m(s.w), h:m(s.h)
        }));
      });
    } else {
      // v1/v2: meters floats, separate keys
      Object.keys(compact.f||{}).forEach(k=>{
        if(!floors[k]) return;
        const cf = compact.f[k];
        floors[k].W = cf.W; floors[k].H = cf.H;
        floors[k].rooms = (cf.r||[]).map(r=>({
          id:r.id, name:r.n, x:r.x, y:r.y, w:r.w, h:r.h,
          color:r.c, tc:r.tc,
          ...(r.st?{stair:true}:{}),
          ...(r.zt?{zoneType:r.zt}:{}),
          ...(r.rot?{rotation:r.rot}:{})
        }));
      });
      Object.keys(compact.fu||{}).forEach(k=>{
        furniture[k] = (compact.fu[k]||[]).map(f=>({
          id:f.id, type:f.t, x:f.x, y:f.y, w:f.w, h:f.h,
          color:f.c, rotation:f.r||0, label:f.l,
          ...(f.sv?{styleVariant:f.sv,st:f.sv}:{}),
          ...(f.ed?{expandDir:f.ed}:{}),
          ...(f.ow?{_openW:f.ow,_openH:f.oh}:{}),
          ...(f.cw?{_closedW:f.cw,_closedH:f.ch}:{})
        }));
      });
      Object.keys(compact.w||{}).forEach(k=>{
        windows[k] = (compact.w[k]||[]).map(w=>({
          id:w.id, wtype:w.wt, x:w.x, y:w.y, w:w.ww,
          ...(w.wa?{wall:w.wa}:{}),
          ...(w.cr?{curtainRail:w.cr}:{})
        }));
      });
      Object.keys(compact.se||{}).forEach(k=>{
        structEls[k] = (compact.se[k]||[]).map(s=>({
          id:s.id, stype:s.t, x:s.x, y:s.y, w:s.w, h:s.h
        }));
      });
    }
    if(compact.cf) curFloor = compact.cf;
    // Recalculate nid to avoid ID collisions
    let maxId2 = nid;
    Object.values(furniture).forEach(list=>(list||[]).forEach(f=>{ if(typeof f.id==='number' && f.id>=maxId2) maxId2=f.id+1; }));
    nid = maxId2;
    return true;
  } catch(e){
    console.error('share URL parse error:', e);
    return false;
  }
}

// Auto-save every 60 seconds
let lastSaveHash = '';
function stateHash(){
  const s = getAppState();
  return JSON.stringify({f: Object.keys(s.furniture).map(k=>s.furniture[k].length), s: Object.keys(s.structEls).map(k=>s.structEls[k].length)});
}
setInterval(()=>{
  const h = stateHash();
  if(h !== lastSaveHash){ lastSaveHash = h; saveToCloud(); }
}, 60000);

// â”€â”€â”€ MOBILE UI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const IS_MOBILE = () => window.innerWidth <= 680;

function initMobileUI(){
  if(!IS_MOBILE()) return;

  // Show bottom bar
  document.getElementById('mobileBottomBar').style.display = 'flex';

  // Add canvas bottom padding so content isn't hidden behind bottom bar
  document.getElementById('canvasWrap').style.paddingBottom = '56px';

  // Clone furniture palette into sheet
  const src = document.getElementById('furniturePalette');
  const dest = document.getElementById('sheetFurniture');
  if(src && dest && !dest.hasChildNodes()){
    dest.innerHTML = src.innerHTML;
    // Re-attach drag events to cloned items
    dest.querySelectorAll('.furniture-item').forEach(item => {
      item.addEventListener('touchstart', e => {
        // Touch-tap to place furniture at center of canvas
        const type  = item.dataset.type;
        const w     = parseFloat(item.dataset.w)||1;
        const h     = parseFloat(item.dataset.h)||1;
        const color = item.dataset.color||'#d0c8b8';
        const label = item.dataset.label||type;
        const fl = floors[curFloor];
        const f = {
          id: 'f'+(Date.now()%1000000),
          type, w, h,
          x: Math.max(0, fl.W/2 - w/2),
          y: Math.max(0, fl.H/2 - h/2),
          color, label,
          rotation: 0
        };
        if(!furniture[curFloor]) furniture[curFloor] = [];
        furniture[curFloor].push(f);
        selFurnId = f.id;
        setMode('furniture');
        draw();
        closeSheet();
        e.preventDefault();
      }, {passive:false});
    });
  }
}

let _sheetCurrentTab = 0;

function mobileTab(tab){
  if(!IS_MOBILE()) return;
  const tabMap = { furniture:0, edit:1, save:2 };
  const idx = tabMap[tab] ?? 0;

  // Update bottom bar active state
  ['furniture','edit','save'].forEach(t => {
    const btn = document.getElementById('mobBtn'+t.charAt(0).toUpperCase()+t.slice(1));
    if(btn) btn.classList.toggle('active', t===tab);
  });

  // Switch sheet tab
  switchSheetTab(idx);

  // Open sheet
  openSheet();
}

function switchSheetTab(idx){
  _sheetCurrentTab = idx;
  document.querySelectorAll('.sheet-tab').forEach((t,i) => t.classList.toggle('active', i===idx));
  document.querySelectorAll('.sheet-panel').forEach((p,i) => p.classList.toggle('active', i===idx));

  // Sync edit panel content into sheet when edit tab selected
  if(idx === 1) syncEditToSheet();
}

function syncEditToSheet(){
  const src = document.getElementById('epRoomControls');
  const dest = document.getElementById('sheetEdit');
  if(!src || !dest) return;

  // Build edit UI in sheet
  const fl = floors[curFloor];
  const r = fl && selRoomId ? fl.rooms.find(r=>r.id===selRoomId) : null;

  if(!r){
    // Show zone add buttons + room list
    let html = '<div style="padding:12px;">';
    html += '<div class="ep-title" style="font-size:10px;color:rgba(255,255,255,.4);text-transform:uppercase;letter-spacing:.06em;margin-bottom:8px;">ã‚¾ãƒ¼ãƒ³ã‚’è¿½åŠ </div>';
    html += '<div id="mobileZoneGrid" style="display:grid;grid-template-columns:1fr 1fr;gap:6px;margin-bottom:14px;"></div>';
    html += '<div class="ep-title" style="font-size:10px;color:rgba(255,255,255,.4);text-transform:uppercase;letter-spacing:.06em;margin-bottom:8px;">éƒ¨å±‹ä¸€è¦§ï¼ˆã‚¿ãƒƒãƒ—ã—ã¦é¸æŠï¼‰</div>';
    // Room list
    const rooms = fl ? fl.rooms : [];
    rooms.forEach(rm => {
      html += `<div style="padding:10px;background:rgba(255,255,255,.06);border-radius:8px;margin-bottom:6px;cursor:pointer;"
        onclick="selectRoom('${rm.id}');syncEditToSheet();">
        <div style="font-size:13px;font-weight:600;">${rm.name.replace('\n',' ')}</div>
        <div style="font-size:11px;color:rgba(255,255,255,.45);">${Math.round(rm.w*100)}cm Ã— ${Math.round(rm.h*100)}cm</div>
      </div>`;
    });
    html += '</div>';
    dest.innerHTML = html;
    // Populate zone buttons after innerHTML is set (avoids quote issues)
    const zg = dest.querySelector('#mobileZoneGrid');
    if(zg){
      [['kitchen_walk','ğŸš¶ ã‚­ãƒƒãƒãƒ³æ­©è¡Œ'],['dining_zone','ğŸ½ï¸ ãƒ€ã‚¤ãƒ‹ãƒ³ã‚°'],
       ['storage_zone','ğŸ“¦ åç´'],['passage_zone','â†”ï¸ é€šè·¯'],
       ['work_zone','ğŸ’» ãƒ¯ãƒ¼ã‚¯'],['free_zone','ï¼‹ ãƒ•ãƒªãƒ¼']
      ].forEach(([zt,label])=>{
        const btn = document.createElement('button');
        btn.className = 'action-btn';
        btn.style.cssText = 'padding:10px;font-size:11px;justify-content:center;border-radius:8px;width:100%;';
        btn.textContent = label;
        btn.onclick = ()=>{ addZone(zt); closeSheet(); };
        zg.appendChild(btn);
      });
    }
    return;
  }

  // Room selected â€” show coordinate controls
  let html = '<div style="padding:12px;">';
  html += `<div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:10px;">
    <div style="font-size:14px;font-weight:700;">${r.name.replace('\n',' ')}</div>
    <button onclick="if(confirm('å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')){floors[curFloor].rooms=floors[curFloor].rooms.filter(rm=>rm.id!==selRoomId);selRoomId=null;draw();syncEditToSheet();}"
      style="background:rgba(200,80,80,.3);border:none;border-radius:6px;color:#ff9090;padding:6px 10px;font-size:11px;cursor:pointer;">å‰Šé™¤</button>
  </div>`;

  // Coord rows helper
  const row = (label, prop, val, min, max) => `
    <div style="display:flex;align-items:center;gap:8px;margin-bottom:8px;">
      <div style="width:40px;font-size:11px;color:rgba(255,255,255,.5);">${label}</div>
      <button onclick="nudgeRoom('${prop}',-0.01)" style="width:36px;height:36px;border:none;background:rgba(255,255,255,.08);border-radius:6px;color:#8fbc8f;font-size:18px;cursor:pointer;">âˆ’</button>
      <input type="number" value="${val.toFixed(2)}" step="0.01" min="${min}" max="${max}"
        style="flex:1;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.15);border-radius:6px;
               color:#fff;text-align:center;padding:8px;font-size:14px;font-family:'DM Mono',monospace;"
        oninput="onSlider('${prop}',this.value);syncEditToSheet();"
        onchange="onSlider('${prop}',this.value);syncEditToSheet();">
      <button onclick="nudgeRoom('${prop}',0.01)" style="width:36px;height:36px;border:none;background:rgba(255,255,255,.08);border-radius:6px;color:#8fbc8f;font-size:18px;cursor:pointer;">ï¼‹</button>
      <div style="width:16px;font-size:10px;color:rgba(255,255,255,.3);">m</div>
    </div>`;

  html += '<div style="font-size:10px;color:rgba(255,255,255,.35);text-transform:uppercase;letter-spacing:.06em;margin-bottom:6px;">ä½ç½®</div>';
  html += row('X', 'x', r.x, 0, fl.W - r.w);
  html += row('Y', 'y', r.y, 0, fl.H - r.h);
  html += '<div style="font-size:10px;color:rgba(255,255,255,.35);text-transform:uppercase;letter-spacing:.06em;margin:10px 0 6px;">ã‚µã‚¤ã‚º</div>';
  html += row('å¹…', 'w', r.w, 0.1, fl.W);
  html += row('å¥¥è¡Œ', 'h', r.h, 0.1, fl.H);
  html += '<div style="font-size:10px;color:rgba(255,255,255,.35);text-transform:uppercase;letter-spacing:.06em;margin:10px 0 6px;">å›è»¢</div>';
  html += `<div style="display:flex;gap:6px;margin-bottom:10px;">
    ${[0,90,180,270].map(deg=>`<button onclick="setRoomRotation(${deg});syncEditToSheet()"
      style="flex:1;padding:10px;border:none;border-radius:8px;cursor:pointer;font-size:12px;
             background:${(r.rotation||0)===deg?'rgba(143,188,143,.3)':'rgba(255,255,255,.08)'};
             color:${(r.rotation||0)===deg?'#8fbc8f':'rgba(255,255,255,.6)'};">${deg}Â°</button>`).join('')}
  </div>`;

  html += `<button onclick="selRoomId=null;draw();syncEditToSheet();"
    style="width:100%;padding:10px;background:rgba(255,255,255,.08);border:none;border-radius:8px;color:rgba(255,255,255,.5);font-size:12px;cursor:pointer;margin-top:4px;">
    â† éƒ¨å±‹ä¸€è¦§ã«æˆ»ã‚‹</button>`;
  html += '</div>';
  dest.innerHTML = html;
}

function openSheet(){
  document.getElementById('mobileSheet').classList.add('open');
}

function closeSheet(){
  document.getElementById('mobileSheet').classList.remove('open');
  // Reset bottom bar active
  document.querySelectorAll('.mob-nav-btn').forEach(b => b.classList.remove('active'));
}

// Swipe down to close sheet
(function(){
  let startY = 0;
  const sheet = document.getElementById('mobileSheet');
  const handle = document.getElementById('sheetHandle');
  if(!sheet || !handle) return;
  handle.addEventListener('touchstart', e => { startY = e.touches[0].clientY; }, {passive:true});
  handle.addEventListener('touchmove', e => {
    const dy = e.touches[0].clientY - startY;
    if(dy > 60) closeSheet();
  }, {passive:true});
})();

// Handle window resize: init mobile if needed
window.addEventListener('resize', ()=>{
  if(IS_MOBILE()) initMobileUI();
  else {
    const bar = document.getElementById('mobileBottomBar');
    if(bar) bar.style.display = 'none';
    document.getElementById('canvasWrap').style.paddingBottom = '';
  }
});

// â”€â”€â”€ STARTUP (must be last â€” needs obStep/obData/all functions) â”€â”€
(()=>{
  // 1. Check for share URL first (highest priority)
  const hasShareParam = new URLSearchParams(location.search).get('d');
  if(hasShareParam){
    loadFromShareUrl().then(ok=>{
      if(ok){
        document.getElementById('onboardingOverlay').style.display='none';
        history.replaceState(null,'',location.pathname);
        draw(); updateAreaLabel(); renderEditRoomList(); renderLegend();
        setSaveStatus('å…±æœ‰ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ', 'rgba(180,220,180,.9)');
        setTimeout(()=>setSaveStatus(''), 3000);
      }
    });
    return;
  }
  // Init mobile UI
  initMobileUI();

  // 2. localStorage â€” if raw data exists, ALWAYS skip onboarding
  const raw = localStorage.getItem(SAVE_KEY);
  if(raw){
    try {
      loadFromCloud();
    } catch(e) {
      console.warn('load error on startup:', e);
    }
    // Hide onboarding regardless of load success â€” data existed
    document.getElementById('onboardingOverlay').style.display='none';
  } else {
    showOnboarding();
  }
})();

</script>
</body>
</html>
